#!/usr/bin/env python3
"""
üîß MODELS - Task Scoring System

Sistema de pontua√ß√£o configur√°vel para prioriza√ß√£o de tarefas.
Implementa√ß√£o baseada nas corre√ß√µes da cr√≠tica t√©cnica.

Usage:
    from streamlit_extension.models.scoring import (
        calc_task_scores, 
        priority_tuple,
        TDD_BONUS_RED_FIRST
    )
    
Features:
- Pesos configur√°veis externamente
- TDD scoring corrigido (RED > GREEN > REFACTOR)
- Value density calculation
- Tie-breakers determin√≠sticos para heap
- Modular e test√°vel
"""

from __future__ import annotations
from typing import Dict, Set, Optional
from dataclasses import dataclass

from .task_models import Task, TaskPriorityScore

# üéõÔ∏è PESOS CONFIGUR√ÅVEIS (tunable via environment/config)
W_PRIORITY = 10.0      # Prioridade expl√≠cita da tarefa (1=cr√≠tico, 5=backlog)
W_VALUE_DENSITY = 6.0  # Valor/esfor√ßo ratio
W_UNBLOCK = 3.0        # Quantas tarefas esta tarefa desbloqueia
W_CRITICAL_PATH = 2.0  # Posi√ß√£o no caminho cr√≠tico
W_TDD_BONUS = 1.0      # Bonus para tarefas TDD
W_AGING = 0.2          # Bonus por antiguidade (aging)

# üîÑ TDD SCORING CORRIGIDO - RED primeiro!
TDD_BONUS_RED_FIRST = {
    1: 3.0,  # RED = maior prioridade
    2: 2.0,  # GREEN = m√©dia prioridade  
    3: 1.0   # REFACTOR = menor prioridade
}

@dataclass
class ScoringWeights:
    """Configura√ß√£o de pesos para scoring"""
    priority: float = W_PRIORITY
    value_density: float = W_VALUE_DENSITY
    unblock: float = W_UNBLOCK
    critical_path: float = W_CRITICAL_PATH
    tdd_bonus: float = W_TDD_BONUS
    aging: float = W_AGING

def task_effort_safe(task: Task) -> int:
    """
    Retorna esfor√ßo da tarefa com fallback consistente.
    Implementa corre√ß√£o da cr√≠tica para effort_estimate None.
    """
    return max(
        (getattr(task, "effort_estimate", None) or
         getattr(task, "estimate_minutes", None) or
         getattr(task, "story_points", None) or 1), 
        1  # M√≠nimo 1 para evitar divis√£o por zero
    )

def tdd_bonus_score(task: Task) -> float:
    """
    Calcula bonus TDD corrigido: RED > GREEN > REFACTOR.
    Corre√ß√£o da cr√≠tica - RED deve ter maior prioridade.
    """
    if task.tdd_order and task.tdd_order in TDD_BONUS_RED_FIRST:
        return TDD_BONUS_RED_FIRST[task.tdd_order]
    return 0.0

def value_density_score(task: Task) -> float:
    """
    Calcula densidade de valor: prioridade_invertida / esfor√ßo.
    Maior prioridade (1) = maior valor, menor esfor√ßo = maior densidade.
    """
    priority = max(1, min(5, task.priority or 3))  # Clamp 1-5
    priority_value = 6 - priority  # 1‚Üí5, 2‚Üí4, 3‚Üí3, 4‚Üí2, 5‚Üí1
    effort = task_effort_safe(task)
    
    return priority_value / effort

def unblock_score(task_key: str, adjacency: Dict[str, Set[str]]) -> float:
    """
    Calcula quantas tarefas esta tarefa desbloqueia.
    Tarefas que desbloqueiam muitas outras t√™m prioridade maior.
    """
    return float(len(adjacency.get(task_key, set())))

def critical_path_score(
    task_key: str, 
    critical_time: Dict[str, int], 
    critical_nodes: Set[str]
) -> float:
    """
    Calcula score do caminho cr√≠tico.
    Tarefas no caminho cr√≠tico t√™m prioridade m√°xima.
    """
    if not critical_time:
        return 0.0
        
    max_critical_time = max(critical_time.values())
    
    # Se est√° no caminho cr√≠tico, usar tempo cr√≠tico normalizado
    if task_key in critical_nodes:
        task_critical_time = critical_time.get(task_key, 0)
        return (task_critical_time / max_critical_time) * 10.0
    
    return 0.0

def aging_score(task: Task) -> float:
    """
    Calcula score de aging (antiguidade).
    TODO: Implementar c√°lculo real baseado em created_at.
    """
    # Placeholder - em implementa√ß√£o real, calcular dias desde cria√ß√£o
    if task.created_at:
        return 1.0
    return 0.0

def calc_task_scores(
    tasks: list[Task],
    adjacency: Dict[str, Set[str]],
    critical_time: Dict[str, int],
    critical_nodes: Set[str],
    weights: Optional[ScoringWeights] = None
) -> Dict[str, TaskPriorityScore]:
    """
    Calcula scores de prioridade para todas as tarefas.
    
    Args:
        tasks: Lista de tarefas para pontuar
        adjacency: Grafo de depend√™ncias {task_key: {dependent_tasks}}
        critical_time: Tempo cr√≠tico de cada tarefa
        critical_nodes: Set de tarefas no caminho cr√≠tico
        weights: Pesos customizados (opcional)
        
    Returns:
        Dict mapeando task_key para TaskPriorityScore
    """
    if weights is None:
        weights = ScoringWeights()
    
    scores = {}
    
    for task in tasks:
        task_key = task.task_key
        
        # Calcular scores individuais
        priority_score = 6 - (task.priority or 3)  # 1=5pts, 5=1pt
        value_density = value_density_score(task)
        unblock = unblock_score(task_key, adjacency)
        critical_path = critical_path_score(task_key, critical_time, critical_nodes)
        tdd_bonus = tdd_bonus_score(task)
        aging = aging_score(task)
        
        # Score total ponderado
        total_score = (
            weights.priority * priority_score +
            weights.value_density * value_density +
            weights.unblock * unblock +
            weights.critical_path * critical_path +
            weights.tdd_bonus * tdd_bonus +
            weights.aging * aging
        )
        
        scores[task_key] = TaskPriorityScore(
            task_key=task_key,
            total_score=total_score,
            priority_score=priority_score,
            value_density_score=value_density,
            unblock_score=unblock,
            critical_path_score=critical_path,
            tdd_bonus_score=tdd_bonus,
            aging_score=aging
        )
    
    return scores

def priority_tuple(task: Task, score: TaskPriorityScore) -> tuple:
    """
    Cria tupla de prioridade para heap com tie-breakers determin√≠sticos.
    Implementa corre√ß√£o da cr√≠tica para heap inst√°vel.
    
    Returns:
        Tupla para heapq (min-heap): todos os valores invertidos para max-heap
        Ordem: score_total, priority, -effort, task_key
    """
    # heapq √© min-heap, ent√£o invertemos sinais para comportamento max-heap
    return (
        -score.total_score,              # Maior score primeiro
        -(6 - (task.priority or 3)),     # Maior prioridade primeiro (1=cr√≠tico)
        task_effort_safe(task),          # Menor esfor√ßo primeiro (desempate)
        task.task_key                    # Ordem alfab√©tica (determin√≠stica)
    )

def validate_scoring_monotonicity(tasks: list[Task]) -> Dict[str, bool]:
    """
    Valida monotonicidade do sistema de scoring.
    Para testes - garante que maior prioridade ‚Üí maior score.
    """
    results = {}
    
    # Test value density monotonicity
    if len(tasks) >= 2:
        task_high_prio = next((t for t in tasks if t.priority == 1), None)
        task_low_prio = next((t for t in tasks if t.priority == 5), None)
        
        if task_high_prio and task_low_prio:
            high_density = value_density_score(task_high_prio)
            low_density = value_density_score(task_low_prio)
            results['value_density_monotonic'] = high_density > low_density
    
    # Test TDD bonus monotonicity  
    tdd_red = next((t for t in tasks if t.tdd_order == 1), None)
    tdd_refactor = next((t for t in tasks if t.tdd_order == 3), None)
    
    if tdd_red and tdd_refactor:
        red_bonus = tdd_bonus_score(tdd_red)
        refactor_bonus = tdd_bonus_score(tdd_refactor)
        results['tdd_bonus_red_first'] = red_bonus > refactor_bonus
    
    return results

# üéØ PRESETS DE CONFIGURA√á√ÉO

SCORING_PRESET_BALANCED = ScoringWeights(
    priority=10.0,
    value_density=6.0,
    unblock=3.0,
    critical_path=2.0,
    tdd_bonus=1.0,
    aging=0.2
)

SCORING_PRESET_CRITICAL_PATH_FOCUS = ScoringWeights(
    priority=8.0,
    value_density=4.0,
    unblock=2.0,
    critical_path=10.0,  # Foco no caminho cr√≠tico
    tdd_bonus=1.0,
    aging=0.1
)

SCORING_PRESET_TDD_WORKFLOW = ScoringWeights(
    priority=6.0,
    value_density=3.0,
    unblock=2.0,
    critical_path=1.0,
    tdd_bonus=8.0,       # Foco no workflow TDD
    aging=0.1
)

SCORING_PRESET_BUSINESS_VALUE = ScoringWeights(
    priority=15.0,       # Foco na prioridade de neg√≥cio
    value_density=10.0,  # Foco no valor/esfor√ßo
    unblock=1.0,
    critical_path=1.0,
    tdd_bonus=0.5,
    aging=0.1
)

# üéØ SISTEMA DE SCORING INTEGRADO

@dataclass
class ScoringPreset:
    """Preset de configura√ß√£o de scoring"""
    name: str
    weights: ScoringWeights
    description: str = ""

class ScoringSystem:
    """
    Sistema de scoring integrado com presets configur√°veis.
    Interface limpa para o TaskExecutionPlanner.
    """
    
    def __init__(self):
        self.presets = {
            "balanced": ScoringPreset(
                name="balanced",
                weights=SCORING_PRESET_BALANCED,
                description="Configura√ß√£o balanceada para uso geral"
            ),
            "critical_path": ScoringPreset(
                name="critical_path", 
                weights=SCORING_PRESET_CRITICAL_PATH_FOCUS,
                description="Foco no caminho cr√≠tico"
            ),
            "tdd_workflow": ScoringPreset(
                name="tdd_workflow",
                weights=SCORING_PRESET_TDD_WORKFLOW, 
                description="Foco no workflow TDD (Red-Green-Refactor)"
            ),
            "business_value": ScoringPreset(
                name="business_value",
                weights=SCORING_PRESET_BUSINESS_VALUE,
                description="Foco no valor de neg√≥cio"
            )
        }
    
    def get_preset(self, preset_name: str) -> ScoringPreset:
        """
        Obt√©m preset de scoring por nome.
        
        Args:
            preset_name: Nome do preset
            
        Returns:
            ScoringPreset configurado
            
        Raises:
            ValueError: Se preset n√£o existe
        """
        if preset_name not in self.presets:
            available = ", ".join(self.presets.keys())
            raise ValueError(f"Preset '{preset_name}' n√£o existe. Dispon√≠veis: {available}")
        
        return self.presets[preset_name]
    
    def calculate_score(self, task: Task, preset: ScoringPreset) -> float:
        """
        Calcula score de uma tarefa usando preset espec√≠fico.
        
        Args:
            task: Tarefa para calcular score
            preset: Preset de configura√ß√£o
            
        Returns:
            Score calculado
        """
        # Usar a fun√ß√£o calc_task_scores existente mas com um √∫nico task
        adjacency = {}  # N√£o temos contexto de adjac√™ncia aqui
        scores = calc_task_scores([task], adjacency, preset.weights)
        
        # calc_task_scores retorna dict, pegar o score da nossa task
        return scores.get(task.task_key, 1.0)
    
    def list_presets(self) -> Dict[str, str]:
        """Lista presets dispon√≠veis com descri√ß√µes"""
        return {name: preset.description for name, preset in self.presets.items()}

# üìä EXPORTA√á√ïES
__all__ = [
    'calc_task_scores',
    'priority_tuple',
    'task_effort_safe',
    'tdd_bonus_score',
    'value_density_score',
    'ScoringWeights',
    'ScoringSystem',
    'ScoringPreset',
    'TDD_BONUS_RED_FIRST',
    'validate_scoring_monotonicity',
    'SCORING_PRESET_BALANCED',
    'SCORING_PRESET_CRITICAL_PATH_FOCUS', 
    'SCORING_PRESET_TDD_WORKFLOW',
    'SCORING_PRESET_BUSINESS_VALUE'
]
diff a/scripts/testing/api_equivalence_validation.py b/scripts/testing/api_equivalence_validation.py	(rejected hunks)
@@ -1,94 +1,83 @@
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 """
 ðŸ“Š API Equivalence Validation Suite (Hardened)
 
 Valida a equivalÃªncia entre a API legada (DatabaseManager) e a API modular.
 
 Destaques:
 - Schema idempotente 100% compatÃ­vel com o seed controlado
 - Seed consistente com o schema
 - ModularAdapter mantÃ©m um Ãºnico contexto por execuÃ§Ã£o e alinha FRAMEWORK_DB/FRAMEWORK_DB_PATH
 - ComparaÃ§Ã£o robusta (normalizaÃ§Ã£o + modo leniente opcional)
 - RelatÃ³rios humano (stdout) e CI (JSON/JUnit)
 """
 
 from __future__ import annotations
 
 import sys
 import os
 import tempfile
-import time
 import logging
 import argparse
-import json
 import sqlite3
 import math
 from pathlib import Path
-from typing import Dict, List, Any, Tuple, Optional, Callable, Iterable
-from dataclasses import dataclass, asdict, field
+from typing import Callable, Iterable
+from dataclasses import asdict, field
 from xml.etree.ElementTree import Element, SubElement, ElementTree
 
+# Legacy import - keeping for hybrid compatibility
+from streamlit_extension.utils.database import DatabaseManager  # Legacy compatibility
+from streamlit_extension.database import get_connection, list_epics, list_tasks
+from streamlit_extension.services import ServiceContainer
+# Validation framework imports
+from streamlit_extension.database.health import DatabaseHealthChecker
+
+import json
+import time
+import difflib
+from typing import Dict, List, Any, Optional, Tuple
+from dataclasses import dataclass
+from streamlit_extension.database import check_health
+from streamlit_extension.database.connection import get_connection_context
+
+HAS_MODULAR = True
+
 # -----------------------------------------------------------------------------
 # Logging
 # -----------------------------------------------------------------------------
 logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
 logger = logging.getLogger("api_equivalence")
 
 # -----------------------------------------------------------------------------
 # Caminho do projeto para imports
 # -----------------------------------------------------------------------------
 project_root = Path(__file__).resolve().parents[2]
 sys.path.insert(0, str(project_root))
 
-# -----------------------------------------------------------------------------
-# Imports do projeto (protegidos)
-# -----------------------------------------------------------------------------
-try:
-    # Legado
-    from streamlit_extension.utils.database import DatabaseManager  # type: ignore
-except Exception as e:
-    DatabaseManager = None  # type: ignore
-    logger.warning(f"NÃ£o foi possÃ­vel importar DatabaseManager legado: {e}")
-
-try:
-    # Novo (modular)
-    from streamlit_extension.database import (  # type: ignore
-        get_connection, transaction, check_health,
-        optimize, create_schema_if_needed, seed_initial_data
-    )
-    from streamlit_extension.database.connection import get_connection_context  # type: ignore
-    from streamlit_extension.database.queries import (  # type: ignore
-        list_epics, list_all_epics, list_tasks, list_all_tasks,
-        list_timer_sessions, get_user_stats, get_achievements
-    )
-    HAS_MODULAR = True
-except Exception as e:
-    HAS_MODULAR = False
-    logger.warning(f"NÃ£o foi possÃ­vel importar API modular: {e}")
-
 # -----------------------------------------------------------------------------
 # Data classes
 # -----------------------------------------------------------------------------
 @dataclass
 class ValidationResult:
     test_name: str
     legacy_result: Any
     modular_result: Any
     equivalent: bool
     legacy_time_ms: float
     modular_time_ms: float
     performance_ratio: float
     error_message: Optional[str] = None
     notes: Optional[str] = None
 
 
 @dataclass
 class ValidationReport:
     timestamp: str
     total_tests: int
     passed_tests: int
     failed_tests: int
     equivalence_percentage: float
     average_performance_ratio: float
     breaking_changes: List[str]
@@ -767,25 +756,152 @@ def main() -> None:
 
         if args.junit_out:
             if not report.test_results:
                 report = validator.build_report(detailed=True)
             save_junit(report, args.junit_out)
             print(f"ðŸ§ª JUnit XML salvo em: {args.junit_out}")
 
         # CÃ³digo de saÃ­da para CI
         exit_code = 0 if (report.equivalence_percentage == 100.0 or args.performance_only) else 1
         sys.exit(exit_code)
 
     except Exception as e:
         logger.error(f"Falha na validaÃ§Ã£o: {e}", exc_info=True)
         sys.exit(1)
     finally:
         # Limpeza do DB temporÃ¡rio
         if temp_file and not args.keep_db:
             try:
                 Path(temp_file).unlink(missing_ok=True)
                 logger.info("DB temporÃ¡rio removido.")
             except Exception as e:
                 logger.warning(f"Falha ao remover DB temporÃ¡rio: {e}")
 
 if __name__ == "__main__":
     main()
+
+@dataclass
+class APIComparisonResult:
+    """Result of API equivalence comparison."""
+    legacy_result: Any
+    modular_result: Any
+    service_result: Any
+    equivalent: bool
+    differences: List[str]
+    performance_delta: float
+
+class APIEquivalenceValidator:
+    """Test equivalence between legacy, modular, and service layer APIs."""
+    def __init__(self):
+        # Legacy API
+        self.db_manager = DatabaseManager()
+        # Modular API
+        try:
+            self.modular_connection = get_connection()
+        except Exception as e:
+            self.modular_connection = None
+        # Service layer
+        try:
+            self.service_container = ServiceContainer()
+        except Exception as e:
+            self.service_container = None
+
+    def compare_epic_operations(self) -> APIComparisonResult:
+        import time
+        # Legacy
+        start = time.time()
+        try:
+            legacy_epics = self.db_manager.get_epics()
+            legacy_time = time.time() - start
+            legacy_error = None
+        except Exception as e:
+            legacy_epics = None
+            legacy_time = time.time() - start
+            legacy_error = str(e)
+
+        # Modular
+        start = time.time()
+        try:
+            modular_epics = list_epics() if self.modular_connection else None
+            modular_time = time.time() - start
+            modular_error = None
+        except Exception as e:
+            modular_epics = None
+            modular_time = time.time() - start
+            modular_error = str(e)
+
+        # Service
+        start = time.time()
+        try:
+            if self.service_container:
+                epic_service = self.service_container.get_epic_service()
+                service_result = epic_service.get_all()
+                service_epics = service_result.data if getattr(service_result, "success", False) else None
+            else:
+                service_epics = None
+            service_time = time.time() - start
+            service_error = None
+        except Exception as e:
+            service_epics = None
+            service_time = time.time() - start
+            service_error = str(e)
+
+        # Compare
+        differences: List[str] = []
+        equivalent = True
+        if legacy_epics is not None and modular_epics is not None:
+            if len(legacy_epics) != len(modular_epics):
+                differences.append(f"Epic count differs: legacy={len(legacy_epics)}, modular={len(modular_epics)}")
+                equivalent = False
+
+        perf_delta = (modular_time - legacy_time) if (legacy_time is not None and modular_time is not None) else 0.0
+        return APIComparisonResult(
+            legacy_result=(legacy_epics, legacy_error),
+            modular_result=(modular_epics, modular_error),
+            service_result=(service_epics, service_error),
+            equivalent=equivalent,
+            differences=differences,
+            performance_delta=perf_delta,
+        )
+
+    def run_comprehensive_validation(self) -> Dict[str, APIComparisonResult]:
+        results: Dict[str, APIComparisonResult] = {}
+        results["epic_operations"] = self.compare_epic_operations()
+        return results
+
+    def generate_validation_report(self, results: Dict[str, APIComparisonResult]) -> str:
+        report: List[str] = []
+        report.append("=== API EQUIVALENCE VALIDATION REPORT ===")
+        report.append(f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}")
+        report.append("")
+        for test_name, result in results.items():
+            report.append(f"## {test_name.upper()}")
+            report.append(f"Equivalent: {'âœ… YES' if result.equivalent else 'âŒ NO'}")
+            if result.differences:
+                report.append("Differences found:")
+                for diff in result.differences:
+                    report.append(f"  - {diff}")
+            report.append(f"Performance delta: {result.performance_delta:.4f}s")
+            report.append("")
+        return "\n".join(report)
+
+# Global validator instance
+api_validator = APIEquivalenceValidator()
+
+def validate_with_modular_api() -> str:
+    """Basic modular API smoke test."""
+    try:
+        conn = get_connection()
+        with conn:
+            cursor = conn.execute("SELECT COUNT(*) FROM framework_epics")
+            count = cursor.fetchone()[0]
+        return f"Modular API working - {count} epics found"
+    except Exception as e:
+        return f"Modular API failed: {e}"
+
+def run_hybrid_validation():
+    """Convenience runner to print the hybrid validation report."""
+    results = api_validator.run_comprehensive_validation()
+    report = api_validator.generate_validation_report(results)
+    print(report)
+    return results
+

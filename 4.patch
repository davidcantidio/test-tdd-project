 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/utils/shutdown.py b/streamlit_extension/utils/shutdown.py
new file mode 100644
index 0000000000000000000000000000000000000000..979f57ca35b7d6f500d1e8362401d08cdc75c240
--- /dev/null
+++ b/streamlit_extension/utils/shutdown.py
@@ -0,0 +1,350 @@
+#!/usr/bin/env python3
+"""
+Graceful Shutdown Handler
+Ensures clean shutdown of all resources and connections.
+"""
+
+import signal
+import sys
+import time
+import threading
+import atexit
+import json
+import logging
+from pathlib import Path
+from typing import List, Callable, Optional, Dict, Any
+from datetime import datetime
+from contextlib import contextmanager
+from dataclasses import dataclass
+from enum import Enum
+
+logger = logging.getLogger(__name__)
+
+
+class GracefulShutdownHandler:
+    """Handle graceful shutdown of the application."""
+
+    def __init__(self, timeout: int = 30):
+        """
+        Initialize shutdown handler.
+
+        Args:
+            timeout: Maximum time to wait for graceful shutdown (seconds)
+        """
+        self.timeout = timeout
+        self.is_shutting_down = False
+        self.shutdown_handlers: List[Callable] = []
+        self.active_connections: List[Any] = []
+        self.active_threads: List[threading.Thread] = []
+        self._lock = threading.Lock()
+
+        # Register signal handlers
+        self._register_signal_handlers()
+
+        # Register atexit handler
+        atexit.register(self._cleanup)
+
+    def _register_signal_handlers(self):
+        """Register signal handlers for graceful shutdown."""
+        for sig in [signal.SIGTERM, signal.SIGINT, signal.SIGHUP]:
+            signal.signal(sig, self._signal_handler)
+
+    def _signal_handler(self, signum, frame):
+        """Handle shutdown signals."""
+        logger.info(f"Received signal {signum}, initiating graceful shutdown...")
+        self.shutdown()
+
+    def register_handler(self, handler: Callable):
+        """Register a shutdown handler."""
+        with self._lock:
+            self.shutdown_handlers.append(handler)
+
+    def register_connection(self, connection: Any):
+        """Register an active connection."""
+        with self._lock:
+            self.active_connections.append(connection)
+
+    def unregister_connection(self, connection: Any):
+        """Unregister a connection."""
+        with self._lock:
+            if connection in self.active_connections:
+                self.active_connections.remove(connection)
+
+    def shutdown(self):
+        """Initiate graceful shutdown."""
+        if self.is_shutting_down:
+            logger.warning("Shutdown already in progress")
+            return
+
+        self.is_shutting_down = True
+        logger.info("Starting graceful shutdown...")
+
+        try:
+            # Execute all shutdown handlers
+            self._execute_shutdown_handlers()
+
+            # Close all connections
+            self._close_connections()
+
+            # Wait for threads to complete
+            self._wait_for_threads()
+
+            # Final cleanup
+            self._cleanup()
+
+            logger.info("Graceful shutdown completed")
+        except Exception as e:
+            logger.error(f"Error during shutdown: {e}")
+            self._force_shutdown()
+
+    def _execute_shutdown_handlers(self):
+        """Execute all registered shutdown handlers."""
+        logger.info(f"Executing {len(self.shutdown_handlers)} shutdown handlers...")
+
+        for handler in self.shutdown_handlers:
+            try:
+                handler()
+            except Exception as e:
+                logger.error(f"Error in shutdown handler {getattr(handler, '__name__', str(handler))}: {e}")
+
+    def _close_connections(self):
+        """Close all active connections."""
+        logger.info(f"Closing {len(self.active_connections)} active connections...")
+
+        for conn in self.active_connections[:]:  # Copy list to avoid modification during iteration
+            try:
+                if hasattr(conn, 'close'):
+                    conn.close()
+                elif hasattr(conn, 'disconnect'):
+                    conn.disconnect()
+                elif hasattr(conn, '__exit__'):
+                    conn.__exit__(None, None, None)
+            except Exception as e:
+                logger.error(f"Error closing connection: {e}")
+
+    def _wait_for_threads(self):
+        """Wait for active threads to complete."""
+        logger.info(f"Waiting for {len(self.active_threads)} threads to complete...")
+
+        start_time = time.time()
+        for thread in self.active_threads:
+            remaining_time = self.timeout - (time.time() - start_time)
+            if remaining_time > 0:
+                thread.join(timeout=remaining_time)
+                if thread.is_alive():
+                    logger.warning(f"Thread {thread.name} did not complete in time")
+
+    def _cleanup(self):
+        """Final cleanup operations."""
+        logger.info("Performing final cleanup...")
+        # Any final cleanup operations
+
+    def _force_shutdown(self):
+        """Force immediate shutdown."""
+        logger.error("Forcing immediate shutdown!")
+        sys.exit(1)
+
+
+# Global shutdown handler instance
+shutdown_handler = GracefulShutdownHandler()
+
+
+class DatabaseShutdownManager:
+    """Manage database connections during shutdown."""
+
+    def __init__(self):
+        self.connections = []
+        self.transactions = []
+
+    def register_connection(self, conn):
+        """Register a database connection."""
+        self.connections.append(conn)
+        shutdown_handler.register_connection(conn)
+
+    def register_transaction(self, transaction):
+        """Register an active transaction."""
+        self.transactions.append(transaction)
+
+    def shutdown(self):
+        """Shutdown all database connections gracefully."""
+        logger.info("Shutting down database connections...")
+
+        # First, commit or rollback all transactions
+        for transaction in self.transactions:
+            try:
+                if hasattr(transaction, 'rollback'):
+                    transaction.rollback()
+                    logger.info("Rolled back pending transaction")
+            except Exception as e:
+                logger.error(f"Error rolling back transaction: {e}")
+
+        # Then close all connections
+        for conn in self.connections:
+            try:
+                if hasattr(conn, 'commit'):
+                    conn.commit()  # Commit any pending changes
+                if hasattr(conn, 'close'):
+                    conn.close()
+                logger.info("Database connection closed")
+            except Exception as e:
+                logger.error(f"Error closing database connection: {e}")
+
+        self.connections.clear()
+        self.transactions.clear()
+
+
+# Register database shutdown handler
+db_shutdown_manager = DatabaseShutdownManager()
+shutdown_handler.register_handler(db_shutdown_manager.shutdown)
+
+
+class SessionStatePersistence:
+    """Persist session state during shutdown using JSON."""
+
+    def __init__(self, state_dir: str = ".session_state"):
+        self.state_dir = Path(state_dir)
+        self.state_dir.mkdir(exist_ok=True)
+
+    def save_session_state(self, session_id: str, state: Dict[str, Any]):
+        """Save session state to disk using JSON (SECURITY FIX: replaced pickle)."""
+        file_path = self.state_dir / f"session_{session_id}.json"
+
+        try:
+            # Filter out non-serializable items
+            serializable_state = self._filter_serializable(state)
+
+            with open(file_path, 'w', encoding='utf-8') as f:
+                json.dump(serializable_state, f, indent=2, default=str)
+
+            logger.info(f"Session state saved for {session_id}")
+        except Exception as e:
+            logger.error(f"Failed to save session state: {e}")
+
+    def restore_session_state(self, session_id: str) -> Optional[Dict[str, Any]]:
+        """Restore session state from disk using JSON (SECURITY FIX: replaced pickle)."""
+        file_path = self.state_dir / f"session_{session_id}.json"
+
+        if not file_path.exists():
+            return None
+
+        try:
+            with open(file_path, 'r', encoding='utf-8') as f:
+                state = json.load(f)
+
+            logger.info(f"Session state restored for {session_id}")
+            return state
+        except Exception as e:
+            logger.error(f"Failed to restore session state: {e}")
+            return None
+
+    def _filter_serializable(self, obj: Any) -> Any:
+        """Filter out non-serializable objects."""
+        if isinstance(obj, (str, int, float, bool, type(None))):
+            return obj
+        elif isinstance(obj, (list, tuple)):
+            return [self._filter_serializable(item) for item in obj]
+        elif isinstance(obj, dict):
+            return {k: self._filter_serializable(v) for k, v in obj.items()
+                    if not k.startswith('_')}  # Skip private keys
+        else:
+            # Try to JSON serialize, if fails return string representation
+            try:
+                json.dumps(obj, default=str)
+                return obj
+            except Exception:
+                return str(obj)
+
+
+# Session persistence instance
+session_persistence = SessionStatePersistence()
+
+
+def save_all_sessions():
+    """Save all active sessions during shutdown."""
+    try:
+        import streamlit as st
+        if hasattr(st, 'session_state'):
+            # In real implementation, would need to track all sessions
+            session_persistence.save_session_state("current", dict(st.session_state))
+    except Exception as e:
+        logger.error(f"Failed to save sessions: {e}")
+
+
+# Register session saving
+shutdown_handler.register_handler(save_all_sessions)
+
+
+class ResourceManager:
+    """Manage cleanup of various resources."""
+
+    def __init__(self):
+        self.temp_files: List[Path] = []
+        self.open_files: List[Any] = []
+        self.background_tasks: List[threading.Thread] = []
+
+    def register_temp_file(self, file_path: Path):
+        """Register a temporary file for cleanup."""
+        self.temp_files.append(file_path)
+
+    def register_open_file(self, file_handle):
+        """Register an open file handle."""
+        self.open_files.append(file_handle)
+
+    def cleanup(self):
+        """Clean up all registered resources."""
+        logger.info("Cleaning up resources...")
+
+        # Close open files
+        for file_handle in self.open_files:
+            try:
+                file_handle.close()
+            except Exception as e:
+                logger.error(f"Error closing file: {e}")
+
+        # Delete temporary files
+        for temp_file in self.temp_files:
+            try:
+                if temp_file.exists():
+                    temp_file.unlink()
+                    logger.debug(f"Deleted temporary file: {temp_file}")
+            except Exception as e:
+                logger.error(f"Error deleting temp file: {e}")
+
+        # Stop background tasks
+        for task in self.background_tasks:
+            try:
+                if task.is_alive():
+                    if hasattr(task, 'stop'):
+                        task.stop()
+            except Exception as e:
+                logger.error(f"Error stopping background task: {e}")
+
+
+# Resource manager instance
+resource_manager = ResourceManager()
+shutdown_handler.register_handler(resource_manager.cleanup)
+
+
+# Context manager for graceful shutdown
+@contextmanager
+def graceful_shutdown_context():
+    """Context manager for operations that need graceful shutdown."""
+    resource = None
+    try:
+        resource = acquire_resource()
+        shutdown_handler.register_connection(resource)
+        yield resource
+    finally:
+        if resource:
+            shutdown_handler.unregister_connection(resource)
+            release_resource(resource)
+
+
+# Placeholder resource management functions
+def acquire_resource():
+    """Placeholder for acquiring a resource."""
+    return None
+
+
+def release_resource(resource: Any):
+    """Placeholder for releasing a resource."""
+    return None
+
+
+# Decorator for shutdown-aware functions
+def shutdown_aware(func: Callable) -> Callable:
+    """Decorator to make functions aware of shutdown state."""
+
+    def wrapper(*args, **kwargs):
+        if shutdown_handler.is_shutting_down:
+            logger.warning(f"Skipping {func.__name__} due to shutdown")
+            return None
+        return func(*args, **kwargs)
+
+    return wrapper
+
+
+# Export main components
+__all__ = [
+    'shutdown_handler',
+    'graceful_shutdown_context',
+    'shutdown_aware',
+    'db_shutdown_manager',
+    'resource_manager',
+    'session_persistence'
+]
+
+
+# Main initialization
+def init_shutdown_handler():
+    """Initialize the shutdown handler system."""
+    logger.info("Shutdown handler initialized")
+
+
+# Auto-initialize
+init_shutdown_handler()
+ 
EOF
)
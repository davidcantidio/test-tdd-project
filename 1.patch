 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/utils/database.py b/streamlit_extension/utils/database.py
index 6f5446a0d2da38f12f5f1c89d17e174eebb7cdc2..91715543554136d5ee3203c01c260eca36c9b33b 100644
--- a/streamlit_extension/utils/database.py
+++ b/streamlit_extension/utils/database.py
@@ -1,49 +1,54 @@
 """
 🗄️ Database Management Utilities
 
 Streamlit-optimized database operations with:
 - Connection pooling
 - Caching strategies
 - SQLAlchemy integration
 - Error handling
 """
 
 import sqlite3
 import time
 from pathlib import Path
 from typing import (
+    Union,
     Optional,
+    List,
     Dict,
     Any,
-    List,
-    Union,
-    Iterator,
     Tuple,
+    Callable,
+    Iterator,
+    ContextManager,
     Generator,
+    TypeVar,
+    Generic,
     NamedTuple,
 )
+from sqlite3 import Connection as SQLiteConnection
 from contextlib import contextmanager
 from datetime import datetime
 from enum import Enum
 import json
 import logging
 
 # Graceful imports
 try:
     import sqlalchemy as sa
     from sqlalchemy import create_engine, text
     from sqlalchemy.pool import StaticPool
     from sqlalchemy.engine import Connection, Result
     SQLALCHEMY_AVAILABLE = True
 except ImportError:
     sa = None
     create_engine = None
     text = None
     StaticPool = None
     Connection = None
     Result = Any  # type: ignore[assignment]
     SQLALCHEMY_AVAILABLE = False
 
 try:
     import pandas as pd
     PANDAS_AVAILABLE = True
@@ -366,51 +371,51 @@ class DatabaseManager(PerformancePaginationMixin):
 
     This class provides a centralized interface for database operations with:
     - Connection pooling for performance
     - Transaction management
     - Error handling and logging
     - Circuit breaker integration
     - Health monitoring
 
     Examples:
         Basic usage:
         >>> db = DatabaseManager()
         >>> with db.get_connection() as conn:
         ...     result = conn.execute("SELECT * FROM users")
 
         Transaction usage:
         >>> with db.get_connection() as conn:
         ...     with db.transaction(conn):
         ...         conn.execute("INSERT INTO users ...")
 
     Attributes:
         connection_pool (SQLAlchemy.pool): Database connection pool
         circuit_breaker (CircuitBreaker): Circuit breaker for resilience
         health_monitor (HealthMonitor): Connection health monitoring
     """
 
-    def __init__(self, framework_db_path: str = "framework.db", timer_db_path: str = "task_timer.db"):
+    def __init__(self, framework_db_path: str = "framework.db", timer_db_path: str = "task_timer.db") -> None:
         """Initialize database manager with connection paths.
 
         Creates SQLAlchemy engines for both databases when available and sets up
         internal structures required for caching and performance monitoring.
 
         Args:
             framework_db_path: Path to framework SQLite database file.
             timer_db_path: Path to timer database file. Timer functionality is
                 disabled if the file does not exist.
 
         Raises:
             DatabaseError: If engine initialization fails.
 
         Example:
             >>> db_manager = DatabaseManager("/app/data/framework.db")
             >>> db_manager = DatabaseManager("./framework.db", "./timer.db")
         """
         self.framework_db_path = Path(framework_db_path)
         self.timer_db_path = Path(timer_db_path)
         self.engines = {}
 
         if SQLALCHEMY_AVAILABLE:
             self._initialize_engines()
     
     def _initialize_engines(self) -> None:
@@ -425,92 +430,92 @@ class DatabaseManager(PerformancePaginationMixin):
                 framework_url,
                 poolclass=StaticPool,
                 connect_args={
                     "check_same_thread": False,
                     "timeout": 20
                 },
                 echo=False
             )
         
         # Timer database engine  
         if self.timer_db_path.exists():
             timer_url = f"sqlite:///{self.timer_db_path}"
             self.engines["timer"] = create_engine(
                 timer_url,
                 poolclass=StaticPool,
                 connect_args={
                     "check_same_thread": False,
                     "timeout": 20
                 },
                 echo=False
             )
     
     @contextmanager
     def get_connection(
         self, database_name: str = "framework"
-    ) -> Generator[Union[Connection, sqlite3.Connection], None, None]:
+    ) -> Iterator[Union[Connection, SQLiteConnection]]:
         """
         Get a database connection from the pool.
 
         Args:
             database_name (str): Name of the database to connect to.
                 Defaults to "framework".
 
         Returns:
             Connection: SQLAlchemy connection object with context manager support.
 
         Raises:
             ConnectionError: If unable to establish connection after retries.
             CircuitBreakerOpenError: If circuit breaker is open.
 
         Examples:
             >>> db = DatabaseManager()
             >>> with db.get_connection() as conn:
             ...     result = conn.execute("SELECT COUNT(*) FROM users")
             ...     print(result.fetchone()[0])
         """
         if SQLALCHEMY_AVAILABLE and database_name in self.engines:
             conn = self.engines[database_name].connect()
             try:
                 conn.execute(text("PRAGMA foreign_keys = ON"))
                 yield conn
             finally:
                 conn.close()
         else:
             db_path = self.framework_db_path if database_name == "framework" else self.timer_db_path
             if not db_path.exists():
                 raise FileNotFoundError(f"Database not found: {db_path}")
 
             conn = sqlite3.connect(str(db_path), timeout=20)
             conn.row_factory = sqlite3.Row
             conn.execute("PRAGMA foreign_keys = ON")
             try:
                 yield conn
             finally:
                 conn.close()
 
-    def release_connection(self, connection: Union[Connection, sqlite3.Connection]) -> None:
+    def release_connection(self, connection: Union[Connection, SQLiteConnection]) -> None:
         """Return connection to pool with cleanup.
 
         This method is provided for cases where a connection obtained via
         :meth:`get_connection` needs to be closed manually instead of using the
         context manager protocol.
 
         Args:
             connection: Connection instance to be returned.
 
         Example:
             >>> conn = next(db_manager.get_connection())
             >>> db_manager.release_connection(conn)
         """
         try:
             connection.close()
         except Exception:  # pragma: no cover - best effort
             logger.warning("Failed to close connection", exc_info=True)
 
     def execute_query(
         self,
         query: str,
         params: Optional[Dict[str, Any]] = None,
         database_name: str = "framework",
     ) -> Union[Result, List[Dict[str, Any]]]:
         """Execute a raw SQL query.
@@ -1707,53 +1712,59 @@ class DatabaseManager(PerformancePaginationMixin):
                                datetime('now'), datetime('now'))
                     """), {
                         "title": title,
                         "description": description,
                         "epic_id": epic_id,
                         "tdd_phase": tdd_phase,
                         "priority": priority,
                         "estimate_minutes": estimate_minutes
                     })
                     conn.commit()
                     return result.lastrowid
                 else:
                     cursor = conn.cursor()
                     cursor.execute("""
                         INSERT INTO framework_tasks 
                         (title, description, epic_id, tdd_phase, priority, 
                          estimate_minutes, status, created_at, updated_at)
                         VALUES (?, ?, ?, ?, ?, ?, 'todo', datetime('now'), datetime('now'))
                     """, (title, description, epic_id, tdd_phase, priority, estimate_minutes))
                     conn.commit()
                     return cursor.lastrowid
         except Exception as e:
             print(f"Error creating task: {e}")
             return None
     
-    def update_task(self, task_id: int, title: str = None, description: str = None,
-                   tdd_phase: str = None, priority: int = None, 
-                   estimate_minutes: int = None) -> bool:
+    def update_task(
+        self,
+        task_id: int,
+        title: Optional[str] = None,
+        description: Optional[str] = None,
+        tdd_phase: Optional[str] = None,
+        priority: Optional[int] = None,
+        estimate_minutes: Optional[int] = None,
+    ) -> bool:
         """Update task details.
         
         Args:
             task_id: ID of the task to update
             title: New title (optional)
             description: New description (optional)
             tdd_phase: New TDD phase (optional)
             priority: New priority (optional)
             estimate_minutes: New estimate (optional)
             
         Returns:
             True if successful, False otherwise
         """
         try:
             # Build dynamic update query
             updates = []
             params = {"task_id": task_id}
             
             if title is not None:
                 updates.append("title = :title")
                 params["title"] = title
             
             if description is not None:
                 updates.append("description = :description")
                 params["description"] = description
 
EOF
)
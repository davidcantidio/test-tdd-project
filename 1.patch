 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/utils/security_testing.py b/streamlit_extension/utils/security_testing.py
new file mode 100644
index 0000000000000000000000000000000000000000..bca158100c54e1412ee23aa9ca3b451f246e5421
--- /dev/null
+++ b/streamlit_extension/utils/security_testing.py
@@ -0,0 +1,68 @@
+"""Utilities for basic security testing simulations."""
+from __future__ import annotations
+
+from html import escape
+import secrets
+from typing import Dict, List
+
+try:
+    from tests.security_scenarios.xss_payloads import XSS_PAYLOADS
+    from tests.security_scenarios.csrf_scenarios import CSRF_SCENARIOS
+except Exception:  # pragma: no cover - fallback for runtime without tests
+    XSS_PAYLOADS = {}
+    CSRF_SCENARIOS = {}
+
+
+class XSSTestHelper:
+    """Helper methods for XSS testing."""
+
+    def generate_xss_payloads(self) -> Dict[str, List[str]]:
+        """Return predefined XSS payloads."""
+        return XSS_PAYLOADS
+
+    def test_input_sanitization(self, payload: str) -> str:
+        """Sanitize input using HTML escaping and basic filtering."""
+        sanitized = escape(payload, quote=True)
+        for keyword in ["javascript:", "onerror", "onload"]:
+            sanitized = sanitized.replace(keyword, "")
+        return sanitized
+
+    def validate_output_encoding(self, output: str) -> bool:
+        """Validate that dangerous patterns are not present in output."""
+        dangerous = ["<script", "javascript:", "onerror", "onload"]
+        lower = output.lower()
+        return not any(d in lower for d in dangerous)
+
+
+class CSRFTestHelper:
+    """Helper methods for CSRF testing."""
+
+    def generate_csrf_tokens(self, count: int = 1) -> List[str]:
+        """Generate a list of pseudo-random CSRF tokens."""
+        return [secrets.token_hex(16) for _ in range(count)]
+
+    def validate_csrf_protection(self, token: str, valid_tokens: List[str]) -> bool:
+        """Check whether a token is recognised as valid."""
+        return token in valid_tokens
+
+    def simulate_csrf_attacks(self, scenario: str) -> str:
+        """Return a description of the CSRF scenario."""
+        return CSRF_SCENARIOS.get(scenario, "unknown")
+
+
+class SecurityTestRunner:
+    """Run security test suites and generate reports."""
+
+    def run_security_suite(self) -> Dict[str, bool]:
+        """Simulate running the security suite."""
+        return {"xss": True, "csrf": True}
+
+    def generate_security_report(self, results: Dict[str, bool] | None = None) -> str:
+        """Generate a simple textual security report."""
+        if results is None:
+            results = self.run_security_suite()
+        lines = ["Security Test Report:"]
+        for key, val in results.items():
+            status = "PASSED" if val else "FAILED"
+            lines.append(f"{key.upper()}: {status}")
+        return "\n".join(lines)
diff --git a/tests/security_scenarios/__init__.py b/tests/security_scenarios/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..1735e4dfd87c1bae9c4c5962e6b0aae5e60ff780
--- /dev/null
+++ b/tests/security_scenarios/__init__.py
@@ -0,0 +1 @@
+"""Security testing scenarios package."""
diff --git a/tests/security_scenarios/csrf_scenarios.py b/tests/security_scenarios/csrf_scenarios.py
new file mode 100644
index 0000000000000000000000000000000000000000..0fac25fcd9e374a338c6c4c49a927ef6405a6117
--- /dev/null
+++ b/tests/security_scenarios/csrf_scenarios.py
@@ -0,0 +1,9 @@
+"""Common CSRF scenarios used for testing."""
+
+CSRF_SCENARIOS = {
+    "form": "Forged form submission",
+    "ajax": "Cross-origin AJAX request",
+    "json": "Malicious JSON payload",
+    "get": "GET request with side effects",
+    "cross_origin": "Cross-origin request without proper CORS",
+}
diff --git a/tests/security_scenarios/xss_payloads.py b/tests/security_scenarios/xss_payloads.py
new file mode 100644
index 0000000000000000000000000000000000000000..b8169a40b27a92746efc7c70dd6ab73d556d6dcc
--- /dev/null
+++ b/tests/security_scenarios/xss_payloads.py
@@ -0,0 +1,22 @@
+"""Common XSS payloads used for testing."""
+
+XSS_PAYLOADS = {
+    "script": [
+        "<script>alert('XSS')</script>",
+        "<script>console.log('test')</script>",
+    ],
+    "html": [
+        "<img src=x onerror=alert('XSS')>",
+        "<div><p>Test</p></div>",
+    ],
+    "attribute": [
+        "<a href='javascript:alert(\"XSS\")'>link</a>",
+        "<body onload=alert('XSS')>",
+    ],
+    "event_handler": [
+        "<button onclick='alert(1)'>click</button>",
+    ],
+    "dom_based": [
+        "javascript:eval('alert(1)')",
+    ],
+}
diff --git a/tests/test_security_xss_csrf.py b/tests/test_security_xss_csrf.py
new file mode 100644
index 0000000000000000000000000000000000000000..f8e97137c56ce53338c2f34759f28930df92ab61
--- /dev/null
+++ b/tests/test_security_xss_csrf.py
@@ -0,0 +1,98 @@
+import pytest
+
+from streamlit_extension.utils.security_testing import (
+    CSRFTestHelper,
+    SecurityTestRunner,
+    XSSTestHelper,
+)
+
+xss_helper = XSSTestHelper()
+csrf_helper = CSRFTestHelper()
+
+
+class TestSecurityXSS:
+    def test_xss_script_injection(self):
+        payloads = xss_helper.generate_xss_payloads().get("script", [])
+        for payload in payloads:
+            sanitized = xss_helper.test_input_sanitization(payload)
+            assert "<script" not in sanitized.lower()
+
+    def test_xss_html_injection(self):
+        payloads = xss_helper.generate_xss_payloads().get("html", [])
+        for payload in payloads:
+            sanitized = xss_helper.test_input_sanitization(payload)
+            assert "<img" not in sanitized.lower()
+
+    def test_xss_attribute_injection(self):
+        payloads = xss_helper.generate_xss_payloads().get("attribute", [])
+        for payload in payloads:
+            sanitized = xss_helper.test_input_sanitization(payload)
+            assert "javascript:" not in sanitized.lower()
+
+    def test_input_sanitization(self):
+        payload = "<b>bold</b>"
+        sanitized = xss_helper.test_input_sanitization(payload)
+        assert sanitized == "&lt;b&gt;bold&lt;/b&gt;"
+
+    def test_output_encoding(self):
+        output = "&lt;script&gt;alert('XSS')&lt;/script&gt;"
+        assert xss_helper.validate_output_encoding(output)
+
+    def test_xss_client_description_field(self):
+        payload = "<script>alert('desc')</script>"
+        sanitized = xss_helper.test_input_sanitization(payload)
+        assert "<script" not in sanitized.lower()
+
+    def test_xss_project_name_field(self):
+        payload = "<img src=x onerror=alert(1)>"
+        sanitized = xss_helper.test_input_sanitization(payload)
+        assert "<img" not in sanitized.lower()
+
+    def test_xss_reflected_in_error_messages(self):
+        payload = "<svg/onload=alert('err')>"
+        sanitized = xss_helper.test_input_sanitization(payload)
+        assert "onload" not in sanitized.lower()
+
+    def test_xss_stored_in_database(self):
+        payload = "<script>alert('db')</script>"
+        fake_db = {}
+        fake_db["description"] = xss_helper.test_input_sanitization(payload)
+        assert "<script" not in fake_db["description"].lower()
+
+
+class TestSecurityCSRF:
+    def test_csrf_form_submission(self):
+        tokens = csrf_helper.generate_csrf_tokens()
+        token = tokens[0]
+        assert csrf_helper.validate_csrf_protection(token, tokens)
+
+    def test_csrf_ajax_requests(self):
+        scenario = csrf_helper.simulate_csrf_attacks("ajax")
+        assert "ajax" in scenario.lower()
+
+    def test_csrf_token_validation(self):
+        tokens = csrf_helper.generate_csrf_tokens(2)
+        assert not csrf_helper.validate_csrf_protection("invalid", tokens)
+
+    def test_csrf_client_creation(self):
+        scenario = csrf_helper.simulate_csrf_attacks("form")
+        assert "form" in scenario.lower()
+
+    def test_csrf_project_update(self):
+        scenario = csrf_helper.simulate_csrf_attacks("ajax")
+        assert "ajax" in scenario.lower()
+
+    def test_csrf_bulk_operations(self):
+        scenario = csrf_helper.simulate_csrf_attacks("json")
+        assert "json" in scenario.lower()
+
+    def test_csrf_token_rotation(self):
+        tokens1 = csrf_helper.generate_csrf_tokens(3)
+        tokens2 = csrf_helper.generate_csrf_tokens(3)
+        assert set(tokens1).isdisjoint(tokens2)
+
+
+def test_security_report_generation():
+    runner = SecurityTestRunner()
+    report = runner.generate_security_report({"xss": True, "csrf": True})
+    assert "XSS: PASSED" in report
 
EOF
)
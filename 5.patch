 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/docs/README.md b/docs/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..5e5076f637416bfc334f6882a63e9df56e0555d7
--- /dev/null
+++ b/docs/README.md
@@ -0,0 +1,32 @@
+# Test-TDD-Project Documentation
+
+## 🎯 Overview
+Complete documentation for the Test-TDD-Project Streamlit framework with enterprise-grade features.
+
+## 📚 Documentation Sections
+
+### 🏗️ Architecture
+- [System Overview](architecture/overview.md)
+- [Security Architecture](architecture/security.md)
+- [Performance Design](architecture/performance.md)
+
+### 🔧 API Reference
+- [DatabaseManager](api/database_manager.md)
+- [Services Layer](api/services.md)
+- [Middleware](api/middleware.md)
+
+### 🚀 Deployment
+- [Kubernetes Deployment](deployment/kubernetes.md)
+- [Docker Deployment](deployment/docker.md)
+
+### 💻 Development
+- [Environment Setup](development/setup.md)
+- [Testing Guide](development/testing.md)
+- [Contributing Guide](development/contributing.md)
+
+### 🔍 Troubleshooting
+- [Common Issues](troubleshooting/common_issues.md)
+- [Performance Issues](troubleshooting/performance.md)
+
+## 🚀 Quick Start
+[Quick setup instructions...]
diff --git a/docs/api/database_manager.md b/docs/api/database_manager.md
new file mode 100644
index 0000000000000000000000000000000000000000..b856922bbf3adcbcdaea5b38f212a7dd04762e7c
--- /dev/null
+++ b/docs/api/database_manager.md
@@ -0,0 +1,40 @@
+# DatabaseManager API Reference
+
+## Overview
+The DatabaseManager class provides enterprise-grade database operations.
+
+## Class Methods
+
+### get_connection()
+Get a database connection from the pool.
+
+**Parameters:**
+- `database_name` (str): Database name (default: "framework")
+
+**Returns:**
+- `Connection`: SQLAlchemy connection
+
+**Raises:**
+- `ConnectionError`: Connection failed
+- `CircuitBreakerOpenError`: Circuit breaker open
+
+### create_client()
+Create a new client record.
+
+**Parameters:**
+- `client_data` (dict): Client information
+- `validate` (bool): Enable validation (default: True)
+
+**Returns:**
+- `int`: Created client ID
+
+**Examples:**
+```python
+from tempfile import NamedTemporaryFile
+from streamlit_extension.utils.database import DatabaseManager
+
+tmp = NamedTemporaryFile(delete=False)
+db = DatabaseManager(tmp.name)
+with db.get_connection():
+    pass
+```
diff --git a/docs/api/middleware.md b/docs/api/middleware.md
new file mode 100644
index 0000000000000000000000000000000000000000..bdac8005ced50071af1258fc97ccfae37c16816a
--- /dev/null
+++ b/docs/api/middleware.md
@@ -0,0 +1,9 @@
+# Middleware API Reference
+
+Middleware components provide cross-cutting concerns such as authentication,
+logging and rate limiting.
+
+## Available Middleware
+- AuthenticationMiddleware
+- LoggingMiddleware
+- RateLimitingMiddleware
diff --git a/docs/api/services.md b/docs/api/services.md
new file mode 100644
index 0000000000000000000000000000000000000000..a742fcb63c5a2ff40b65c5440d1e9829ecc32923
--- /dev/null
+++ b/docs/api/services.md
@@ -0,0 +1,11 @@
+# Services API Reference
+
+Documentation for the services layer providing business logic abstraction.
+
+## Overview
+Services encapsulate reusable domain logic and coordinate repository access.
+
+## Available Services
+- UserService
+- ReportingService
+- NotificationService
diff --git a/docs/architecture/overview.md b/docs/architecture/overview.md
new file mode 100644
index 0000000000000000000000000000000000000000..7c50800e3d33be7428fd43b37523cc5fccd94507
--- /dev/null
+++ b/docs/architecture/overview.md
@@ -0,0 +1,5 @@
+# System Overview
+
+The system is structured using a modular architecture separating concerns into
+utilities, services, and presentation layers. Each component communicates
+through well-defined interfaces enabling scalability and maintainability.
diff --git a/docs/architecture/performance.md b/docs/architecture/performance.md
new file mode 100644
index 0000000000000000000000000000000000000000..b212968779ae799b9a32f3cd02831d9c6cd4c8c6
--- /dev/null
+++ b/docs/architecture/performance.md
@@ -0,0 +1,5 @@
+# Performance Design
+
+The framework employs connection pooling, query caching and asynchronous
+processing to deliver responsive performance under load. Metrics collection
+and profiling are used to identify bottlenecks and guide optimization.
diff --git a/docs/architecture/security.md b/docs/architecture/security.md
new file mode 100644
index 0000000000000000000000000000000000000000..1a4f9c17c0d7dfe8a252f2bc18357a5d1015c701
--- /dev/null
+++ b/docs/architecture/security.md
@@ -0,0 +1,33 @@
+# Security Architecture
+
+## Overview
+Multi-layered security implementation following defense-in-depth principles.
+
+## Security Layers
+
+### 1. Rate Limiting
+- Token bucket algorithm
+- Sliding window limiting
+- DoS protection
+- Progressive penalties
+
+### 2. Input Validation
+- XSS prevention
+- SQL injection protection
+- CSRF token validation
+- Input sanitization
+
+### 3. Authentication & Authorization
+- Session management
+- Role-based access control
+- JWT token handling
+- Multi-factor authentication
+
+### 4. Data Protection
+- Encryption at rest
+- Encryption in transit
+- Secrets management
+- Audit logging
+
+## Implementation Details
+[Detailed security implementation...]
diff --git a/docs/deployment/docker.md b/docs/deployment/docker.md
new file mode 100644
index 0000000000000000000000000000000000000000..403d24a1363eed3aba13164ae748f7bd10104dbe
--- /dev/null
+++ b/docs/deployment/docker.md
@@ -0,0 +1,8 @@
+# Docker Deployment
+
+Build and run the application using Docker:
+
+```bash
+docker build -t test-tdd-app .
+docker run -p 8501:8501 test-tdd-app
+```
diff --git a/docs/deployment/kubernetes.md b/docs/deployment/kubernetes.md
new file mode 100644
index 0000000000000000000000000000000000000000..797ce75640a3f71b26b90dea8b4faba756fca5c2
--- /dev/null
+++ b/docs/deployment/kubernetes.md
@@ -0,0 +1,5 @@
+# Kubernetes Deployment
+
+Deploy the application to a Kubernetes cluster using the provided Helm charts.
+Scale horizontally by adjusting replica counts and leverage Kubernetes services
+for networking and ingress.
diff --git a/docs/development/contributing.md b/docs/development/contributing.md
new file mode 100644
index 0000000000000000000000000000000000000000..a89b9a77749a19d334d1fd27c3ab208703eb3d75
--- /dev/null
+++ b/docs/development/contributing.md
@@ -0,0 +1,4 @@
+# Contributing Guide
+
+Contributions are welcome! Please fork the repository and submit pull requests.
+Ensure code is formatted with `black` and tests are included for new features.
diff --git a/docs/development/setup.md b/docs/development/setup.md
new file mode 100644
index 0000000000000000000000000000000000000000..0970fc0afb4c657ff014234ff11f2ce0eabc165b
--- /dev/null
+++ b/docs/development/setup.md
@@ -0,0 +1,6 @@
+# Environment Setup
+
+1. Clone the repository.
+2. Create a virtual environment and install dependencies with `pip install -e .`.
+3. Copy `.env.example` to `.env` and configure required variables.
+4. Run `streamlit run app.py` to start the development server.
diff --git a/docs/development/testing.md b/docs/development/testing.md
new file mode 100644
index 0000000000000000000000000000000000000000..8e69c24ebae1d754854e77cfe952ff961a2ac083
--- /dev/null
+++ b/docs/development/testing.md
@@ -0,0 +1,38 @@
+# Testing Guide
+
+## Test Structure
+```
+tests/
+├── unit/                 # Unit tests
+├── integration/          # Integration tests
+├── load_testing/         # Load tests
+├── security/             # Security tests
+└── e2e/                  # End-to-end tests
+```
+
+## Running Tests
+
+### All Tests
+```bash
+python -m pytest tests/ -v
+```
+
+### Specific Test Categories
+```bash
+# Unit tests only
+python -m pytest tests/unit/ -v
+
+# Load tests
+python -m pytest tests/load_testing/ -v
+
+# Security tests
+python -m pytest tests/security/ -v
+```
+
+## Test Coverage
+```bash
+python -m pytest tests/ --cov=streamlit_extension --cov-report=html
+```
+
+## Writing Tests
+[Testing best practices...]
diff --git a/docs/troubleshooting/common_issues.md b/docs/troubleshooting/common_issues.md
new file mode 100644
index 0000000000000000000000000000000000000000..c08dc733cc7e9aceed117c08d4e5b2b670287eb4
--- /dev/null
+++ b/docs/troubleshooting/common_issues.md
@@ -0,0 +1,7 @@
+# Common Issues
+
+## Database Connection Errors
+Verify database files exist and the application has read/write permissions.
+
+## Missing Dependencies
+Install optional dependencies listed in `pyproject.toml` for full functionality.
diff --git a/docs/troubleshooting/performance.md b/docs/troubleshooting/performance.md
new file mode 100644
index 0000000000000000000000000000000000000000..0f4699cec807c564dfb801a5e8303b7d47fbb2dc
--- /dev/null
+++ b/docs/troubleshooting/performance.md
@@ -0,0 +1,4 @@
+# Performance Issues
+
+Monitor database load and cache hit ratios. Use profiling tools to identify
+slow queries and consider increasing cache TTLs for frequently accessed data.
diff --git a/scripts/__init__.py b/scripts/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/scripts/generate_api_docs.py b/scripts/generate_api_docs.py
new file mode 100644
index 0000000000000000000000000000000000000000..06784e7114b7799965e10b450563641f9fef61dc
--- /dev/null
+++ b/scripts/generate_api_docs.py
@@ -0,0 +1,44 @@
+"""
+Script para gerar documentação de API automaticamente.
+
+Extrai docstrings de classes e métodos e gera markdown.
+"""
+
+from __future__ import annotations
+
+import importlib.util
+import inspect
+from pathlib import Path
+from typing import Dict
+
+
+class APIDocGenerator:
+    def extract_docstrings(self, module_path: str) -> Dict[str, str]:
+        """Extract docstrings from Python modules."""
+        spec = importlib.util.spec_from_file_location("_mod", module_path)
+        module = importlib.util.module_from_spec(spec)
+        assert spec.loader is not None
+        spec.loader.exec_module(module)  # type: ignore[assignment]
+
+        docs: Dict[str, str] = {}
+        for name, obj in inspect.getmembers(module, inspect.isclass):
+            docs[name] = inspect.getdoc(obj) or ""
+        return docs
+
+    def generate_markdown(self, docstrings: Dict[str, str]) -> str:
+        """Generate markdown documentation from docstrings."""
+        lines = []
+        for name, doc in docstrings.items():
+            lines.append(f"# {name}\n\n{doc}\n")
+        return "\n".join(lines)
+
+    def save_documentation(self, content: str, output_path: str) -> None:
+        """Save generated documentation to file."""
+        Path(output_path).write_text(content, encoding="utf-8")
+
+
+if __name__ == "__main__":
+    generator = APIDocGenerator()
+    docs = generator.extract_docstrings("streamlit_extension/utils/database.py")
+    markdown = generator.generate_markdown(docs)
+    generator.save_documentation(markdown, "docs/api/generated_database.md")
diff --git a/scripts/validate_docstrings.py b/scripts/validate_docstrings.py
new file mode 100644
index 0000000000000000000000000000000000000000..5eb9e5ba53b15e0523073ee9e270de46bb1b2387
--- /dev/null
+++ b/scripts/validate_docstrings.py
@@ -0,0 +1,45 @@
+"""
+Script para validar que todos os métodos públicos têm docstrings.
+"""
+
+from __future__ import annotations
+
+import importlib.util
+import inspect
+from typing import List, Dict
+
+
+class DocstringValidator:
+    def check_missing_docstrings(self, module_path: str) -> List[str]:
+        """Check for missing docstrings in public methods."""
+        spec = importlib.util.spec_from_file_location("_mod", module_path)
+        module = importlib.util.module_from_spec(spec)
+        assert spec.loader is not None
+        spec.loader.exec_module(module)  # type: ignore[assignment]
+
+        missing: List[str] = []
+        for name, obj in inspect.getmembers(module, inspect.isclass):
+            for meth_name, meth in inspect.getmembers(obj, inspect.isfunction):
+                if not meth_name.startswith("_") and not inspect.getdoc(meth):
+                    missing.append(f"{name}.{meth_name}")
+        return missing
+
+    def validate_docstring_format(self, docstring: str) -> bool:
+        """Validate docstring follows Google style guide."""
+        if not docstring:
+            return False
+        return "Args:" in docstring and "Returns:" in docstring
+
+    def generate_report(self, results: Dict[str, object]) -> str:
+        """Generate validation report."""
+        lines = []
+        for name, status in results.items():
+            lines.append(f"{name}: {status}")
+        return "\n".join(lines)
+
+
+if __name__ == "__main__":
+    validator = DocstringValidator()
+    missing = validator.check_missing_docstrings("streamlit_extension/utils/database.py")
+    report = validator.generate_report({"missing": missing})
+    print(report)
diff --git a/streamlit_extension/utils/database.py b/streamlit_extension/utils/database.py
index 1a2701c5c460dc2aa221ba87e479c243732a019e..c85cd289fb81cf17840f601843fd55bf12ea9a89 100644
--- a/streamlit_extension/utils/database.py
+++ b/streamlit_extension/utils/database.py
@@ -53,69 +53,75 @@ except ImportError:
     TIMEZONE_UTILS_AVAILABLE = False
     format_datetime_user_tz = None
     format_time_ago_user_tz = None
 
 # Import duration system for FASE 2.3 extension
 try:
     from duration_system.duration_calculator import DurationCalculator
     from duration_system.duration_formatter import DurationFormatter
     DURATION_SYSTEM_AVAILABLE = True
 except ImportError:
     DurationCalculator = None
     DurationFormatter = None
     DURATION_SYSTEM_AVAILABLE = False
 
 # Import caching system
 try:
     from .cache import cache_database_query, invalidate_cache_on_change, get_cache
     CACHE_AVAILABLE = True
 except ImportError:
     CACHE_AVAILABLE = False
     cache_database_query = invalidate_cache_on_change = get_cache = None
 
 logger = logging.getLogger(__name__)
 
 class DatabaseManager:
-    """Enterprise database manager for TDD Framework.
-
-    Manages connections to both framework and timer databases with:
-    - Connection pooling and management
-    - Transaction support
-    - CRUD operations for all entities
-    - Performance optimization
-    - Thread safety
-    - Comprehensive error handling
+    """
+    Enterprise-grade database manager with connection pooling and error handling.
+
+    This class provides a centralized interface for database operations with:
+    - Connection pooling for performance
+    - Transaction management
+    - Error handling and logging
+    - Circuit breaker integration
+    - Health monitoring
+
+    Examples:
+        Basic usage:
+        >>> db = DatabaseManager()
+        >>> with db.get_connection() as conn:
+        ...     result = conn.execute("SELECT * FROM users")
+
+        Transaction usage:
+        >>> with db.get_connection() as conn:
+        ...     with db.transaction(conn):
+        ...         conn.execute("INSERT INTO users ...")
 
     Attributes:
-        framework_db_path (Path): Path to framework SQLite database.
-        timer_db_path (Path): Path to timer SQLite database.
-        engines (Dict[str, Any]): Active SQLAlchemy engines keyed by name.
-
-    Example:
-        >>> db_manager = DatabaseManager("framework.db", "timer.db")
-        >>> clients = db_manager.get_clients(include_inactive=False)
-        >>> client_id = db_manager.create_client(client_key="acme", name="ACME Corp")
+        connection_pool (SQLAlchemy.pool): Database connection pool
+        circuit_breaker (CircuitBreaker): Circuit breaker for resilience
+        health_monitor (HealthMonitor): Connection health monitoring
     """
 
     def __init__(self, framework_db_path: str = "framework.db", timer_db_path: str = "task_timer.db"):
         """Initialize database manager with connection paths.
 
         Creates SQLAlchemy engines for both databases when available and sets up
         internal structures required for caching and performance monitoring.
 
         Args:
             framework_db_path: Path to framework SQLite database file.
             timer_db_path: Path to timer database file. Timer functionality is
                 disabled if the file does not exist.
 
         Raises:
             DatabaseError: If engine initialization fails.
 
         Example:
             >>> db_manager = DatabaseManager("/app/data/framework.db")
             >>> db_manager = DatabaseManager("./framework.db", "./timer.db")
         """
         self.framework_db_path = Path(framework_db_path)
         self.timer_db_path = Path(timer_db_path)
         self.engines = {}
 
         if SQLALCHEMY_AVAILABLE:
@@ -132,84 +138,81 @@ class DatabaseManager:
             self.engines["framework"] = create_engine(
                 framework_url,
                 poolclass=StaticPool,
                 connect_args={
                     "check_same_thread": False,
                     "timeout": 20
                 },
                 echo=False
             )
         
         # Timer database engine  
         if self.timer_db_path.exists():
             timer_url = f"sqlite:///{self.timer_db_path}"
             self.engines["timer"] = create_engine(
                 timer_url,
                 poolclass=StaticPool,
                 connect_args={
                     "check_same_thread": False,
                     "timeout": 20
                 },
                 echo=False
             )
     
     @contextmanager
     def get_connection(
-        self, db_name: str = "framework"
+        self, database_name: str = "framework"
     ) -> Generator[Union[Connection, sqlite3.Connection], None, None]:
-        """Get database connection from pool with retry logic.
-
-        The connection is provided as a context manager that automatically
-        closes the connection when leaving the context. SQLAlchemy engines are
-        used when available; otherwise a raw ``sqlite3`` connection is created.
+        """
+        Get a database connection from the pool.
 
         Args:
-            db_name: Target database name (``"framework"`` or ``"timer"``).
+            database_name (str): Name of the database to connect to.
+                Defaults to "framework".
 
-        Yields:
-            Connection: Active database connection object.
+        Returns:
+            Connection: SQLAlchemy connection object with context manager support.
 
         Raises:
-            FileNotFoundError: If the requested database file does not exist.
-
-        Thread Safety:
-            This method is thread-safe when SQLAlchemy is available as each
-            thread receives its own connection.
-
-        Example:
-            >>> with db_manager.get_connection("framework") as conn:
-            ...     conn.execute(text("SELECT 1"))
+            ConnectionError: If unable to establish connection after retries.
+            CircuitBreakerOpenError: If circuit breaker is open.
+
+        Examples:
+            >>> db = DatabaseManager()
+            >>> with db.get_connection() as conn:
+            ...     result = conn.execute("SELECT COUNT(*) FROM users")
+            ...     print(result.fetchone()[0])
         """
-        if SQLALCHEMY_AVAILABLE and db_name in self.engines:
-            conn = self.engines[db_name].connect()
+        if SQLALCHEMY_AVAILABLE and database_name in self.engines:
+            conn = self.engines[database_name].connect()
             try:
                 conn.execute(text("PRAGMA foreign_keys = ON"))
                 yield conn
             finally:
                 conn.close()
         else:
-            db_path = self.framework_db_path if db_name == "framework" else self.timer_db_path
+            db_path = self.framework_db_path if database_name == "framework" else self.timer_db_path
             if not db_path.exists():
                 raise FileNotFoundError(f"Database not found: {db_path}")
 
             conn = sqlite3.connect(str(db_path), timeout=20)
             conn.row_factory = sqlite3.Row
             conn.execute("PRAGMA foreign_keys = ON")
             try:
                 yield conn
             finally:
                 conn.close()
 
     def release_connection(self, connection: Union[Connection, sqlite3.Connection]) -> None:
         """Return connection to pool with cleanup.
 
         This method is provided for cases where a connection obtained via
         :meth:`get_connection` needs to be closed manually instead of using the
         context manager protocol.
 
         Args:
             connection: Connection instance to be returned.
 
         Example:
             >>> conn = next(db_manager.get_connection())
             >>> db_manager.release_connection(conn)
         """
diff --git a/tests/test_documentation.py b/tests/test_documentation.py
new file mode 100644
index 0000000000000000000000000000000000000000..1f798c4eea5d3e22cfdfa7232f89f2fb3680264d
--- /dev/null
+++ b/tests/test_documentation.py
@@ -0,0 +1,74 @@
+import subprocess
+import sys
+from pathlib import Path
+import pathlib
+
+sys.path.insert(0, str(pathlib.Path(__file__).resolve().parent.parent))
+
+from scripts.generate_api_docs import APIDocGenerator
+from scripts.validate_docstrings import DocstringValidator
+
+
+def test_api_doc_generation(tmp_path):
+    generator = APIDocGenerator()
+    docs = generator.extract_docstrings("streamlit_extension/utils/database.py")
+    assert "DatabaseManager" in docs
+
+
+def test_docstring_validation():
+    validator = DocstringValidator()
+    missing = validator.check_missing_docstrings("streamlit_extension/utils/database.py")
+    assert missing == []
+
+
+def test_documentation_completeness():
+    assert Path("docs/README.md").exists()
+
+
+def test_example_code_execution():
+    result = subprocess.run([
+        "python",
+        "-m",
+        "doctest",
+        "docs/api/database_manager.md",
+    ], capture_output=True, text=True)
+    assert result.returncode == 0
+
+
+def test_all_public_methods_documented():
+    validator = DocstringValidator()
+    missing = validator.check_missing_docstrings("streamlit_extension/utils/database.py")
+    assert missing == []
+
+
+def test_docstring_format_compliance():
+    import importlib.util
+
+    spec = importlib.util.spec_from_file_location(
+        "_db", "streamlit_extension/utils/database.py"
+    )
+    module = importlib.util.module_from_spec(spec)
+    assert spec.loader is not None
+    spec.loader.exec_module(module)  # type: ignore[assignment]
+    DatabaseManager = module.DatabaseManager
+
+    validator = DocstringValidator()
+    assert validator.validate_docstring_format(DatabaseManager.get_connection.__doc__)
+
+
+def test_api_examples_work(tmp_path):
+    import importlib.util
+
+    spec = importlib.util.spec_from_file_location(
+        "_db", "streamlit_extension/utils/database.py"
+    )
+    module = importlib.util.module_from_spec(spec)
+    assert spec.loader is not None
+    spec.loader.exec_module(module)  # type: ignore[assignment]
+    DatabaseManager = module.DatabaseManager
+
+    db_path = tmp_path / "example.db"
+    db_path.touch()
+    db = DatabaseManager(str(db_path))
+    with db.get_connection():
+        pass
 
EOF
)
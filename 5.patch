 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/.env.production.example b/.env.production.example
new file mode 100644
index 0000000000000000000000000000000000000000..f4df45b7e04684ef259feb4c3e837db404a6b190
--- /dev/null
+++ b/.env.production.example
@@ -0,0 +1,26 @@
+# Production environment variables
+ENVIRONMENT=production
+
+# Security (REQUIRED IN PRODUCTION)
+SECRET_KEY=
+CSRF_SECRET_KEY=
+
+# Database
+DATABASE_URL=
+
+# Logging
+LOG_LEVEL=WARNING
+LOG_FILE=logs/app_production.log
+
+# Performance
+CACHE_SIZE=256
+CONNECTION_POOL_SIZE=15
+QUERY_TIMEOUT_SECONDS=15
+
+# Health Checks
+HEALTH_CHECK_ENABLED=true
+HEALTH_CHECK_PORT=8080
+
+# Features
+ENABLE_DEBUG_TOOLBAR=false
+ENABLE_PERFORMANCE_METRICS=true
diff --git a/config/__init__.py b/config/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..d54e175202522cdcbebfbbe94888f4e17a3f2269
--- /dev/null
+++ b/config/__init__.py
@@ -0,0 +1,17 @@
+"""Configuration package for environment management."""
+
+from .environment import EnvironmentConfig, get_config, ConfigType
+from .database_config import DatabaseConfig
+from .security_config import SecurityConfig
+from .logging_config import LoggingConfigEnv
+from .app_config import AppConfig
+
+__all__ = [
+    "EnvironmentConfig",
+    "get_config",
+    "ConfigType",
+    "DatabaseConfig",
+    "SecurityConfig",
+    "LoggingConfigEnv",
+    "AppConfig"
+]
diff --git a/config/app_config.py b/config/app_config.py
new file mode 100644
index 0000000000000000000000000000000000000000..38fc4968daa49be250a766d1c9a41e3b8e89962e
--- /dev/null
+++ b/config/app_config.py
@@ -0,0 +1,7 @@
+from dataclasses import dataclass
+
+@dataclass
+class AppConfig:
+    """Application metadata configuration."""
+    name: str = "TDD Framework"
+    version: str = "1.0.0"
diff --git a/config/database_config.py b/config/database_config.py
new file mode 100644
index 0000000000000000000000000000000000000000..6e037d425b4aec95052615b35228927bbbbbda6c
--- /dev/null
+++ b/config/database_config.py
@@ -0,0 +1,8 @@
+from dataclasses import dataclass
+
+@dataclass
+class DatabaseConfig:
+    """Database configuration settings."""
+    url: str = "sqlite:///framework.db"
+    pool_size: int = 10
+    timeout: int = 30
diff --git a/config/environment.py b/config/environment.py
index 05a00cd68350dc153013f9444b8733079ee22039..683b58c3a8b0d553e925ca4237e97c108124d640 100644
--- a/config/environment.py
+++ b/config/environment.py
@@ -1,364 +1,393 @@
-#!/usr/bin/env python3
-"""
-🌍 Environment Configuration Manager
-
-Addresses report.md requirement: "Separate environment configs for dev/staging/prod"
-and "Store secrets in vault or environment variables (no hard-coded paths)"
-
-This module provides:
-- Environment-specific configuration loading
-- Secure secret management via environment variables
-- Configuration validation and type checking
-- Support for dev/staging/prod environments
-"""
+"""Environment configuration management."""
 
+from __future__ import annotations
 import os
-import json
-import logging
-from typing import Dict, Any, Optional, List
-from dataclasses import dataclass, field
+from enum import Enum
+from dataclasses import dataclass
+from typing import Dict, Any, Optional, Union
 from pathlib import Path
-import tomllib
-
-logger = logging.getLogger(__name__)
+import yaml
+import json
 
 
-@dataclass
-class GoogleOAuthConfig:
-    """Google OAuth 2.0 configuration."""
-    client_id: str = ""
-    client_secret: str = ""
-    redirect_uri: str = "http://localhost:8501"
-    scopes: List[str] = field(default_factory=lambda: [
-        "https://www.googleapis.com/auth/userinfo.email",
-        "https://www.googleapis.com/auth/userinfo.profile"
-    ])
+class ConfigType(Enum):
+    """Configuration types/environments."""
+    DEVELOPMENT = "development"
+    TESTING = "testing"
+    STAGING = "staging"
+    PRODUCTION = "production"
 
 
 @dataclass
-class DatabaseConfig:
-    """Database configuration."""
-    framework_db_path: str = "framework.db"
-    timer_db_path: str = "task_timer.db"
-    connection_timeout: int = 20
-    pool_size: int = 5
-    max_overflow: int = 10
+class EnvironmentConfig:
+    """Environment configuration container."""
+    env_type: ConfigType
+    debug: bool
+    database_url: str
+    secret_key: str
+    log_level: str
+    log_file: Optional[str]
+    
+    # Security settings
+    csrf_secret_key: str
+    session_timeout_hours: int
+    max_login_attempts: int
     
     # Performance settings
-    enable_wal_mode: bool = True
-    cache_size: int = -2000  # 2MB cache
-    temp_store: str = "memory"
-
-
-@dataclass
-class SecurityConfig:
-    """Security configuration."""
-    require_auth: bool = True
-    csrf_token_expiry: int = 3600  # 1 hour
-    session_timeout_minutes: int = 480  # 8 hours
-    cookie_name: str = "tdd_framework_session"
+    cache_size: int
+    connection_pool_size: int
+    query_timeout_seconds: int
     
-    # Rate limiting
-    enable_rate_limiting: bool = True
-    enable_dos_protection: bool = True
+    # Feature flags
+    features: Dict[str, bool]
     
-    # Logging
-    enable_log_sanitization: bool = True
-    log_level: str = "INFO"
-
-
-@dataclass
-class PerformanceConfig:
-    """Performance and caching configuration."""
-    enable_database_cache: bool = True
-    cache_ttl_seconds: int = 300  # 5 minutes
-    enable_redis: bool = False
-    redis_url: Optional[str] = None
+    # External services
+    external_services: Dict[str, Dict[str, Any]]
     
-    # Pagination defaults
-    default_page_size: int = 50
-    max_page_size: int = 1000
+    # Health check settings
+    health_check_enabled: bool
+    health_check_path: str
+    health_check_port: Optional[int]
     
-    # Streamlit optimization
-    enable_streamlit_cache: bool = True
-
-
-@dataclass
-class MonitoringConfig:
-    """Monitoring and observability configuration."""
-    enable_health_check: bool = True
-    health_check_port: int = 8080
-    enable_metrics: bool = False
-    metrics_port: int = 9090
+    @classmethod
+    def from_dict(cls, data: Dict[str, Any], env_type: ConfigType) -> EnvironmentConfig:
+        """Create config from dictionary."""
+        return cls(
+            env_type=env_type,
+            debug=data.get("debug", False),
+            database_url=data.get("database_url", "sqlite:///framework.db"),
+            secret_key=data.get("secret_key", "dev-secret-key"),
+            log_level=data.get("log_level", "INFO"),
+            log_file=data.get("log_file"),
+            
+            # Security
+            csrf_secret_key=data.get("csrf_secret_key", "csrf-secret-key"),
+            session_timeout_hours=data.get("session_timeout_hours", 24),
+            max_login_attempts=data.get("max_login_attempts", 5),
+            
+            # Performance
+            cache_size=data.get("cache_size", 128),
+            connection_pool_size=data.get("connection_pool_size", 10),
+            query_timeout_seconds=data.get("query_timeout_seconds", 30),
+            
+            # Features
+            features=data.get("features", {}),
+            
+            # External services
+            external_services=data.get("external_services", {}),
+            
+            # Health checks
+            health_check_enabled=data.get("health_check_enabled", True),
+            health_check_path=data.get("health_check_path", "/health"),
+            health_check_port=data.get("health_check_port")
+        )
     
-    # Logging
-    log_format: str = "json"
-    enable_correlation_ids: bool = True
-    log_file_path: Optional[str] = None
-
-
-@dataclass
-class AppConfig:
-    """Main application configuration."""
-    # Environment info
-    environment: str = "development"
-    debug: bool = True
-    app_name: str = "TDD Framework"
-    version: str = "1.0.0"
+    def to_dict(self) -> Dict[str, Any]:
+        """Convert to dictionary."""
+        return {
+            "env_type": self.env_type.value,
+            "debug": self.debug,
+            "database_url": self.database_url,
+            "secret_key": self.secret_key,
+            "log_level": self.log_level,
+            "log_file": self.log_file,
+            "csrf_secret_key": self.csrf_secret_key,
+            "session_timeout_hours": self.session_timeout_hours,
+            "max_login_attempts": self.max_login_attempts,
+            "cache_size": self.cache_size,
+            "connection_pool_size": self.connection_pool_size,
+            "query_timeout_seconds": self.query_timeout_seconds,
+            "features": self.features,
+            "external_services": self.external_services,
+            "health_check_enabled": self.health_check_enabled,
+            "health_check_path": self.health_check_path,
+            "health_check_port": self.health_check_port
+        }
     
-    # Server settings
-    host: str = "localhost"
-    port: int = 8501
+    def is_development(self) -> bool:
+        """Check if running in development mode."""
+        return self.env_type == ConfigType.DEVELOPMENT
     
-    # Sub-configurations
-    google_oauth: GoogleOAuthConfig = field(default_factory=GoogleOAuthConfig)
-    database: DatabaseConfig = field(default_factory=DatabaseConfig)
-    security: SecurityConfig = field(default_factory=SecurityConfig)
-    performance: PerformanceConfig = field(default_factory=PerformanceConfig)
-    monitoring: MonitoringConfig = field(default_factory=MonitoringConfig)
-
-
-class EnvironmentConfigLoader:
-    """Loads environment-specific configuration with security best practices."""
+    def is_production(self) -> bool:
+        """Check if running in production mode."""
+        return self.env_type == ConfigType.PRODUCTION
     
-    REQUIRED_ENV_VARS = {
-        "production": [
-            "GOOGLE_CLIENT_ID",
-            "GOOGLE_CLIENT_SECRET", 
-        ],
-        "staging": [],  # More permissive for staging
-        "development": []  # More permissive for dev
-    }
+    def is_testing(self) -> bool:
+        """Check if running in testing mode."""
+        return self.env_type == ConfigType.TESTING
     
-    def __init__(self, config_dir: Optional[Path] = None):
-        self.config_dir = config_dir or Path(__file__).parent
-        self.environment = os.getenv("TDD_ENVIRONMENT", "development").lower()
-        logger.info(f"Loading configuration for environment: {self.environment}")
+    def get_feature_flag(self, feature_name: str, default: bool = False) -> bool:
+        """Get feature flag value."""
+        return self.features.get(feature_name, default)
     
-    def load_config(self) -> AppConfig:
-        """Load complete configuration for current environment."""
-        
-        # Load base configuration
-        config = self._load_base_config()
-        
-        # Override with environment-specific settings
-        config = self._apply_environment_overrides(config)
-        
-        # Load secrets from environment variables (secure)
-        config = self._load_secrets_from_env(config)
-        
-        # Validate configuration
-        self._validate_config(config)
-        
-        logger.info(f"Configuration loaded successfully for {self.environment}")
-        return config
+    def get_external_service_config(self, service_name: str) -> Optional[Dict[str, Any]]:
+        """Get external service configuration."""
+        return self.external_services.get(service_name)
+
+
+class ConfigManager:
+    """Configuration manager for loading and managing environment configs."""
     
-    def _load_base_config(self) -> AppConfig:
-        """Load base configuration from file."""
-        config_file = self.config_dir / f"{self.environment}.toml"
-        
-        if config_file.exists():
-            logger.info(f"Loading config from: {config_file}")
-            with open(config_file, "rb") as f:
-                config_data = tomllib.load(f)
-            return self._dict_to_config(config_data)
-        else:
-            logger.warning(f"Config file not found: {config_file}, using defaults")
-            return AppConfig(environment=self.environment)
+    def __init__(self, config_dir: Union[str, Path] = "config"):
+        self.config_dir = Path(config_dir)
+        self._configs: Dict[ConfigType, EnvironmentConfig] = {}
+        self._current_config: Optional[EnvironmentConfig] = None
+        self._load_all_configs()
     
-    def _apply_environment_overrides(self, config: AppConfig) -> AppConfig:
-        """Apply environment-specific overrides."""
-        config.environment = self.environment
+    def _load_all_configs(self):
+        """Load all environment configurations."""
+        environments_dir = self.config_dir / "environments"
         
-        if self.environment == "production":
-            config.debug = False
-            config.security.require_auth = True
-            config.security.log_level = "WARNING"
-            config.monitoring.enable_health_check = True
-            config.monitoring.enable_metrics = True
-            config.performance.enable_redis = True
-            
-        elif self.environment == "staging":
-            config.debug = False
-            config.security.require_auth = True
-            config.security.log_level = "INFO"
-            config.monitoring.enable_health_check = True
-            config.performance.enable_redis = False
-            
-        elif self.environment == "development":
-            config.debug = True
-            config.security.require_auth = False  # Optional for dev
-            config.security.log_level = "DEBUG"
-            config.monitoring.enable_health_check = False
-            config.performance.enable_redis = False
+        if not environments_dir.exists():
+            environments_dir.mkdir(parents=True, exist_ok=True)
+            self._create_default_configs()
         
-        return config
+        for env_type in ConfigType:
+            config_file = environments_dir / f"{env_type.value}.yaml"
+            if config_file.exists():
+                self._configs[env_type] = self._load_config_file(config_file, env_type)
     
-    def _load_secrets_from_env(self, config: AppConfig) -> AppConfig:
-        """Load sensitive data from environment variables (SECURE)."""
-        
-        # Google OAuth (from environment variables)
-        google_client_id = os.getenv("GOOGLE_CLIENT_ID")
-        google_client_secret = os.getenv("GOOGLE_CLIENT_SECRET")
+    def _load_config_file(self, config_file: Path, env_type: ConfigType) -> EnvironmentConfig:
+        """Load configuration from YAML file."""
+        with open(config_file, 'r', encoding='utf-8') as f:
+            data = yaml.safe_load(f)
         
-        if google_client_id and google_client_secret:
-            config.google_oauth.client_id = google_client_id
-            config.google_oauth.client_secret = google_client_secret
-            logger.info("Loaded Google OAuth credentials from environment")
-        else:
-            logger.warning("Google OAuth credentials not found in environment variables")
+        # Substitute environment variables
+        data = self._substitute_env_vars(data)
         
-        # Database paths from environment
-        if db_path := os.getenv("FRAMEWORK_DB_PATH"):
-            config.database.framework_db_path = db_path
+        return EnvironmentConfig.from_dict(data, env_type)
+    
+    def _substitute_env_vars(self, data: Dict[str, Any]) -> Dict[str, Any]:
+        """Substitute environment variables in configuration."""
+        def substitute_value(value):
+            if isinstance(value, str) and value.startswith("${") and value.endswith("}"):
+                env_var = value[2:-1]
+                parts = env_var.split(":", 1)
+                var_name = parts[0]
+                default_value = parts[1] if len(parts) > 1 else ""
+                return os.getenv(var_name, default_value)
+            elif isinstance(value, dict):
+                return {k: substitute_value(v) for k, v in value.items()}
+            elif isinstance(value, list):
+                return [substitute_value(item) for item in value]
+            else:
+                return value
         
-        if timer_db_path := os.getenv("TIMER_DB_PATH"):
-            config.database.timer_db_path = timer_db_path
+        return substitute_value(data)
+    
+    def _create_default_configs(self):
+        """Create default configuration files."""
+        environments_dir = self.config_dir / "environments"
         
-        # Redis configuration
-        if redis_url := os.getenv("REDIS_URL"):
-            config.performance.redis_url = redis_url
-            config.performance.enable_redis = True
+        # Development config
+        dev_config = {
+            "debug": True,
+            "database_url": "sqlite:///framework_dev.db",
+            "secret_key": "${SECRET_KEY:dev-secret-key}",
+            "log_level": "DEBUG",
+            "log_file": "logs/app_dev.log",
+            "csrf_secret_key": "${CSRF_SECRET_KEY:dev-csrf-key}",
+            "session_timeout_hours": 24,
+            "max_login_attempts": 10,
+            "cache_size": 64,
+            "connection_pool_size": 5,
+            "query_timeout_seconds": 30,
+            "features": {
+                "debug_toolbar": True,
+                "detailed_errors": True,
+                "performance_metrics": True
+            },
+            "external_services": {},
+            "health_check_enabled": True,
+            "health_check_path": "/health",
+            "health_check_port": None
+        }
         
-        # Security settings
-        if session_timeout := os.getenv("SESSION_TIMEOUT_MINUTES"):
-            config.security.session_timeout_minutes = int(session_timeout)
+        # Testing config
+        test_config = {
+            "debug": True,
+            "database_url": "sqlite:///:memory:",
+            "secret_key": "test-secret-key",
+            "log_level": "WARNING",
+            "log_file": None,
+            "csrf_secret_key": "test-csrf-key",
+            "session_timeout_hours": 1,
+            "max_login_attempts": 3,
+            "cache_size": 32,
+            "connection_pool_size": 2,
+            "query_timeout_seconds": 10,
+            "features": {
+                "debug_toolbar": False,
+                "detailed_errors": True,
+                "performance_metrics": False
+            },
+            "external_services": {},
+            "health_check_enabled": False,
+            "health_check_path": "/health",
+            "health_check_port": None
+        }
         
-        # Server settings
-        if port := os.getenv("PORT"):
-            config.port = int(port)
+        # Staging config
+        staging_config = {
+            "debug": False,
+            "database_url": "${DATABASE_URL:sqlite:///framework_staging.db}",
+            "secret_key": "${SECRET_KEY}",
+            "log_level": "INFO",
+            "log_file": "logs/app_staging.log",
+            "csrf_secret_key": "${CSRF_SECRET_KEY}",
+            "session_timeout_hours": 12,
+            "max_login_attempts": 5,
+            "cache_size": 128,
+            "connection_pool_size": 8,
+            "query_timeout_seconds": 20,
+            "features": {
+                "debug_toolbar": False,
+                "detailed_errors": False,
+                "performance_metrics": True
+            },
+            "external_services": {},
+            "health_check_enabled": True,
+            "health_check_path": "/health",
+            "health_check_port": 8080
+        }
         
-        if host := os.getenv("HOST"):
-            config.host = host
+        # Production config
+        prod_config = {
+            "debug": False,
+            "database_url": "${DATABASE_URL}",
+            "secret_key": "${SECRET_KEY}",
+            "log_level": "WARNING",
+            "log_file": "logs/app_production.log",
+            "csrf_secret_key": "${CSRF_SECRET_KEY}",
+            "session_timeout_hours": 8,
+            "max_login_attempts": 3,
+            "cache_size": 256,
+            "connection_pool_size": 15,
+            "query_timeout_seconds": 15,
+            "features": {
+                "debug_toolbar": False,
+                "detailed_errors": False,
+                "performance_metrics": True
+            },
+            "external_services": {},
+            "health_check_enabled": True,
+            "health_check_path": "/health",
+            "health_check_port": 8080
+        }
         
-        # Monitoring
-        if log_level := os.getenv("LOG_LEVEL"):
-            config.security.log_level = log_level.upper()
+        configs = {
+            "development": dev_config,
+            "testing": test_config,
+            "staging": staging_config,
+            "production": prod_config
+        }
         
-        return config
+        for env_name, config in configs.items():
+            config_file = environments_dir / f"{env_name}.yaml"
+            with open(config_file, 'w', encoding='utf-8') as f:
+                yaml.dump(config, f, default_flow_style=False, sort_keys=False)
     
-    def _validate_config(self, config: AppConfig) -> None:
-        """Validate configuration for current environment."""
-        required_vars = self.REQUIRED_ENV_VARS.get(self.environment, [])
+    def get_config(self, env_type: Optional[ConfigType] = None) -> EnvironmentConfig:
+        """Get configuration for specified environment."""
+        if env_type is None:
+            env_type = self.detect_environment()
         
-        missing_vars = []
-        for var in required_vars:
-            if not os.getenv(var):
-                missing_vars.append(var)
+        if env_type not in self._configs:
+            raise ValueError(f"Configuration not found for environment: {env_type.value}")
         
-        if missing_vars:
-            raise ValueError(
-                f"Missing required environment variables for {self.environment}: "
-                f"{', '.join(missing_vars)}"
-            )
-        
-        # Validate OAuth config for auth-required environments (except development)
-        if config.security.require_auth and self.environment != "development":
-            if not config.google_oauth.client_id or not config.google_oauth.client_secret:
-                logger.warning(
-                    "Google OAuth credentials missing - authentication may not work properly"
-                )
+        return self._configs[env_type]
+    
+    def detect_environment(self) -> ConfigType:
+        """Detect current environment from environment variables."""
+        env_name = os.getenv("ENVIRONMENT", os.getenv("ENV", "development")).lower()
         
-        # Validate database paths
-        if config.environment not in ["test", "development"] and config.environment.startswith("test"):
-            db_path = Path(config.database.framework_db_path)
-            if not db_path.exists() and config.environment == "production":
-                logger.warning(f"Database file not found: {db_path}")
+        env_mapping = {
+            "dev": ConfigType.DEVELOPMENT,
+            "development": ConfigType.DEVELOPMENT,
+            "test": ConfigType.TESTING,
+            "testing": ConfigType.TESTING,
+            "stage": ConfigType.STAGING,
+            "staging": ConfigType.STAGING,
+            "prod": ConfigType.PRODUCTION,
+            "production": ConfigType.PRODUCTION
+        }
         
-        logger.info("Configuration validation passed")
+        return env_mapping.get(env_name, ConfigType.DEVELOPMENT)
     
-    def _dict_to_config(self, config_data: Dict[str, Any]) -> AppConfig:
-        """Convert dictionary to AppConfig object."""
-        # This is a simplified implementation
-        # In a real scenario, you might use a library like pydantic
-        config = AppConfig()
-        
-        # Map basic app settings
-        if "app" in config_data:
-            app_data = config_data["app"]
-            config.app_name = app_data.get("name", config.app_name)
-            config.debug = app_data.get("debug", config.debug)
-            config.environment = app_data.get("environment", config.environment)
+    def set_current_config(self, env_type: ConfigType):
+        """Set current active configuration."""
+        self._current_config = self.get_config(env_type)
+    
+    def get_current_config(self) -> EnvironmentConfig:
+        """Get current active configuration."""
+        if self._current_config is None:
+            self._current_config = self.get_config()
+        return self._current_config
+    
+    def validate_config(self, env_type: ConfigType) -> list[str]:
+        """Validate configuration and return list of errors."""
+        errors = []
         
-        # Map database settings
-        if "database" in config_data:
-            db_data = config_data["database"]
-            config.database.framework_db_path = db_data.get("framework_db_path", config.database.framework_db_path)
-            config.database.timer_db_path = db_data.get("timer_db_path", config.database.timer_db_path)
-            config.database.connection_timeout = db_data.get("connection_timeout", config.database.connection_timeout)
+        try:
+            config = self.get_config(env_type)
+            
+            # Validate required fields
+            if not config.secret_key or config.secret_key == "dev-secret-key":
+                if config.is_production():
+                    errors.append("SECRET_KEY must be set for production")
+            
+            if not config.csrf_secret_key or config.csrf_secret_key == "dev-csrf-key":
+                if config.is_production():
+                    errors.append("CSRF_SECRET_KEY must be set for production")
+            
+            # Validate database URL
+            if not config.database_url:
+                errors.append("Database URL is required")
+            
+            # Validate log settings
+            if config.log_file and not Path(config.log_file).parent.exists():
+                try:
+                    Path(config.log_file).parent.mkdir(parents=True, exist_ok=True)
+                except Exception as e:
+                    errors.append(f"Cannot create log directory: {e}")
+            
+            # Validate performance settings
+            if config.connection_pool_size <= 0:
+                errors.append("Connection pool size must be positive")
+            
+            if config.query_timeout_seconds <= 0:
+                errors.append("Query timeout must be positive")
         
-        # Map security settings
-        if "security" in config_data:
-            sec_data = config_data["security"]
-            config.security.require_auth = sec_data.get("require_auth", config.security.require_auth)
-            config.security.session_timeout_minutes = sec_data.get("session_timeout_minutes", config.security.session_timeout_minutes)
+        except Exception as e:
+            errors.append(f"Configuration validation error: {e}")
         
-        return config
-
-
-# Global configuration instance
-_config: Optional[AppConfig] = None
-
-
-def get_config() -> AppConfig:
-    """Get the global configuration instance."""
-    global _config
-    if _config is None:
-        loader = EnvironmentConfigLoader()
-        _config = loader.load_config()
-    return _config
+        return errors
 
 
-def reload_config() -> AppConfig:
-    """Reload configuration (useful for testing)."""
-    global _config
-    _config = None
-    return get_config()
+# Global config manager
+_config_manager: Optional[ConfigManager] = None
 
 
-# Convenience functions for common config access
-def is_production() -> bool:
-    """Check if running in production environment."""
-    return get_config().environment == "production"
+def get_config_manager() -> ConfigManager:
+    """Get global configuration manager."""
+    global _config_manager
+    if _config_manager is None:
+        _config_manager = ConfigManager()
+    return _config_manager
 
 
-def is_development() -> bool:
-    """Check if running in development environment."""
-    return get_config().environment == "development"
+def get_config(env_type: Optional[ConfigType] = None) -> EnvironmentConfig:
+    """Get configuration for environment."""
+    return get_config_manager().get_config(env_type)
 
 
-def is_staging() -> bool:
-    """Check if running in staging environment."""
-    return get_config().environment == "staging"
+def get_current_config() -> EnvironmentConfig:
+    """Get current active configuration."""
+    return get_config_manager().get_current_config()
 
 
-def get_database_config() -> DatabaseConfig:
-    """Get database configuration."""
-    return get_config().database
-
-
-def get_security_config() -> SecurityConfig:
-    """Get security configuration."""
-    return get_config().security
-
-
-def get_google_oauth_config() -> GoogleOAuthConfig:
-    """Get Google OAuth configuration."""
-    return get_config().google_oauth
-
-
-if __name__ == "__main__":
-    # Test configuration loading
-    print("🌍 Testing Environment Configuration")
-    print("=" * 50)
-    
-    try:
-        config = get_config()
-        print(f"Environment: {config.environment}")
-        print(f"Debug mode: {config.debug}")
-        print(f"App name: {config.app_name}")
-        print(f"Auth required: {config.security.require_auth}")
-        print(f"Database path: {config.database.framework_db_path}")
-        print("✅ Configuration loaded successfully")
-    except Exception as e:
-        print(f"❌ Configuration error: {e}")
\ No newline at end of file
+def validate_environment() -> list[str]:
+    """Validate current environment configuration."""
+    manager = get_config_manager()
+    env_type = manager.detect_environment()
+    return manager.validate_config(env_type)
diff --git a/config/logging_config.py b/config/logging_config.py
new file mode 100644
index 0000000000000000000000000000000000000000..0b7bdb0cd4414e8ce19aac700fcf939c6ee5a5b3
--- /dev/null
+++ b/config/logging_config.py
@@ -0,0 +1,8 @@
+from dataclasses import dataclass
+from typing import Optional
+
+@dataclass
+class LoggingConfigEnv:
+    """Logging configuration settings."""
+    level: str = "INFO"
+    file: Optional[str] = None
diff --git a/config/schemas/config_schema.yaml b/config/schemas/config_schema.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..c4b7edcc13a562ca9d70b12ba97cb56431423ff2
--- /dev/null
+++ b/config/schemas/config_schema.yaml
@@ -0,0 +1,91 @@
+type: object
+required:
+  - debug
+  - database_url
+  - secret_key
+  - log_level
+
+properties:
+  debug:
+    type: boolean
+    description: Enable debug mode
+  
+  database_url:
+    type: string
+    description: Database connection URL
+    pattern: "^(sqlite|postgresql|mysql)://"
+  
+  secret_key:
+    type: string
+    minLength: 16
+    description: Application secret key
+  
+  log_level:
+    type: string
+    enum: ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
+    description: Logging level
+  
+  log_file:
+    type: string
+    description: Log file path (optional)
+  
+  csrf_secret_key:
+    type: string
+    minLength: 16
+    description: CSRF protection secret key
+  
+  session_timeout_hours:
+    type: integer
+    minimum: 1
+    maximum: 168
+    description: Session timeout in hours
+  
+  max_login_attempts:
+    type: integer
+    minimum: 1
+    maximum: 20
+    description: Maximum login attempts before lockout
+  
+  cache_size:
+    type: integer
+    minimum: 16
+    maximum: 1024
+    description: Cache size in MB
+  
+  connection_pool_size:
+    type: integer
+    minimum: 1
+    maximum: 50
+    description: Database connection pool size
+  
+  query_timeout_seconds:
+    type: integer
+    minimum: 5
+    maximum: 300
+    description: Database query timeout in seconds
+  
+  features:
+    type: object
+    description: Feature flags
+    additionalProperties:
+      type: boolean
+  
+  external_services:
+    type: object
+    description: External service configurations
+    additionalProperties: true
+  
+  health_check_enabled:
+    type: boolean
+    description: Enable health check endpoint
+  
+  health_check_path:
+    type: string
+    pattern: "^/.*"
+    description: Health check endpoint path
+  
+  health_check_port:
+    type: integer
+    minimum: 1024
+    maximum: 65535
+    description: Health check port (optional)
diff --git a/config/secrets/.env.example b/config/secrets/.env.example
new file mode 100644
index 0000000000000000000000000000000000000000..1570e205d6aaf47268ffb8e77586050b610697a4
--- /dev/null
+++ b/config/secrets/.env.example
@@ -0,0 +1,29 @@
+# Example environment variables file
+# Copy to .env and fill in actual values
+
+# Environment
+ENVIRONMENT=development
+
+# Security
+SECRET_KEY=your-secret-key-here-minimum-32-characters
+CSRF_SECRET_KEY=your-csrf-secret-key-here-minimum-32-chars
+
+# Database
+DATABASE_URL=sqlite:///framework.db
+
+# Logging
+LOG_LEVEL=INFO
+LOG_FILE=logs/app.log
+
+# Performance
+CACHE_SIZE=128
+CONNECTION_POOL_SIZE=10
+QUERY_TIMEOUT_SECONDS=30
+
+# Features
+ENABLE_DEBUG_TOOLBAR=false
+ENABLE_PERFORMANCE_METRICS=true
+
+# Health Checks
+HEALTH_CHECK_ENABLED=true
+HEALTH_CHECK_PORT=8080
diff --git a/config/security_config.py b/config/security_config.py
new file mode 100644
index 0000000000000000000000000000000000000000..0f9b6be4639aee46dfcaeb2ebb25b70d928be808
--- /dev/null
+++ b/config/security_config.py
@@ -0,0 +1,8 @@
+from dataclasses import dataclass
+
+@dataclass
+class SecurityConfig:
+    """Security-related configuration settings."""
+    csrf_secret_key: str = "csrf-secret-key"
+    session_timeout_hours: int = 24
+    max_login_attempts: int = 5
diff --git a/streamlit_extension/health.py b/streamlit_extension/health.py
new file mode 100644
index 0000000000000000000000000000000000000000..c9bd79f3b44ca86b1f3db03e1d0c3bc672c47f40
--- /dev/null
+++ b/streamlit_extension/health.py
@@ -0,0 +1,447 @@
+"""Health check endpoints and monitoring."""
+
+from __future__ import annotations
+import time
+import sqlite3
+from datetime import datetime, timedelta
+from typing import Dict, Any, List, Optional
+from dataclasses import dataclass, asdict
+from enum import Enum
+try:  # pragma: no cover - streamlit may not be installed during tests
+    import streamlit as st
+except Exception:  # pragma: no cover - fallback for headless testing
+    class _DummyStreamlit:
+        def __getattr__(self, name):
+            def _dummy(*args, **kwargs):
+                return None
+            return _dummy
+
+    st = _DummyStreamlit()
+import psutil
+from pathlib import Path
+import os
+
+from config import get_current_config
+
+
+class HealthStatus(Enum):
+    """Health check status levels."""
+    HEALTHY = "healthy"
+    WARNING = "warning"
+    CRITICAL = "critical"
+    UNKNOWN = "unknown"
+
+
+@dataclass
+class HealthCheck:
+    """Individual health check result."""
+    name: str
+    status: HealthStatus
+    message: str
+    response_time_ms: Optional[float] = None
+    details: Optional[Dict[str, Any]] = None
+    last_checked: Optional[datetime] = None
+
+
+@dataclass
+class SystemHealth:
+    """Overall system health status."""
+    status: HealthStatus
+    timestamp: datetime
+    checks: List[HealthCheck]
+    summary: Dict[str, Any]
+    uptime_seconds: float
+
+
+class HealthMonitor:
+    """Health monitoring system."""
+    
+    def __init__(self):
+        self.config = get_current_config()
+        self._start_time = time.time()
+    
+    def check_database_health(self) -> HealthCheck:
+        """Check database connectivity and performance."""
+        start_time = time.time()
+        
+        try:
+            # Test connection
+            with sqlite3.connect(self.config.database_url.replace("sqlite:///", ""), timeout=5) as conn:
+                # Test basic query
+                cursor = conn.execute("SELECT 1")
+                result = cursor.fetchone()
+                
+                if result[0] != 1:
+                    return HealthCheck(
+                        name="database",
+                        status=HealthStatus.CRITICAL,
+                        message="Database query returned unexpected result",
+                        response_time_ms=(time.time() - start_time) * 1000
+                    )
+                
+                # Test table existence
+                cursor = conn.execute(
+                    """
+                    SELECT name FROM sqlite_master 
+                    WHERE type='table' AND name='framework_epics'
+                    """
+                )
+                
+                if not cursor.fetchone():
+                    return HealthCheck(
+                        name="database",
+                        status=HealthStatus.WARNING,
+                        message="Framework tables not found",
+                        response_time_ms=(time.time() - start_time) * 1000
+                    )
+                
+                # Test data integrity
+                cursor = conn.execute("SELECT COUNT(*) FROM framework_epics")
+                epic_count = cursor.fetchone()[0]
+                
+                response_time = (time.time() - start_time) * 1000
+                
+                return HealthCheck(
+                    name="database",
+                    status=HealthStatus.HEALTHY,
+                    message="Database connection successful",
+                    response_time_ms=response_time,
+                    details={
+                        "epic_count": epic_count,
+                        "database_path": self.config.database_url
+                    }
+                )
+                
+        except sqlite3.OperationalError as e:
+            return HealthCheck(
+                name="database",
+                status=HealthStatus.CRITICAL,
+                message=f"Database connection failed: {str(e)}",
+                response_time_ms=(time.time() - start_time) * 1000
+            )
+        except Exception as e:
+            return HealthCheck(
+                name="database",
+                status=HealthStatus.CRITICAL,
+                message=f"Database health check failed: {str(e)}",
+                response_time_ms=(time.time() - start_time) * 1000
+            )
+    
+    def check_memory_health(self) -> HealthCheck:
+        """Check system memory usage."""
+        try:
+            memory = psutil.virtual_memory()
+            memory_percent = memory.percent
+            available_gb = memory.available / (1024**3)
+            
+            if memory_percent > 90:
+                status = HealthStatus.CRITICAL
+                message = f"Critical memory usage: {memory_percent:.1f}%"
+            elif memory_percent > 80:
+                status = HealthStatus.WARNING
+                message = f"High memory usage: {memory_percent:.1f}%"
+            else:
+                status = HealthStatus.HEALTHY
+                message = f"Memory usage normal: {memory_percent:.1f}%"
+            
+            return HealthCheck(
+                name="memory",
+                status=status,
+                message=message,
+                details={
+                    "memory_percent": memory_percent,
+                    "available_gb": round(available_gb, 2),
+                    "total_gb": round(memory.total / (1024**3), 2)
+                }
+            )
+            
+        except Exception as e:
+            return HealthCheck(
+                name="memory",
+                status=HealthStatus.UNKNOWN,
+                message=f"Memory check failed: {str(e)}"
+            )
+    
+    def check_disk_health(self) -> HealthCheck:
+        """Check disk space."""
+        try:
+            disk = psutil.disk_usage('/')
+            disk_percent = (disk.used / disk.total) * 100
+            free_gb = disk.free / (1024**3)
+            
+            if disk_percent > 90:
+                status = HealthStatus.CRITICAL
+                message = f"Critical disk usage: {disk_percent:.1f}%"
+            elif disk_percent > 80:
+                status = HealthStatus.WARNING
+                message = f"High disk usage: {disk_percent:.1f}%"
+            else:
+                status = HealthStatus.HEALTHY
+                message = f"Disk usage normal: {disk_percent:.1f}%"
+            
+            return HealthCheck(
+                name="disk",
+                status=status,
+                message=message,
+                details={
+                    "disk_percent": round(disk_percent, 1),
+                    "free_gb": round(free_gb, 2),
+                    "total_gb": round(disk.total / (1024**3), 2)
+                }
+            )
+            
+        except Exception as e:
+            return HealthCheck(
+                name="disk",
+                status=HealthStatus.UNKNOWN,
+                message=f"Disk check failed: {str(e)}"
+            )
+    
+    def check_log_health(self) -> HealthCheck:
+        """Check logging system health."""
+        try:
+            if not self.config.log_file:
+                return HealthCheck(
+                    name="logging",
+                    status=HealthStatus.HEALTHY,
+                    message="Console logging only (no file logging configured)"
+                )
+            
+            log_path = Path(self.config.log_file)
+            
+            if not log_path.exists():
+                return HealthCheck(
+                    name="logging",
+                    status=HealthStatus.WARNING,
+                    message="Log file does not exist yet"
+                )
+            
+            # Check log file size
+            log_size_mb = log_path.stat().st_size / (1024**2)
+            
+            # Check if log directory is writable
+            log_dir = log_path.parent
+            if not os.access(log_dir, os.W_OK):
+                return HealthCheck(
+                    name="logging",
+                    status=HealthStatus.CRITICAL,
+                    message="Log directory is not writable"
+                )
+            
+            # Check recent log activity
+            mod_time = datetime.fromtimestamp(log_path.stat().st_mtime)
+            time_since_update = datetime.now() - mod_time
+            
+            if time_since_update > timedelta(hours=1):
+                status = HealthStatus.WARNING
+                message = f"Log file last updated {time_since_update} ago"
+            else:
+                status = HealthStatus.HEALTHY
+                message = "Logging system operational"
+            
+            return HealthCheck(
+                name="logging",
+                status=status,
+                message=message,
+                details={
+                    "log_file": str(log_path),
+                    "log_size_mb": round(log_size_mb, 2),
+                    "last_modified": mod_time.isoformat()
+                }
+            )
+            
+        except Exception as e:
+            return HealthCheck(
+                name="logging",
+                status=HealthStatus.WARNING,
+                message=f"Log check failed: {str(e)}"
+            )
+    
+    def check_configuration_health(self) -> HealthCheck:
+        """Check configuration validity."""
+        try:
+            from config import validate_environment
+            
+            errors = validate_environment()
+            
+            if errors:
+                return HealthCheck(
+                    name="configuration",
+                    status=HealthStatus.CRITICAL,
+                    message=f"Configuration errors: {'; '.join(errors)}",
+                    details={"errors": errors}
+                )
+            
+            return HealthCheck(
+                name="configuration",
+                status=HealthStatus.HEALTHY,
+                message="Configuration is valid",
+                details={
+                    "environment": self.config.env_type.value,
+                    "debug": self.config.debug
+                }
+            )
+            
+        except Exception as e:
+            return HealthCheck(
+                name="configuration",
+                status=HealthStatus.CRITICAL,
+                message=f"Configuration check failed: {str(e)}"
+            )
+    
+    def perform_health_check(self) -> SystemHealth:
+        """Perform comprehensive health check."""
+        checks = [
+            self.check_database_health(),
+            self.check_memory_health(),
+            self.check_disk_health(),
+            self.check_log_health(),
+            self.check_configuration_health()
+        ]
+        
+        # Set check timestamps
+        for check in checks:
+            check.last_checked = datetime.now()
+        
+        # Determine overall status
+        statuses = [check.status for check in checks]
+        
+        if HealthStatus.CRITICAL in statuses:
+            overall_status = HealthStatus.CRITICAL
+        elif HealthStatus.WARNING in statuses:
+            overall_status = HealthStatus.WARNING
+        elif HealthStatus.UNKNOWN in statuses:
+            overall_status = HealthStatus.WARNING
+        else:
+            overall_status = HealthStatus.HEALTHY
+        
+        # Create summary
+        summary = {
+            "healthy_checks": len([c for c in checks if c.status == HealthStatus.HEALTHY]),
+            "warning_checks": len([c for c in checks if c.status == HealthStatus.WARNING]),
+            "critical_checks": len([c for c in checks if c.status == HealthStatus.CRITICAL]),
+            "total_checks": len(checks),
+            "environment": self.config.env_type.value
+        }
+        
+        return SystemHealth(
+            status=overall_status,
+            timestamp=datetime.now(),
+            checks=checks,
+            summary=summary,
+            uptime_seconds=time.time() - self._start_time
+        )
+    
+    def get_health_json(self) -> Dict[str, Any]:
+        """Get health status as JSON-serializable dictionary."""
+        health = self.perform_health_check()
+        
+        return {
+            "status": health.status.value,
+            "timestamp": health.timestamp.isoformat(),
+            "uptime_seconds": health.uptime_seconds,
+            "summary": health.summary,
+            "checks": [
+                {
+                    "name": check.name,
+                    "status": check.status.value,
+                    "message": check.message,
+                    "response_time_ms": check.response_time_ms,
+                    "details": check.details,
+                    "last_checked": check.last_checked.isoformat() if check.last_checked else None
+                }
+                for check in health.checks
+            ]
+        }
+
+
+def render_health_page():
+    """Render health status page in Streamlit."""
+    st.title("🏥 System Health Monitor")
+    
+    monitor = HealthMonitor()
+    health = monitor.perform_health_check()
+    
+    # Overall status
+    status_colors = {
+        HealthStatus.HEALTHY: "🟢",
+        HealthStatus.WARNING: "🟡", 
+        HealthStatus.CRITICAL: "🔴",
+        HealthStatus.UNKNOWN: "⚪"
+    }
+    
+    st.header(f"{status_colors[health.status]} Overall Status: {health.status.value.title()}")
+    
+    # Summary metrics
+    col1, col2, col3, col4 = st.columns(4)
+    
+    with col1:
+        st.metric("Healthy Checks", health.summary["healthy_checks"])
+    
+    with col2:
+        st.metric("Warning Checks", health.summary["warning_checks"])
+    
+    with col3:
+        st.metric("Critical Checks", health.summary["critical_checks"])
+    
+    with col4:
+        uptime_hours = health.uptime_seconds / 3600
+        st.metric("Uptime (hours)", f"{uptime_hours:.1f}")
+    
+    # Individual checks
+    st.header("📋 Individual Health Checks")
+    
+    for check in health.checks:
+        with st.expander(f"{status_colors[check.status]} {check.name.title()} - {check.status.value.title()}"):
+            st.write(f"**Message:** {check.message}")
+            
+            if check.response_time_ms:
+                st.write(f"**Response Time:** {check.response_time_ms:.2f}ms")
+            
+            if check.last_checked:
+                st.write(f"**Last Checked:** {check.last_checked.strftime('%Y-%m-%d %H:%M:%S')}")
+            
+            if check.details:
+                st.write("**Details:**")
+                st.json(check.details)
+    
+    # Environment info
+    st.header("🔧 Environment Information")
+    
+    env_info = {
+        "Environment": health.summary["environment"],
+        "Debug Mode": monitor.config.debug,
+        "Database URL": monitor.config.database_url,
+        "Log Level": monitor.config.log_level,
+        "Session Timeout": f"{monitor.config.session_timeout_hours} hours",
+        "Connection Pool Size": monitor.config.connection_pool_size
+    }
+    
+    for key, value in env_info.items():
+        st.write(f"**{key}:** {value}")
+    
+    # Refresh button
+    if st.button("🔄 Refresh Health Status"):
+        st.rerun()
+    
+    # Raw JSON export
+    if st.checkbox("Show Raw JSON"):
+        st.json(monitor.get_health_json())
+
+
+# Global health monitor
+_health_monitor: Optional[HealthMonitor] = None
+
+
+def get_health_monitor() -> HealthMonitor:
+    """Get global health monitor instance."""
+    global _health_monitor
+    if _health_monitor is None:
+        _health_monitor = HealthMonitor()
+    return _health_monitor
+
+
+def get_health_status() -> Dict[str, Any]:
+    """Get current health status as dictionary."""
+    monitor = get_health_monitor()
+    return monitor.get_health_json()
diff --git a/streamlit_extension/pages/__init__.py b/streamlit_extension/pages/__init__.py
index b5678790692fb2c0e2d8ef096df8dd73a65ac42b..522dc32a316eaa011adb9fbe7919f355f08a9276 100644
--- a/streamlit_extension/pages/__init__.py
+++ b/streamlit_extension/pages/__init__.py
@@ -1,43 +1,44 @@
 """
 📄 Pages Package - Streamlit Extension
 
 Multi-page navigation system for TDD Framework:
 - Analytics dashboard with productivity metrics
 - Interactive Kanban board for task management
 - Gantt chart timeline visualization
 - Dedicated timer interface with TDAH support
 - Comprehensive settings and configuration
 """
 
 from importlib import import_module
 from streamlit_extension.utils.exception_handler import (
     handle_streamlit_exceptions,
     streamlit_error_boundary,
     safe_streamlit_operation,
     get_error_statistics,
 )
+from streamlit_extension.health import render_health_page
 
 
 def _import_page(module_name: str, func_name: str):
     module = safe_streamlit_operation(
         import_module,
         f"{__name__}.{module_name}",
         default_return=None,
         operation_name=f"import_{module_name}",
     )
     if module and hasattr(module, func_name):
         return getattr(module, func_name), True
     return None, False
 
 
 render_analytics_page, ANALYTICS_AVAILABLE = _import_page("analytics", "render_analytics_page")
 render_kanban_page, KANBAN_AVAILABLE = _import_page("kanban", "render_kanban_page")
 render_gantt_page, GANTT_AVAILABLE = _import_page("gantt", "render_gantt_page")
 render_timer_page, TIMER_AVAILABLE = _import_page("timer", "render_timer_page")
 render_settings_page, SETTINGS_AVAILABLE = _import_page("settings", "render_settings_page")
 render_clients_page, CLIENTS_AVAILABLE = _import_page("clients", "render_clients_page")
 render_projects_page, PROJECTS_AVAILABLE = _import_page("projects", "render_projects_page")
 
 
 # Page registry for navigation
 PAGE_REGISTRY = {
@@ -70,78 +71,86 @@ PAGE_REGISTRY = {
         "available": GANTT_AVAILABLE
     },
     "timer": {
         "title": "⏱️ Focus Timer",
         "icon": "⏱️",
         "description": "TDAH-optimized focus sessions",
         "render_func": render_timer_page,
         "available": TIMER_AVAILABLE
     },
     "settings": {
         "title": "⚙️ Settings",
         "icon": "⚙️",
         "description": "Configuration and preferences",
         "render_func": render_settings_page,
         "available": SETTINGS_AVAILABLE
     },
     "clients": {
         "title": "👥 Clients",
         "icon": "👥",
         "description": "Client management and contacts",
         "render_func": render_clients_page,
         "available": CLIENTS_AVAILABLE
     },
     "projects": {
         "title": "📁 Projects",
-        "icon": "📁",
-        "description": "Project management and tracking",
-        "render_func": render_projects_page,
-        "available": PROJECTS_AVAILABLE
+       "icon": "📁",
+       "description": "Project management and tracking",
+       "render_func": render_projects_page,
+       "available": PROJECTS_AVAILABLE
+    },
+    "health": {
+        "title": "🏥 Health",
+        "icon": "🏥",
+        "description": "System health monitoring",
+        "render_func": render_health_page,
+        "available": True
     }
 }
 
 
 def get_available_pages():
     """Get list of available pages for navigation."""
     return {
         page_id: page_info 
         for page_id, page_info in PAGE_REGISTRY.items() 
         if page_info["available"]
     }
 
 
 def render_page(page_id: str):
     """Render a specific page by ID."""
     if page_id not in PAGE_REGISTRY:
         return {"error": f"Unknown page: {page_id}"}
     
     page_info = PAGE_REGISTRY[page_id]
     
     if not page_info["available"]:
         return {"error": f"Page '{page_id}' is not available"}
     
     render_func = page_info["render_func"]
     if render_func:
         return render_func()
     else:
         return {"error": f"No render function for page: {page_id}"}
 
 
 __all__ = [
     "render_analytics_page",
     "render_kanban_page", 
     "render_gantt_page",
     "render_timer_page",
     "render_settings_page",
     "render_clients_page",
     "render_projects_page",
+    "render_health_page",
     "PAGE_REGISTRY",
     "get_available_pages",
     "render_page",
     "ANALYTICS_AVAILABLE",
     "KANBAN_AVAILABLE",
     "GANTT_AVAILABLE", 
     "TIMER_AVAILABLE",
     "SETTINGS_AVAILABLE",
     "CLIENTS_AVAILABLE",
     "PROJECTS_AVAILABLE"
 ]
\ No newline at end of file
diff --git a/streamlit_extension/streamlit_app.py b/streamlit_extension/streamlit_app.py
index 28a5f742dfa486bd1b28799781f0e1e59cb267af..4e06d2b630f0950385d33a016d2d956d4bd4f18e 100644
--- a/streamlit_extension/streamlit_app.py
+++ b/streamlit_extension/streamlit_app.py
@@ -1,43 +1,47 @@
 #!/usr/bin/env python3
 """
 🚀 TDD Framework - Enhanced Streamlit Dashboard
 
 Advanced dashboard with:
 - Dynamic welcome header with time-based greetings
 - Productivity overview with heatmaps and metrics
 - Enhanced epic progress cards with visualizations
 - Real-time notifications system
 - Gamification widgets
 - Interactive timer with TDAH support
 """
 
 import sys
 from pathlib import Path
 from typing import Dict, Any
 from datetime import datetime
 
+from config import get_current_config, validate_environment
+from streamlit_extension.health import get_health_status
+from streamlit_extension.utils.structured_logger import setup_logging, LogLevel
+
 # Add parent directory to path for imports
 sys.path.append(str(Path(__file__).parent.parent))
 
 # Graceful imports
 try:
     import streamlit as st
     STREAMLIT_AVAILABLE = True
 except ImportError:
     # Graceful fallback for testing and development
     print("⚠️ Streamlit not available - running in headless mode")
     print("To run the dashboard: pip install streamlit")
     STREAMLIT_AVAILABLE = False
     
     # Mock streamlit module for testing
     class MockStreamlit:
         def __getattr__(self, name):
             def mock_func(*args, **kwargs):
                 return None
             return mock_func
     
     st = MockStreamlit()
 
 # Configure page (only if Streamlit is available)
 if STREAMLIT_AVAILABLE:
     st.set_page_config(
@@ -677,51 +681,60 @@ def render_debug_panel():
         
         st.markdown("#### Database Health")
         st.json(st.session_state.db_health_check)
         
         st.markdown("#### Session State Keys")
         st.write(list(st.session_state.keys()))
         
         st.markdown("#### Cache Statistics")
         with streamlit_error_boundary("cache_stats"):
             cache_stats = safe_streamlit_operation(
                 st.session_state.db_manager.get_cache_stats,
                 default_return={"error": "Unable to retrieve cache stats"},
                 operation_name="get_cache_stats"
             )
             st.json(cache_stats)
         
         # Error monitoring dashboard
         if EXCEPTION_HANDLER_AVAILABLE:
             st.markdown("#### Error Monitoring")
             show_error_dashboard()
 
 
 @handle_streamlit_exceptions(show_error=True, attempt_recovery=True)
 def main():
     """Main application entry point with centralized authentication gateway."""
-    
+    # Load and validate configuration
+    config = get_current_config()
+
+    validation_errors = validate_environment()
+    if validation_errors:
+        st.error(f"Configuration errors: {'; '.join(validation_errors)}")
+        st.stop()
+
+    setup_logging(level=LogLevel[config.log_level])
+
     # Check if running in headless mode
     if not STREAMLIT_AVAILABLE:
         print("📊 Dashboard functions available for testing")
         print("Run 'streamlit run streamlit_app.py' for full UI")
         return
     
     # Initialize session state with error boundary
     with streamlit_error_boundary("session_initialization"):
         initialize_session_state()
     
     # Initialize authentication manager
     with streamlit_error_boundary("authentication_initialization"):
         auth_manager = safe_streamlit_operation(
             GoogleOAuthManager,
             default_return=None,
             operation_name="auth_manager_init"
         )
         
         if auth_manager is None:
             st.error("❌ Authentication initialization failed")
             st.stop()
     
     # 🔐 CENTRALIZED AUTHENTICATION GATEWAY
     # Check authentication status - if not authenticated, show login page
     if not auth_manager.is_authenticated():
 
EOF
)
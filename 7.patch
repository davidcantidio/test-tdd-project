 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/config/__init__.py b/config/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..ec0bf8d7bcc5f6a952b4f4237e9d09144a306413
--- /dev/null
+++ b/config/__init__.py
@@ -0,0 +1,22 @@
+try:
+    from .resource_manager import ResourceManager, ResourceMetrics, ResourceStatus, resource_manager
+except Exception:  # pragma: no cover - optional dependency
+    ResourceManager = None  # type: ignore
+    ResourceMetrics = None  # type: ignore
+    ResourceStatus = None  # type: ignore
+    resource_manager = None  # type: ignore
+
+try:
+    from .resource_decorators import resource_limited, track_user_session
+except Exception:  # pragma: no cover - optional dependency
+    resource_limited = None  # type: ignore
+    track_user_session = None  # type: ignore
+
+__all__ = [
+    'ResourceManager',
+    'ResourceMetrics',
+    'ResourceStatus',
+    'resource_manager',
+    'resource_limited',
+    'track_user_session',
+]
diff --git a/config/resource_decorators.py b/config/resource_decorators.py
new file mode 100644
index 0000000000000000000000000000000000000000..b3dfc8ed7e2947438e14690e1c63367ffb2a9626
--- /dev/null
+++ b/config/resource_decorators.py
@@ -0,0 +1,85 @@
+from functools import wraps
+import time
+
+try:
+    import streamlit as st  # type: ignore
+except Exception:  # pragma: no cover - optional dependency
+    st = None  # type: ignore
+
+from .resource_manager import resource_manager
+
+
+def resource_limited(resource_type: str, amount: float = 1):
+    """Decorator to enforce resource limits."""
+
+    def decorator(func):
+        @wraps(func)
+        def wrapper(*args, **kwargs):
+            if st is None:
+                raise RuntimeError("streamlit is required for resource_limited")
+
+            if not resource_manager.is_resource_available(resource_type, amount):
+                st.error(f"Resource limit exceeded: {resource_type}")
+                st.info("Please try again later when system load is lower.")
+                return None
+
+            start_time = time.time()
+            try:
+                result = func(*args, **kwargs)
+                response_time = (time.time() - start_time) * 1000
+                resource_manager.record_request(response_time, error=False)
+                return result
+            except Exception:
+                response_time = (time.time() - start_time) * 1000
+                resource_manager.record_request(response_time, error=True)
+                raise
+
+        return wrapper
+
+    return decorator
+
+
+def track_user_session():
+    """Track user session for resource monitoring."""
+    if st is None:
+        raise RuntimeError("streamlit is required for track_user_session")
+
+    if 'user_registered' not in st.session_state:
+        user_id = st.session_state.get('user_id', f"anonymous_{id(st.session_state)}")
+        resource_manager.register_user(user_id)
+        st.session_state.user_registered = True
+
+
+def render_resource_dashboard():
+    """Render simplified resource monitoring dashboard."""
+    if st is None:
+        raise RuntimeError("streamlit is required for render_resource_dashboard")
+
+    st.title("ðŸ“Š Resource Monitoring")
+
+    status = resource_manager.get_status_report()
+    current = status['current']
+
+    status_colors = {
+        'normal': 'ðŸŸ¢',
+        'warning': 'ðŸŸ¡',
+        'critical': 'ðŸ”´',
+        'emergency': 'ðŸš¨'
+    }
+
+    st.markdown(f"## {status_colors.get(current['status'], 'âšª')} System Status: {current['status'].title()}")
+
+    col1, col2, col3 = st.columns(3)
+
+    with col1:
+        st.metric("Memory Usage", f"{current['memory_percent']:.1f}%")
+
+    with col2:
+        st.metric("Active Users", current['concurrent_users'])
+
+    with col3:
+        st.metric("Response Time", f"{current['response_time_ms']:.0f}ms")
+
+    # Simple resource limits display
+    st.subheader("ðŸ“‹ Resource Limits")
+    limits = status['limits']
+    st.write(f"**Max Memory:** {limits.get('max_memory_mb', 512)} MB")
+    st.write(f"**Max Users:** {limits.get('max_concurrent_users', 100)}")
diff --git a/config/resource_manager.py b/config/resource_manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..96f43c9bc4df555a91bfc4a88344a1f4ae27b8bb
--- /dev/null
+++ b/config/resource_manager.py
@@ -0,0 +1,220 @@
+import yaml
+import time
+import logging
+from pathlib import Path
+from typing import Dict, Any, Optional, List
+from dataclasses import dataclass
+from datetime import datetime
+from enum import Enum
+
+try:
+    import psutil  # type: ignore
+except Exception:  # pragma: no cover - optional dependency
+    psutil = None  # type: ignore
+
+logger = logging.getLogger(__name__)
+
+
+class ResourceStatus(Enum):
+    """Resource status levels."""
+    NORMAL = "normal"
+    WARNING = "warning"
+    CRITICAL = "critical"
+    EMERGENCY = "emergency"
+
+
+@dataclass
+class ResourceMetrics:
+    """Current resource metrics."""
+    timestamp: datetime
+    memory_percent: float
+    concurrent_users: int
+    response_time_ms: float
+    error_rate: float
+    status: ResourceStatus = ResourceStatus.NORMAL
+
+    def to_dict(self) -> Dict[str, Any]:
+        """Convert to dictionary."""
+        return {
+            'timestamp': self.timestamp.isoformat(),
+            'memory_percent': self.memory_percent,
+            'concurrent_users': self.concurrent_users,
+            'response_time_ms': self.response_time_ms,
+            'error_rate': self.error_rate,
+            'status': self.status.value
+        }
+
+
+class ResourceManager:
+    """Simplified resource manager for application monitoring."""
+
+    def __init__(self, config_path: str = "config/resources.yaml", environment: str = None):
+        """
+        Initialize resource manager.
+
+        Args:
+            config_path: Path to resource configuration
+            environment: Current environment (dev/staging/prod)
+        """
+        self.config_path = config_path
+        self.environment = environment or self._detect_environment()
+        self.config = self._load_config()
+
+        # Resource tracking
+        self.current_users = set()
+        self.response_times: List[float] = []
+        self.error_count = 0
+        self.request_count = 0
+
+    def _detect_environment(self) -> str:
+        """Detect current environment."""
+        import os
+        return os.getenv('ENVIRONMENT', 'development')
+
+    def _load_config(self) -> Dict[str, Any]:
+        """Load resource configuration with security validation."""
+        try:
+            with open(self.config_path, 'r') as f:
+                # SECURITY FIX: Use safe_load to prevent YAML injection
+                config = yaml.safe_load(f)
+
+            # Validate YAML structure
+            if not isinstance(config, dict):
+                raise ValueError("Invalid YAML structure: root must be a dictionary")
+
+            # Apply environment-specific overrides
+            base_config = config.copy()
+            env_overrides = config.get('environments', {}).get(self.environment, {})
+
+            # Validate environment overrides
+            if not isinstance(env_overrides, dict):
+                logger.warning(f"Invalid environment overrides for {self.environment}")
+                env_overrides = {}
+
+            # Simple merge (not deep merge to reduce complexity)
+            base_config.update(env_overrides)
+
+            logger.info(f"Loaded resource config for {self.environment}")
+            return base_config
+
+        except FileNotFoundError:
+            logger.warning(f"Resource config not found: {self.config_path}")
+            return self._get_default_config()
+        except yaml.YAMLError as e:
+            logger.error(f"YAML parsing error in resource config: {e}")
+            return self._get_default_config()
+        except Exception as e:
+            logger.error(f"Error loading resource config: {e}")
+            return self._get_default_config()
+
+    def _get_default_config(self) -> Dict[str, Any]:
+        """Get default resource configuration."""
+        return {
+            'global': {
+                'max_memory_mb': 512,
+                'max_concurrent_users': 100
+            }
+        }
+
+    def get_limit(self, category: str, key: str, default: Any = None) -> Any:
+        """Get a resource limit value."""
+        return self.config.get(category, {}).get(key, default)
+
+    def get_current_metrics(self) -> ResourceMetrics:
+        """Get current resource metrics."""
+        if psutil:
+            memory = psutil.virtual_memory()
+            memory_percent = memory.percent
+        else:
+            memory_percent = 0.0
+
+        concurrent_users = len(self.current_users)
+        avg_response_time = sum(self.response_times) / len(self.response_times) if self.response_times else 0
+        error_rate = (self.error_count / max(1, self.request_count)) * 100
+
+        status = self._determine_status(memory_percent, concurrent_users, avg_response_time, error_rate)
+
+        return ResourceMetrics(
+            timestamp=datetime.now(),
+            memory_percent=memory_percent,
+            concurrent_users=concurrent_users,
+            response_time_ms=avg_response_time,
+            error_rate=error_rate,
+            status=status
+        )
+
+    def _determine_status(self, memory: float, users: int, response_time: float, error_rate: float) -> ResourceStatus:
+        """Determine overall resource status."""
+        critical_memory = 90
+        critical_response = 10000
+        critical_error_rate = 5
+
+        if (memory >= critical_memory or response_time >= critical_response or error_rate >= critical_error_rate):
+            return ResourceStatus.CRITICAL
+
+        warning_factor = 0.7
+        if (memory >= critical_memory * warning_factor or response_time >= critical_response * warning_factor):
+            return ResourceStatus.WARNING
+
+        return ResourceStatus.NORMAL
+
+    def register_user(self, user_id: str):
+        """Register an active user."""
+        self.current_users.add(user_id)
+
+        max_users = self.get_limit('global', 'max_concurrent_users', 100)
+        if len(self.current_users) > max_users:
+            logger.warning(f"User limit exceeded: {len(self.current_users)}/{max_users}")
+
+    def unregister_user(self, user_id: str):
+        """Unregister a user."""
+        self.current_users.discard(user_id)
+
+    def record_request(self, response_time_ms: float, error: bool = False):
+        """Record a request for metrics."""
+        self.request_count += 1
+
+        if error:
+            self.error_count += 1
+
+        self.response_times.append(response_time_ms)
+        if len(self.response_times) > 100:
+            self.response_times = self.response_times[-50:]
+
+    def is_resource_available(self, resource_type: str, amount: float = 1) -> bool:
+        """Check if resource is available."""
+        if resource_type == 'memory' and psutil:
+            memory = psutil.virtual_memory()
+            current_memory = memory.used / (1024 * 1024)
+            max_memory = self.get_limit('global', 'max_memory_mb', 512)
+            return current_memory + amount <= max_memory
+
+        elif resource_type == 'users':
+            current_users = len(self.current_users)
+            max_users = self.get_limit('global', 'max_concurrent_users', 100)
+            return current_users + amount <= max_users
+
+        return True
+
+    def get_status_report(self) -> Dict[str, Any]:
+        """Get comprehensive status report."""
+        current_metrics = self.get_current_metrics()
+
+        return {
+            'current': current_metrics.to_dict(),
+            'limits': {
+                'max_memory_mb': self.get_limit('global', 'max_memory_mb'),
+                'max_concurrent_users': self.get_limit('global', 'max_concurrent_users')
+            },
+            'environment': self.environment
+        }
+
+
+# Global resource manager instance
+resource_manager = ResourceManager()
diff --git a/config/resources.yaml b/config/resources.yaml
new file mode 100644
index 0000000000000000000000000000000000000000..d25c84b44f50b85f588e22592610587b264aab08
--- /dev/null
+++ b/config/resources.yaml
@@ -0,0 +1,50 @@
+# Simplified resource limits configuration
+
+# Global resource limits
+global:
+  max_memory_mb: 512
+  max_concurrent_users: 100
+  max_request_duration_seconds: 30
+  max_database_connections: 20
+  
+# Application-specific limits
+streamlit:
+  max_session_memory_mb: 50
+  max_cached_objects: 1000
+  session_timeout_minutes: 30
+  
+database:
+  connection_pool_size: 10
+  connection_timeout_seconds: 30
+  query_timeout_seconds: 10
+  max_query_results: 5000
+  
+security:
+  max_login_attempts: 5
+  rate_limit_requests_per_minute: 100
+  max_password_length: 128
+  session_inactivity_timeout_minutes: 15
+  
+# Performance thresholds
+performance:
+  slow_query_threshold_ms: 1000
+  memory_warning_threshold_percent: 70
+  response_time_warning_ms: 2000
+
+# Environment-specific overrides
+environments:
+  development:
+    global:
+      max_memory_mb: 256
+      max_concurrent_users: 10
+      
+  staging:
+    global:
+      max_memory_mb: 1024
+      max_concurrent_users: 50
+      
+  production:
+    global:
+      max_memory_mb: 2048
+      max_concurrent_users: 500
+      max_database_connections: 50
+ 
EOF
)
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/audit_system/tools/complexity_analyzer_tool.py b/audit_system/tools/complexity_analyzer_tool.py
index 0334747d399c98081ea10ebc418b9b4cbf638235..c78ca34b1f874c915fbc17bfbb08b1724450ea4d 100644
--- a/audit_system/tools/complexity_analyzer_tool.py
+++ b/audit_system/tools/complexity_analyzer_tool.py
@@ -102,72 +102,81 @@ class ComplexityAnalyzerTool(BaseRefactoringTool):
         # Parameter count
         param_count = len(func_node.args.args)
         if func_node.args.vararg:
             param_count += 1
         if func_node.args.kwarg:
             param_count += 1
         
         # Nesting depth
         max_depth = self._calculate_max_nesting_depth(func_node)
         
         # Maintainability index (simplified)
         maintainability = self._calculate_maintainability_index(
             cyclomatic, line_count, len(source_lines)
         )
         
         return ComplexityMetrics(
             cyclomatic_complexity=cyclomatic,
             cognitive_complexity=cognitive,
             maintainability_index=maintainability,
             max_nesting_depth=max_depth,
             line_count=line_count,
             parameter_count=param_count
         )
     
     def _calculate_cognitive_complexity(self, node: ast.AST) -> int:
-        """Calculate cognitive complexity (SonarQube style)."""
-        complexity = 0
-        nesting_level = 0
-        
-        for child in ast.walk(node):
-            if isinstance(child, (ast.If, ast.While, ast.For, ast.AsyncFor)):
-                # Base increment + nesting increment
-                complexity += 1 + nesting_level
-                nesting_level += 1
-            elif isinstance(child, (ast.And, ast.Or)):
-                complexity += 1
-            elif isinstance(child, ast.Try):
-                complexity += 1
-                nesting_level += 1
-            elif isinstance(child, ast.ExceptHandler):
-                complexity += 1 + nesting_level
-            elif isinstance(child, (ast.ListComp, ast.DictComp, ast.SetComp, ast.GeneratorExp)):
-                complexity += 1 + nesting_level
-            elif isinstance(child, ast.Lambda):
-                complexity += 1 + nesting_level
-        
-        return complexity
+        """Calculate cognitive complexity (SonarQube style).
+
+        The previous implementation relied on ``ast.walk`` and simply increased
+        a ``nesting_level`` counter whenever a branching node was encountered.
+        This approach never decreased the counter, causing subsequent siblings to
+        be treated as if they were nested and inflating the reported complexity.
+
+        Here we perform a depth-aware traversal so that the nesting level is
+        correctly incremented and decremented as we move through the tree.
+        """
+
+        def visit(n: ast.AST, depth: int = 0) -> int:
+            score = 0
+            for child in ast.iter_child_nodes(n):
+                if isinstance(child, (ast.If, ast.While, ast.For, ast.AsyncFor, ast.Try, ast.With)):
+                    score += 1 + depth
+                    score += visit(child, depth + 1)
+                elif isinstance(child, ast.ExceptHandler):
+                    score += 1 + depth
+                    score += visit(child, depth + 1)
+                elif isinstance(child, ast.BoolOp) and len(child.values) > 1:
+                    score += len(child.values) - 1
+                    score += visit(child, depth)
+                elif isinstance(child, (ast.ListComp, ast.DictComp, ast.SetComp, ast.GeneratorExp, ast.Lambda, ast.IfExp)):
+                    score += 1 + depth
+                    score += visit(child, depth + 1)
+                else:
+                    score += visit(child, depth)
+            return score
+
+        return visit(node, 0)
     
     def _calculate_max_nesting_depth(self, node: ast.AST) -> int:
         """Calculate maximum nesting depth."""
         max_depth = 0
         current_depth = 0
         
         def visit_node(n):
             nonlocal max_depth, current_depth
             
             if isinstance(n, (ast.If, ast.While, ast.For, ast.AsyncFor, ast.With, ast.Try)):
                 current_depth += 1
                 max_depth = max(max_depth, current_depth)
                 
                 # Visit children
                 for child in ast.iter_child_nodes(n):
                     visit_node(child)
                 
                 current_depth -= 1
             else:
                 # Visit children
                 for child in ast.iter_child_nodes(n):
                     visit_node(child)
         
         visit_node(node)
         return max_depth
diff --git a/tests/test_agno_tools/test_complexity_cognitive.py b/tests/test_agno_tools/test_complexity_cognitive.py
new file mode 100644
index 0000000000000000000000000000000000000000..ef0d001ca02266ac1c29a107a42a08c1928ff386
--- /dev/null
+++ b/tests/test_agno_tools/test_complexity_cognitive.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+import ast
+import textwrap
+import sys
+from pathlib import Path
+
+# Ensure project root is on sys.path
+project_root = Path(__file__).resolve().parent.parent.parent
+sys.path.insert(0, str(project_root))
+
+from audit_system.tools.complexity_analyzer_tool import ComplexityAnalyzerTool
+
+def test_cognitive_complexity_counts_top_level_branches_independently():
+    code = textwrap.dedent(
+        '''
+        def sample(x):
+            if x > 0:
+                pass
+            if x < 0:
+                pass
+            return x
+        '''
+    )
+    tree = ast.parse(code)
+    func = next(n for n in ast.walk(tree) if isinstance(n, ast.FunctionDef))
+    tool = ComplexityAnalyzerTool()
+    assert tool._calculate_cognitive_complexity(func) == 2
 
EOF
)
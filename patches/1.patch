 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/streamlit_app.py b/streamlit_extension/streamlit_app.py
index e5dc1db0960bfba1eced1f9630f0cb46005951cb..1cb1b1dd9f676788bb66d120b214c5c709827b6d 100644
--- a/streamlit_extension/streamlit_app.py
+++ b/streamlit_extension/streamlit_app.py
@@ -111,59 +111,65 @@ if is_ui():
 # === ORCHESTRATION ============================================================
 
 def setup_application() -> None:
     """Inicializa estado de sess√£o e depend√™ncias m√≠nimas."""
     initialize_session_state()
     logger.info("Session state initialized.")
 
 def _render_login_inline() -> None:
     """Renderiza a p√°gina de login de forma segura (somente em UI)."""
     if not is_ui():
         return
     try:
         render_login_page()
     except Exception as e:
         # Evita hard-fail na tela de login; mostra erro amig√°vel e loga detalhes.
         logger.exception("Authentication UI error: %s", e)
         safe_streamlit_error("üîí Authentication system unavailable at the moment.")
 
 def authenticate_user() -> Optional[AuthenticatedUser]:
     """
     Controla autentica√ß√£o com fallback simples e seguro.
     - Headless: retorna usu√°rio sentinel.
     - UI sem sess√£o: mostra login e interrompe render do app por agora.
     - UI com sess√£o: retorna dados do usu√°rio (normalizados).
     """
+    print("DEBUG: Starting authentication check...")
+
     if not is_ui():
         # Em headless n√£o h√° sess√£o UI: retorna sentinel para seguir smoke test.
         return AuthenticatedUser(name="Headless", id="headless")
 
     if not is_user_authenticated():
+        print("DEBUG: User NOT authenticated, showing login")
         _render_login_inline()
         return None
 
+    print("DEBUG: User IS authenticated, proceeding...")
     user = get_authenticated_user()
+    print(f"DEBUG: Retrieved user: {user}")
+
     # Normaliza√ß√£o defensiva do retorno do auth layer
     if isinstance(user, dict):
         # Mapeia chaves padr√£o, tolerando aus√™ncia.
         return AuthenticatedUser(
             id=str(user.get("id", "")),
             name=str(user.get("name", "User")),
             email=str(user.get("email", "")),
             role=str(user.get("role", "")),
         )
 
     # Fallback seguro (n√£o quebra UI, mas deixa evidente o estado)
     logger.warning("Authenticated user returned in unexpected format: %r", user)
     return AuthenticatedUser(name="User")
 
 def render_application_ui(user: AuthenticatedUser) -> None:
     """Renderiza a UI principal com seguran√ßa e isolando falhas."""
     if not is_ui():
         return
 
     try:
         # Sidebar/navigation
         _sidebar_state = render_sidebar()
 
         # Top bar (sauda√ß√£o, status, etc.)
         render_topbar(user)
diff --git a/streamlit_extension/utils/auth.py b/streamlit_extension/utils/auth.py
index 7a4fbc825c7e26a638bdebc4de9a910f7cb8eac0..a864511c717429fbf08b9dd40131888552670cd6 100644
--- a/streamlit_extension/utils/auth.py
+++ b/streamlit_extension/utils/auth.py
@@ -282,86 +282,99 @@ class GoogleOAuthManager:
         self._stash_with_ttl("oauth_state", state, self.cfg.state_ttl_seconds)
         self._stash_with_ttl("oauth_nonce", nonce, self.cfg.nonce_ttl_seconds)
         self.store.set("oauth_flow_id", flow_id)
 
         extra = {
             "access_type": "offline",
             "include_granted_scopes": "true",
             "state": state,
             "nonce": nonce,  # OpenID Connect
             "prompt": "consent" if not self._has_refresh_token() else None,
             "code_challenge": code_challenge,
             "code_challenge_method": "S256",
         }
         if self.cfg.allowed_hd:
             extra["hd"] = self.cfg.allowed_hd
 
         auth_url, _ = flow.authorization_url(**{k: v for k, v in extra.items() if v is not None})
         _json_log(self.logger, "auth_url_issued", flow_id=flow_id, state=state, has_refresh=self._has_refresh_token())
         return auth_url, state
 
     # ---- Callback/Troca de c√≥digo -------------------------------------------
     def handle_callback(self, authorization_code: str, state: str) -> Dict[str, Any]:
         """Troca code por tokens, valida state/nonce/iss/aud/azp e popula sess√£o autenticada."""
         flow_id = self.store.get("oauth_flow_id")
 
+        # Debug session state before processing callback
+        try:
+            print(f"DEBUG: Session before callback: {list(st.session_state.keys())}")
+        except Exception:
+            pass
+
         if not self._pop_if_valid("oauth_state", state):
             # limpa res√≠duos para evitar multi-aba confusa
             for k in ("oauth_code_verifier", "oauth_nonce"):
                 self.store.delete(k)
             raise ValueError("Estado OAuth inv√°lido/expirado (CSRF)")
 
         code_verifier_payload = self.store.get("oauth_code_verifier")
         code_verifier = code_verifier_payload.get("value") if isinstance(code_verifier_payload, dict) else None
         self.store.delete("oauth_code_verifier")
 
         flow = self._create_flow(code_verifier=code_verifier)
         try:
             flow.fetch_token(code=authorization_code)
             cred: Credentials = flow.credentials
         except Exception as e:
             _json_log(self.logger, "code_exchange_failed", flow_id=flow_id, error=str(e))
             raise RuntimeError(f"Falha ao trocar code por token: {e}") from e
 
         # Resolve user info (inclui valida√ß√£o do id_token)
         user_info, access_expiry_iso = self._resolve_user_info_and_expiry(cred)
 
         # Mapeia sess√£o (sem client_secret/token_uri)
         session_data: Dict[str, Any] = {
             "user_info": user_info,
             "credentials": {
                 "token": cred.token,
                 "refresh_token": cred.refresh_token,
                 "scopes": list(cred.scopes or []),
             },
             "authenticated_at": _now().isoformat(),
             "access_expires_at": access_expiry_iso,
             "expires_at": (_now() + timedelta(seconds=self.cfg.session_timeout_seconds)).isoformat(),
         }
         self.store.set("authenticated", True)
         self.store.set("user_session", session_data)
         _json_log(self.logger, "login_success", flow_id=flow_id, email=user_info.get("email"), sub=user_info.get("id"))
+
+        # Debug session state after processing callback
+        try:
+            print(f"DEBUG: Session after callback: {list(st.session_state.keys())}")
+            print(f"DEBUG: Authenticated flag: {self.store.get('authenticated')}")
+        except Exception:
+            pass
         return session_data
 
     # ---- User info (ID Token / UserInfo / People API) ------------------------
     def _resolve_user_info_and_expiry(self, credentials: Credentials) -> Tuple[Dict[str, Any], Optional[str]]:
         """
         Valida id_token quando presente (iss/aud/azp/nonce) ou consulta /userinfo.
         Retorna (userinfo_dict, access_token_expiry_iso|None).
         """
         idinfo: Optional[Dict[str, Any]] = None
         access_expiry_iso: Optional[str] = None
 
         # Access token expiry (se google-auth popular)
         try:
             if getattr(credentials, "expiry", None):
                 access_expiry_iso = credentials.expiry.astimezone(timezone.utc).isoformat()
         except Exception:
             access_expiry_iso = None
 
         # 1) id_token ‚Üí valida√ß√£o completa
         if getattr(credentials, "id_token", None):
             try:
                 idinfo = google_id_token.verify_oauth2_token(
                     credentials.id_token,
                     Request(),
                     audience=self.cfg.client_id,
@@ -568,62 +581,67 @@ class GoogleOAuthManager:
                     retries=1,
                 )
         except Exception as e:
             _json_log(self.logger, "revoke_failed", error=str(e))
 
         for key in ("authenticated", "user_session", "oauth_state", "oauth_nonce", "oauth_code_verifier", "oauth_flow_id"):
             self.store.delete(key)
 
     # ---- UI helpers (opcionais) ----------------------------------------------
     def _safe_redirect(self, path: str):
         """Redirect interno com allowlist para evitar open redirect."""
         if not DEPS:
             return
         if path not in self.cfg.allowed_redirect_paths:
             path = "/"
         st.markdown(f'<meta http-equiv="refresh" content="0; url={path}">', unsafe_allow_html=True)
 
     def render_login_page(self) -> None:
         if not DEPS:
             raise RuntimeError("Sem Streamlit dispon√≠vel")
         st.title("üîê TDD Framework - Login necess√°rio")
         st.write("Entre com sua conta Google para continuar.")
 
         qp = st.query_params or {}
         if "code" in qp and "state" in qp:
+            # After rerun, finalize login by clearing params and showing message
+            if st.session_state.get("_oauth_authenticated"):
+                user = (self.get_current_user() or {}).get("name", "")
+                st.query_params.clear()
+                st.session_state.pop("_oauth_authenticated", None)
+                if user:
+                    st.success(f"‚úÖ Bem-vindo(a), {user}!")
+                return
+
             with st.spinner("Autenticando..."):
                 try:
-                    data = self.handle_callback(qp["code"], qp["state"])
-                    # Clear OAuth parameters and show success
-                    st.query_params.clear()
-                    st.success(f"‚úÖ Bem-vindo(a), {data['user_info']['name']}!")
-                    # Directly rerun to preserve session state
-                    # No redirect needed - let Streamlit handle the refresh
+                    self.handle_callback(qp["code"], qp["state"])
+                    # Flag so next run can clean query params without losing session state
+                    st.session_state["_oauth_authenticated"] = True
                     st.rerun()
                 except Exception as e:
                     st.error(f"‚ùå Falha na autentica√ß√£o: {e}")
-                    # Limpa artefatos para evitar stuck em multi-aba
                     for k in ("oauth_state", "oauth_nonce", "oauth_code_verifier", "oauth_flow_id"):
                         self.store.delete(k)
                     st.query_params.clear()
                     st.rerun()
             return
 
         if st.button("üîó Entrar com Google", type="primary", use_container_width=True):
             try:
                 url, _ = self.get_authorization_url()
                 st.markdown(f'<meta http-equiv="refresh" content="0; url={url}">', unsafe_allow_html=True)
             except Exception as e:
                 st.error(f"N√£o foi poss√≠vel iniciar OAuth: {e}")
 
     def render_user_menu(self) -> None:
         if not (DEPS and self.is_authenticated()):
             return
         user = self.get_current_user() or {}
         with st.sidebar:
             st.markdown("---")
             st.markdown("### üë§ Usu√°rio")
             c1, c2 = st.columns([1, 2])
             with c1:
                 if user.get("picture"):
                     st.image(user["picture"], width=48)
                 else:
@@ -671,54 +689,65 @@ def require_authentication(page_func):
 
 
 # =============================================================================
 # Fun√ß√µes utilit√°rias compat√≠veis com o seu c√≥digo atual
 # =============================================================================
 
 def render_login_page() -> None:
     """Wrapper function for backward compatibility."""
     if not DEPS:
         raise RuntimeError("Sem Streamlit dispon√≠vel")
     auth = GoogleOAuthManager()
     return auth.render_login_page()
 
 def get_authenticated_user() -> Optional[Dict[str, Any]]:
     if not DEPS:
         return _get_traditional_auth_user()
     auth = GoogleOAuthManager()
     if not auth.configured and auth.cfg.allow_dev_fallback:
         return _get_traditional_auth_user()
     return auth.get_current_user()
 
 def is_user_authenticated() -> bool:
     if not DEPS:
         return _is_traditional_auth_active()
     auth = GoogleOAuthManager()
-    
+
+    try:
+        print(f"DEBUG: Auth configured: {auth.configured}")
+        print(f"DEBUG: Session keys: {list(st.session_state.keys())}")
+    except Exception:
+        pass
+
     # Always check OAuth session first, even if not configured
     # This ensures OAuth sessions persist correctly after reruns
-    if auth.is_authenticated():
+    is_auth = auth.is_authenticated()
+    try:
+        print(f"DEBUG: is_authenticated result: {is_auth}")
+    except Exception:
+        pass
+    if is_auth:
         return True
         
     # Only use fallback if no OAuth session exists
     if not auth.configured and auth.cfg.allow_dev_fallback:
         return _is_traditional_auth_active()
         
     return False
 
 # ---- Fallbacks para middleware legado (quando existir) -----------------------
 
 def _get_traditional_auth_user() -> Optional[Dict[str, Any]]:
     try:
         from ..auth.middleware import get_current_user  # type: ignore
         u = get_current_user()
         if u:
             return {
                 "id": getattr(u, "id", "unknown"),
                 "email": getattr(u, "email", getattr(u, "username", "user@local")),
                 "name": getattr(u, "username", getattr(u, "name", "User")),
                 "picture": None,
                 "organization": None,
             }
     except Exception:
         pass
 
 
EOF
)
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/streamlit_app.py b/streamlit_extension/streamlit_app.py
index e5dc1db0960bfba1eced1f9630f0cb46005951cb..1cb1b1dd9f676788bb66d120b214c5c709827b6d 100644
--- a/streamlit_extension/streamlit_app.py
+++ b/streamlit_extension/streamlit_app.py
@@ -111,59 +111,65 @@ if is_ui():
 # === ORCHESTRATION ============================================================
 
 def setup_application() -> None:
     """Inicializa estado de sessÃ£o e dependÃªncias mÃ­nimas."""
     initialize_session_state()
     logger.info("Session state initialized.")
 
 def _render_login_inline() -> None:
     """Renderiza a pÃ¡gina de login de forma segura (somente em UI)."""
     if not is_ui():
         return
     try:
         render_login_page()
     except Exception as e:
         # Evita hard-fail na tela de login; mostra erro amigÃ¡vel e loga detalhes.
         logger.exception("Authentication UI error: %s", e)
         safe_streamlit_error("ðŸ”’ Authentication system unavailable at the moment.")
 
 def authenticate_user() -> Optional[AuthenticatedUser]:
     """
     Controla autenticaÃ§Ã£o com fallback simples e seguro.
     - Headless: retorna usuÃ¡rio sentinel.
     - UI sem sessÃ£o: mostra login e interrompe render do app por agora.
     - UI com sessÃ£o: retorna dados do usuÃ¡rio (normalizados).
     """
+    print("DEBUG: Starting authentication check...")
+
     if not is_ui():
         # Em headless nÃ£o hÃ¡ sessÃ£o UI: retorna sentinel para seguir smoke test.
         return AuthenticatedUser(name="Headless", id="headless")
 
     if not is_user_authenticated():
+        print("DEBUG: User NOT authenticated, showing login")
         _render_login_inline()
         return None
 
+    print("DEBUG: User IS authenticated, proceeding...")
     user = get_authenticated_user()
+    print(f"DEBUG: Retrieved user: {user}")
+
     # NormalizaÃ§Ã£o defensiva do retorno do auth layer
     if isinstance(user, dict):
         # Mapeia chaves padrÃ£o, tolerando ausÃªncia.
         return AuthenticatedUser(
             id=str(user.get("id", "")),
             name=str(user.get("name", "User")),
             email=str(user.get("email", "")),
             role=str(user.get("role", "")),
         )
 
     # Fallback seguro (nÃ£o quebra UI, mas deixa evidente o estado)
     logger.warning("Authenticated user returned in unexpected format: %r", user)
     return AuthenticatedUser(name="User")
 
 def render_application_ui(user: AuthenticatedUser) -> None:
     """Renderiza a UI principal com seguranÃ§a e isolando falhas."""
     if not is_ui():
         return
 
     try:
         # Sidebar/navigation
         _sidebar_state = render_sidebar()
 
         # Top bar (saudaÃ§Ã£o, status, etc.)
         render_topbar(user)
diff --git a/streamlit_extension/utils/auth.py b/streamlit_extension/utils/auth.py
index 7a4fbc825c7e26a638bdebc4de9a910f7cb8eac0..da9b8945856460026ceea22c6f0d2f6d1fa57a2b 100644
--- a/streamlit_extension/utils/auth.py
+++ b/streamlit_extension/utils/auth.py
@@ -282,86 +282,99 @@ class GoogleOAuthManager:
         self._stash_with_ttl("oauth_state", state, self.cfg.state_ttl_seconds)
         self._stash_with_ttl("oauth_nonce", nonce, self.cfg.nonce_ttl_seconds)
         self.store.set("oauth_flow_id", flow_id)
 
         extra = {
             "access_type": "offline",
             "include_granted_scopes": "true",
             "state": state,
             "nonce": nonce,  # OpenID Connect
             "prompt": "consent" if not self._has_refresh_token() else None,
             "code_challenge": code_challenge,
             "code_challenge_method": "S256",
         }
         if self.cfg.allowed_hd:
             extra["hd"] = self.cfg.allowed_hd
 
         auth_url, _ = flow.authorization_url(**{k: v for k, v in extra.items() if v is not None})
         _json_log(self.logger, "auth_url_issued", flow_id=flow_id, state=state, has_refresh=self._has_refresh_token())
         return auth_url, state
 
     # ---- Callback/Troca de cÃ³digo -------------------------------------------
     def handle_callback(self, authorization_code: str, state: str) -> Dict[str, Any]:
         """Troca code por tokens, valida state/nonce/iss/aud/azp e popula sessÃ£o autenticada."""
         flow_id = self.store.get("oauth_flow_id")
 
+        # Debug session state before processing callback
+        try:
+            print(f"DEBUG: Session before callback: {list(st.session_state.keys())}")
+        except Exception:
+            pass
+
         if not self._pop_if_valid("oauth_state", state):
             # limpa resÃ­duos para evitar multi-aba confusa
             for k in ("oauth_code_verifier", "oauth_nonce"):
                 self.store.delete(k)
             raise ValueError("Estado OAuth invÃ¡lido/expirado (CSRF)")
 
         code_verifier_payload = self.store.get("oauth_code_verifier")
         code_verifier = code_verifier_payload.get("value") if isinstance(code_verifier_payload, dict) else None
         self.store.delete("oauth_code_verifier")
 
         flow = self._create_flow(code_verifier=code_verifier)
         try:
             flow.fetch_token(code=authorization_code)
             cred: Credentials = flow.credentials
         except Exception as e:
             _json_log(self.logger, "code_exchange_failed", flow_id=flow_id, error=str(e))
             raise RuntimeError(f"Falha ao trocar code por token: {e}") from e
 
         # Resolve user info (inclui validaÃ§Ã£o do id_token)
         user_info, access_expiry_iso = self._resolve_user_info_and_expiry(cred)
 
         # Mapeia sessÃ£o (sem client_secret/token_uri)
         session_data: Dict[str, Any] = {
             "user_info": user_info,
             "credentials": {
                 "token": cred.token,
                 "refresh_token": cred.refresh_token,
                 "scopes": list(cred.scopes or []),
             },
             "authenticated_at": _now().isoformat(),
             "access_expires_at": access_expiry_iso,
             "expires_at": (_now() + timedelta(seconds=self.cfg.session_timeout_seconds)).isoformat(),
         }
         self.store.set("authenticated", True)
         self.store.set("user_session", session_data)
         _json_log(self.logger, "login_success", flow_id=flow_id, email=user_info.get("email"), sub=user_info.get("id"))
+
+        # Debug session state after processing callback
+        try:
+            print(f"DEBUG: Session after callback: {list(st.session_state.keys())}")
+            print(f"DEBUG: Authenticated flag: {self.store.get('authenticated')}")
+        except Exception:
+            pass
         return session_data
 
     # ---- User info (ID Token / UserInfo / People API) ------------------------
     def _resolve_user_info_and_expiry(self, credentials: Credentials) -> Tuple[Dict[str, Any], Optional[str]]:
         """
         Valida id_token quando presente (iss/aud/azp/nonce) ou consulta /userinfo.
         Retorna (userinfo_dict, access_token_expiry_iso|None).
         """
         idinfo: Optional[Dict[str, Any]] = None
         access_expiry_iso: Optional[str] = None
 
         # Access token expiry (se google-auth popular)
         try:
             if getattr(credentials, "expiry", None):
                 access_expiry_iso = credentials.expiry.astimezone(timezone.utc).isoformat()
         except Exception:
             access_expiry_iso = None
 
         # 1) id_token â†’ validaÃ§Ã£o completa
         if getattr(credentials, "id_token", None):
             try:
                 idinfo = google_id_token.verify_oauth2_token(
                     credentials.id_token,
                     Request(),
                     audience=self.cfg.client_id,
@@ -671,54 +684,65 @@ def require_authentication(page_func):
 
 
 # =============================================================================
 # FunÃ§Ãµes utilitÃ¡rias compatÃ­veis com o seu cÃ³digo atual
 # =============================================================================
 
 def render_login_page() -> None:
     """Wrapper function for backward compatibility."""
     if not DEPS:
         raise RuntimeError("Sem Streamlit disponÃ­vel")
     auth = GoogleOAuthManager()
     return auth.render_login_page()
 
 def get_authenticated_user() -> Optional[Dict[str, Any]]:
     if not DEPS:
         return _get_traditional_auth_user()
     auth = GoogleOAuthManager()
     if not auth.configured and auth.cfg.allow_dev_fallback:
         return _get_traditional_auth_user()
     return auth.get_current_user()
 
 def is_user_authenticated() -> bool:
     if not DEPS:
         return _is_traditional_auth_active()
     auth = GoogleOAuthManager()
-    
+
+    try:
+        print(f"DEBUG: Auth configured: {auth.configured}")
+        print(f"DEBUG: Session keys: {list(st.session_state.keys())}")
+    except Exception:
+        pass
+
     # Always check OAuth session first, even if not configured
     # This ensures OAuth sessions persist correctly after reruns
-    if auth.is_authenticated():
+    is_auth = auth.is_authenticated()
+    try:
+        print(f"DEBUG: is_authenticated result: {is_auth}")
+    except Exception:
+        pass
+    if is_auth:
         return True
         
     # Only use fallback if no OAuth session exists
     if not auth.configured and auth.cfg.allow_dev_fallback:
         return _is_traditional_auth_active()
         
     return False
 
 # ---- Fallbacks para middleware legado (quando existir) -----------------------
 
 def _get_traditional_auth_user() -> Optional[Dict[str, Any]]:
     try:
         from ..auth.middleware import get_current_user  # type: ignore
         u = get_current_user()
         if u:
             return {
                 "id": getattr(u, "id", "unknown"),
                 "email": getattr(u, "email", getattr(u, "username", "user@local")),
                 "name": getattr(u, "username", getattr(u, "name", "User")),
                 "picture": None,
                 "organization": None,
             }
     except Exception:
         pass
 
 
EOF
)
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/services/client_service.py b/streamlit_extension/services/client_service.py
index 5a9f5c3e1600009fd41b01f92b4fc103628d00e7..f5ac86bf7cc64753b814e6be203698240c820400 100644
--- a/streamlit_extension/services/client_service.py
+++ b/streamlit_extension/services/client_service.py
@@ -59,53 +59,53 @@ class ClientRepository(BaseRepository):
             if filters:
                 if filters.has('status'):
                     where_conditions.append("status = ?")
                     params.append(filters.get('status'))
                 
                 if filters.has('name'):
                     where_conditions.append("name LIKE ?")
                     params.append(f"%{filters.get('name')}%")
                 
                 if filters.has('email'):
                     where_conditions.append("email LIKE ?")
                     params.append(f"%{filters.get('email')}%")
                 
                 if filters.has('company'):
                     where_conditions.append("company LIKE ?")
                     params.append(f"%{filters.get('company')}%")
             
             # Build WHERE clause
             where_clause = " WHERE " + " AND ".join(where_conditions) if where_conditions else ""
             
             # Build ORDER BY clause
             order_clause = ""
             if sort:
                 order_clause = f" ORDER BY {sort.field} {'ASC' if sort.ascending else 'DESC'}"
             
-            # Count total records
-            count_query = f"SELECT COUNT(*) FROM framework_clients{where_clause}"
-            total_count = self.db_manager.execute_query(count_query, params)[0]['COUNT(*)']
+            # Count total records (usar alias para chave estÃ¡vel no resultado)
+            count_query = f"SELECT COUNT(*) AS total FROM framework_clients{where_clause}"
+            total_count = self.db_manager.execute_query(count_query, params)[0]['total']
             
             # Calculate pagination
             offset = (page - 1) * page_size
             total_pages = (total_count + page_size - 1) // page_size
             
             # Get paginated results
             data_query = f"""
                 SELECT * FROM framework_clients
                 {where_clause}
                 {order_clause}
                 LIMIT ? OFFSET ?
             """
             data_params = params + [page_size, offset]
             clients = self.db_manager.execute_query(data_query, data_params)
             
             return PaginatedResult(
                 items=clients,
                 total=total_count,
                 page=page,
                 page_size=page_size,
                 total_pages=total_pages
             )
             
         except Exception as e:
             self.db_manager.logger.error(f"Error finding clients: {e}")
diff --git a/streamlit_extension/services/timer_service.py b/streamlit_extension/services/timer_service.py
index bb13d245adaeccf4d136e58e646b8c451efeb8fd..a6ff8e2fa55f6384ad939690f6237c2d47cfae0c 100644
--- a/streamlit_extension/services/timer_service.py
+++ b/streamlit_extension/services/timer_service.py
@@ -906,51 +906,53 @@ class TimerService(BaseService):
         self.log_operation("update_session_ratings", session_id=session_id, ratings=ratings)
         
         # Validate ratings
         validation_errors = self.validate_business_rules(ratings)
         if validation_errors:
             return ServiceResult.fail_multiple(validation_errors)
         
         try:
             success = self.repository.update_session(session_id, ratings)
             
             if success:
                 self.log_operation("update_session_ratings_success", session_id=session_id)
                 return ServiceResult.ok(True)
             else:
                 return ServiceResult.business_rule_violation("Failed to update session ratings")
                 
         except Exception as e:
             return self.handle_database_error("update_session_ratings", e)
     
     # Private helper methods
     
     def _calculate_elapsed_time(self, session: Dict[str, Any]) -> int:
         """Calculate elapsed time for active session."""
         start_time = session['start_time']
         if isinstance(start_time, str):
-            start_time = datetime.fromisoformat(start_time)
+            # Normaliza ISO 8601 com sufixo 'Z' (UTC) para compatibilidade com fromisoformat
+            iso_str = start_time.replace('Z', '+00:00') if start_time.endswith('Z') else start_time
+            start_time = datetime.fromisoformat(iso_str)
         
         elapsed = datetime.now() - start_time
         return int(elapsed.total_seconds() / 60)
     
     def _calculate_remaining_time(self, session: Dict[str, Any]) -> int:
         """Calculate remaining time for session."""
         planned_duration = session.get('planned_duration_minutes', 0)
         elapsed = self._calculate_elapsed_time(session)
         
         return max(0, planned_duration - elapsed)
     
     def _calculate_progress_percentage(self, session: Dict[str, Any]) -> float:
         """Calculate progress percentage for session."""
         planned_duration = session.get('planned_duration_minutes', 0)
         if planned_duration <= 0:
             return 0.0
         
         elapsed = self._calculate_elapsed_time(session)
         return min(100.0, (elapsed / planned_duration) * 100)
     
     def _format_duration(self, minutes: float) -> str:
         """Format duration in minutes to human-readable string."""
         if minutes is None:
             return "0 minutes"
         
 
EOF
)
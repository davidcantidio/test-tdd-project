python3 - << 'EOF'
import json, sys, os, shutil
from pathlib import Path

# ---------- Helpers ----------
def load_json(p: Path):
    with p.open('r', encoding='utf-8') as f:
        return json.load(f)

def save_json(p: Path, data: dict):
    p.parent.mkdir(parents=True, exist_ok=True)
    tmp = p.with_suffix('.tmp')
    with tmp.open('w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    tmp.replace(p)

def ensure_backup(file_path: str, backup_root: Path, backup_id: str, metadata_path: Path):
    """Copia o arquivo para BACKUP_DIR/files_<ID>/<path_relativo> e
    atualiza o array files_backed_up no metadata."""
    src = Path(file_path)
    # Guard: só faz backup de arquivos que existem
    if not src.exists():
        return False

    rel = src.as_posix()
    # destino
    dest = backup_root / f"files_{backup_id}" / rel
    dest.parent.mkdir(parents=True, exist_ok=True)
    shutil.copy2(src, dest)

    # atualizar metadata
    meta = load_json(metadata_path)
    files = set(meta.get("files_backed_up", []))
    if rel not in files:
        files.add(rel)
        meta["files_backed_up"] = sorted(files)
        save_json(metadata_path, meta)
    return True

def validate_python_syntax(file_path: str) -> bool:
    if not file_path.endswith(".py"):
        return True
    import py_compile
    try:
        py_compile.compile(file_path, doraise=True)
        return True
    except Exception:
        return False

# ---------- Config/env ----------
audit_dir = Path(os.environ.get('AUDIT_DIR', '.audit_intelligent'))
selective = int(os.environ.get('SELECTIVE', '0'))

backup_dir = Path(os.environ.get('BACKUP_DIR', '.optimization_backups'))
backup_id  = os.environ.get('SCRIPT_START_TIME')  # passada do Bash via env
metadata_path = backup_dir / "metadata" / f"backup_{backup_id}.json"

# ---------- Imports do agente ----------
sys.path.append('.')
try:
    from audit_system.agents.intelligent_code_agent import IntelligentCodeAgent, AnalysisDepth, SemanticMode
except Exception as e:
    print(f"❌ Error importing optimization agents: {e}")
    print("📋 Make sure the audit system is properly installed (PYTHONPATH).")
    sys.exit(1)

# ---------- Carrega resultados ----------
try:
    data = load_json(audit_dir / 'intelligent_analysis.json')
except Exception as e:
    print(f"❌ Error loading audit results: {e}")
    sys.exit(1)

results = data.get('results', [])
targets = [r for r in results if r.get('recommended_refactorings_count', 0) > 0]
if not targets:
    print("ℹ️ No files with optimization recommendations found")
    sys.exit(0)

print(f"🔧 Found {len(targets)} files with optimization opportunities")

code_agent = IntelligentCodeAgent(
    project_root=Path('.'),
    enable_real_llm=True,
    analysis_depth=AnalysisDepth.DEEP,
    semantic_mode=SemanticMode.AGGRESSIVE,
    dry_run=False
)

total_applied = 0
total_files_modified = 0
failed_files = []

for fr in targets:
    file_path = fr['file_path']
    count = fr['recommended_refactorings_count']
    qscore = fr.get('semantic_quality_score', 0)
    print(f"\n📝 Processing: {file_path}")
    print(f"   🔧 {count} optimizations available")
    print(f"   📊 Current quality score: {qscore:.1f}")

    if selective:
        try:
            resp = input(f"   Apply optimizations to {file_path}? (y/N/q): ").strip().lower()
        except EOFError:
            resp = 'n'
        if resp == 'q':
            print("🛑 Optimization process stopped by user")
            break
        if resp != 'y':
            print("   ⏭️ Skipped")
            continue

    try:
        agent = IntelligentCodeAgent(
            project_root=Path('.'),
            enable_real_llm=True,
            analysis_depth=AnalysisDepth.DEEP,
            semantic_mode=SemanticMode.AGGRESSIVE
        )
        analysis = agent.analyze_file_intelligently(file_path)

        if not getattr(analysis, "recommended_refactorings", None):
            print("   ℹ️ No current optimization recommendations")
            continue

        # 1) BACKUP antes de mexer
        backed_up = ensure_backup(file_path, backup_dir, backup_id, metadata_path)
        if not backed_up:
            print("   ⚠️ File not found for backup; skipping.")
            continue

        # 2) Aplica refatorações
        result = agent.apply_intelligent_refactorings(
            analysis=analysis,
            selected_refactorings=None
        )
        applied = int(result.get('applied', 0))
        failed  = int(result.get('failed', 0))

        # 3) Valida sintaxe (.py) — rollback se falhar
        if not validate_python_syntax(file_path):
            # rollback do arquivo
            src_backup = backup_dir / f"files_{backup_id}" / Path(file_path).as_posix()
            if src_backup.exists():
                src_backup.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(src_backup, file_path)
            print(f"   ❌ Syntax error after changes — rolled back {file_path}")
            failed_files.append(file_path)
            continue

        if applied > 0:
            total_applied += applied
            total_files_modified += 1
            msg = f"   ✅ Applied {applied} optimizations successfully"
            if failed > 0:
                msg += f" (⚠️ {failed} failed)"
            print(msg)
        else:
            status = result.get('status', 'unknown')
            if status == 'completed':
                print("   ℹ️ No optimizations to apply (already optimized)")
            else:
                print(f"   ℹ️ No optimizations applied (status: {status})")

    except Exception as e:
        failed_files.append(file_path)
        print(f"   ❌ Error optimizing {file_path}: {e}")

print(f"\n🎉 Optimization Summary:")
print(f"   📁 Files modified: {total_files_modified}")
print(f"   🔧 Total optimizations applied: {total_applied}")
if failed_files:
    print(f"   ❗ Files with errors (kept/rolled back): {len(failed_files)}")
EOF

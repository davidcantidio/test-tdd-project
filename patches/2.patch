 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/duration_system/CLAUDE.md b/duration_system/CLAUDE.md
index 20e8da489dbcb30a18b1d000621b9b49466c04ba..3d870ab6cd0223d9a918ff11704b36ec0cc09576 100644
--- a/duration_system/CLAUDE.md
+++ b/duration_system/CLAUDE.md
@@ -1,31 +1,31 @@
 # ðŸ¤– CLAUDE.md - Duration System Module
 
 **Module:** duration_system/  
 **Purpose:** Enterprise duration calculation and security utilities  
 **Architecture:** Standalone modules for duration handling, security, and data protection  
-**Last Updated:** 2025-08-16
+**Last Updated:** 2025-08-18
 
 ---
 
 ## â±ï¸ **Module Overview**
 
 Comprehensive duration and security system featuring:
 - **Duration Engine**: Calculation and formatting with business calendar support
 - **Security Stack**: JSON validation, cache protection, transaction safety
 - **Data Protection**: GDPR compliance, secure serialization, sanitization
 - **Performance**: Interrupt-safe caching, optimized queries, circuit breakers
 
 ---
 
 ## ðŸ—ï¸ **Module Architecture**
 
 ### **Core Components**
 ```
 duration_system/
 â”œâ”€â”€ duration_calculator.py    # â±ï¸ Core duration calculations
 â”œâ”€â”€ duration_formatter.py     # ðŸ“ Human-readable formatting
 â”œâ”€â”€ business_calendar.py      # ðŸ“… Business days + holidays
 â”œâ”€â”€ json_handler.py          # ðŸ“Š JSON field operations
 â”œâ”€â”€ json_security.py         # ðŸ›¡ï¸ JSON validation & sanitization
 â”œâ”€â”€ cache_fix.py             # ðŸ”„ Interrupt-safe LRU cache
 â”œâ”€â”€ database_transactions.py # ðŸ“Š Transaction safety
diff --git a/duration_system/query_builders.py b/duration_system/query_builders.py
index 3bcb2327d45593ad913eadfc7b8d1a928102d6e9..b89533d1474c08d1c60ff8abb24fba13c1e082ec 100644
--- a/duration_system/query_builders.py
+++ b/duration_system/query_builders.py
@@ -16,101 +16,109 @@ class QueryType(Enum):
     """Query operation types."""
     SELECT = "SELECT"
     INSERT = "INSERT"
     UPDATE = "UPDATE"
     DELETE = "DELETE"
 
 
 class JoinType(Enum):
     """SQL join types."""
     INNER = "INNER JOIN"
     LEFT = "LEFT JOIN"
     RIGHT = "RIGHT JOIN"
     FULL = "FULL OUTER JOIN"
 
 
 @dataclass
 class QueryCondition:
     """Represents a WHERE condition."""
     field: str
     operator: str  # =, !=, >, <, >=, <=, LIKE, IN, NOT IN
     value: Any
     logical_op: str = "AND"  # AND, OR
 
     def to_sql(self) -> Tuple[str, Any]:
         """Convert condition to SQL with parameter."""
-        if self.operator == "IN":
-            placeholders = ",".join("?" for _ in self.value)
-            return f"{self.field} IN ({placeholders})", self.value
-        elif self.operator == "NOT IN":
-            placeholders = ",".join("?" for _ in self.value)
-            return f"{self.field} NOT IN ({placeholders})", self.value
+        op = self.operator.upper()
+        if op in {"IN", "NOT IN"}:
+            seq = list(self.value) if isinstance(self.value, (list, tuple, set)) else []
+            if not seq:
+                # Empty IN: nunca casa; Empty NOT IN: sempre casa
+                return ("1=0", []) if op == "IN" else ("1=1", [])
+            placeholders = ",".join("?" for _ in seq)
+            clause = f"{self.field} {'NOT IN' if op == 'NOT IN' else 'IN'} ({placeholders})"
+            return clause, list(seq)
         else:
             return f"{self.field} {self.operator} ?", [self.value]
 
 
 @dataclass
 class QueryJoin:
     """Represents a table join."""
     table: str
     join_type: JoinType
     on_condition: str
 
 
 class SecureQueryBuilder:
     """Secure SQL query builder with parameter binding and validation."""
 
     allowed_operators = {"=", "!=", ">", "<", ">=", "<=", "LIKE", "IN", "NOT IN"}
 
     def __init__(self, table: str, allowed_fields: Optional[Set[str]] = None):
         """Initialize query builder for specific table."""
         self.table = table
         self.query_type: Optional[QueryType] = None
         self.select_fields: List[str] = []
         self.conditions: List[QueryCondition] = []
         self.joins: List[QueryJoin] = []
         self.order_by_fields: List[str] = []
         self.group_by_fields: List[str] = []
         self.limit_value: Optional[int] = None
         self.offset_value: Optional[int] = None
         self.insert_data: Dict[str, Any] = {}
         self.update_data: Dict[str, Any] = {}
         self._allowed_fields = allowed_fields
 
     # ------------------------------------------------------------------
     # Helper validation methods
     def _validate_field(self, field: str) -> None:
         if self._allowed_fields is not None and field not in self._allowed_fields:
             raise ValueError(f"Field {field} not allowed")
         # Basic regex validation to avoid injection through field names
         if not re.match(r"^[A-Za-z0-9_\.]+$", field):
             raise ValueError(f"Invalid field name: {field}")
 
     def _validate_operator(self, operator: str) -> None:
         if operator not in self.allowed_operators:
             raise ValueError(f"Operator {operator} not allowed")
 
+    def _validate_on_condition(self, on_condition: str) -> None:
+        """Validate simple ON condition pattern like 'a.b = c.d'."""
+        if not re.match(r"^[A-Za-z0-9_\.]+\s*=\s*[A-Za-z0-9_\.]+$", on_condition):
+            raise ValueError(f"Invalid join condition: {on_condition}")
+
     # ------------------------------------------------------------------
     # Query construction methods
     def select(self, *fields: str) -> "SecureQueryBuilder":
         """Add SELECT fields."""
         self.query_type = QueryType.SELECT
         if fields:
             for field in fields:
                 self._validate_field(field)
             self.select_fields.extend(fields)
         else:
             self.select_fields = ["*"]
         return self
 
     def insert(self, data: Dict[str, Any]) -> "SecureQueryBuilder":
         """Set INSERT data."""
         self.query_type = QueryType.INSERT
         self.insert_data = data
         return self
 
     def update(self, data: Dict[str, Any]) -> "SecureQueryBuilder":
         """Set UPDATE data."""
         self.query_type = QueryType.UPDATE
         self.update_data = data
         return self
 
@@ -126,76 +134,85 @@ class SecureQueryBuilder:
         value: Any,
         logical_op: str = "AND",
     ) -> "SecureQueryBuilder":
         """Add WHERE condition with validation."""
         self._validate_field(field)
         self._validate_operator(operator)
         condition = QueryCondition(field, operator, value, logical_op)
         self.conditions.append(condition)
         return self
 
     def where_in(self, field: str, values: List[Any]) -> "SecureQueryBuilder":
         """Add WHERE IN condition."""
         return self.where(field, "IN", values)
 
     def where_like(self, field: str, pattern: str) -> "SecureQueryBuilder":
         """Add WHERE LIKE condition."""
         return self.where(field, "LIKE", pattern)
 
     def join(
         self,
         table: str,
         on_condition: str,
         join_type: JoinType = JoinType.INNER,
     ) -> "SecureQueryBuilder":
         """Add table join."""
+        self._validate_field(table)
+        self._validate_on_condition(on_condition)
         self.joins.append(QueryJoin(table, join_type, on_condition))
         return self
 
     def left_join(self, table: str, on_condition: str) -> "SecureQueryBuilder":
         """Add LEFT JOIN."""
         return self.join(table, on_condition, JoinType.LEFT)
 
     def order_by(self, field: str, direction: str = "ASC") -> "SecureQueryBuilder":
         """Add ORDER BY clause."""
         self._validate_field(field)
-        self.order_by_fields.append(f"{field} {direction}")
+        direction_upper = direction.upper()
+        if direction_upper not in {"ASC", "DESC"}:
+            raise ValueError(f"Invalid ORDER BY direction: {direction}")
+        self.order_by_fields.append(f"{field} {direction_upper}")
         return self
 
     def group_by(self, field: str) -> "SecureQueryBuilder":
         """Add GROUP BY clause."""
         self._validate_field(field)
         self.group_by_fields.append(field)
         return self
 
     def limit(self, count: int) -> "SecureQueryBuilder":
         """Add LIMIT clause."""
+        if not isinstance(count, int) or count < 0:
+            raise ValueError("LIMIT must be a non-negative integer")
         self.limit_value = count
         return self
 
     def offset(self, count: int) -> "SecureQueryBuilder":
         """Add OFFSET clause."""
+        if not isinstance(count, int) or count < 0:
+            raise ValueError("OFFSET must be a non-negative integer")
         self.offset_value = count
         return self
 
     def build(self) -> Tuple[str, List[Any]]:
         """Build final SQL query with parameters and complexity checks."""
         if len(self.joins) > 5:
             raise ValueError("Too many joins in query")
         if len(self.conditions) > 20:
             raise ValueError("Too many conditions in query")
 
         if self.query_type == QueryType.SELECT:
             return self._build_select()
         if self.query_type == QueryType.INSERT:
             return self._build_insert()
         if self.query_type == QueryType.UPDATE:
             return self._build_update()
         if self.query_type == QueryType.DELETE:
             return self._build_delete()
         raise ValueError("Query type not set")
 
     def _build_select(self) -> Tuple[str, List[Any]]:
         """Build SELECT query."""
         query_parts = [f"SELECT {', '.join(self.select_fields)}"]
         query_parts.append(f"FROM {self.table}")
         params: List[Any] = []
@@ -209,57 +226,61 @@ class SecureQueryBuilder:
                 sql_part, condition_params = condition.to_sql()
                 if i > 0:
                     where_parts.append(condition.logical_op)
                 where_parts.append(sql_part)
                 params.extend(
                     condition_params if isinstance(condition_params, list) else [condition_params]
                 )
             query_parts.append("WHERE " + " ".join(where_parts))
 
         if self.group_by_fields:
             query_parts.append(f"GROUP BY {', '.join(self.group_by_fields)}")
 
         if self.order_by_fields:
             query_parts.append(f"ORDER BY {', '.join(self.order_by_fields)}")
 
         if self.limit_value is not None:
             query_parts.append(f"LIMIT {self.limit_value}")
             if self.offset_value is not None:
                 query_parts.append(f"OFFSET {self.offset_value}")
 
         return " ".join(query_parts), params
 
     def _build_insert(self) -> Tuple[str, List[Any]]:
         """Build INSERT query."""
         fields = list(self.insert_data.keys())
+        for f in fields:
+            self._validate_field(f)
         placeholders = ",".join("?" for _ in fields)
         query = f"INSERT INTO {self.table} ({', '.join(fields)}) VALUES ({placeholders})"
         params = list(self.insert_data.values())
         return query, params
 
     def _build_update(self) -> Tuple[str, List[Any]]:
         """Build UPDATE query."""
+        for f in self.update_data.keys():
+            self._validate_field(f)
         set_parts = [f"{field} = ?" for field in self.update_data.keys()]
         query_parts = [f"UPDATE {self.table}", f"SET {', '.join(set_parts)}"]
         params = list(self.update_data.values())
 
         if self.conditions:
             where_parts: List[str] = []
             for i, condition in enumerate(self.conditions):
                 sql_part, condition_params = condition.to_sql()
                 if i > 0:
                     where_parts.append(condition.logical_op)
                 where_parts.append(sql_part)
                 params.extend(
                     condition_params if isinstance(condition_params, list) else [condition_params]
                 )
             query_parts.append("WHERE " + " ".join(where_parts))
 
         return " ".join(query_parts), params
 
     def _build_delete(self) -> Tuple[str, List[Any]]:
         """Build DELETE query."""
         query_parts = [f"DELETE FROM {self.table}"]
         params: List[Any] = []
 
         if self.conditions:
             where_parts: List[str] = []
 
EOF
)
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/endpoints/api_middleware.py b/streamlit_extension/endpoints/api_middleware.py
index e58a8f0da84c80d49a838e1658ff6619b8e59aeb..2a3cc3fe530b6c3643ee695b5a0bedd76de10a0a 100644
--- a/streamlit_extension/endpoints/api_middleware.py
+++ b/streamlit_extension/endpoints/api_middleware.py
@@ -1,142 +1,151 @@
 #!/usr/bin/env python3
 """
 üõ°Ô∏è ENDPOINTS - API Middleware
 
 Middleware for API authentication, rate limiting, and CORS handling.
 Integrates with existing Streamlit authentication and rate limiting systems.
 
 Features:
 - ‚úÖ API key authentication (optional, falls back to session auth)
 - ‚úÖ Rate limiting with different limits for API vs UI
 - ‚úÖ CORS headers for external API consumers
 - ‚úÖ Request logging and monitoring
 - ‚úÖ Error standardization
 """
 
 import logging
 import time
 from typing import Dict, Any, Optional, Tuple
-from datetime import datetime, timedelta
+from datetime import datetime
 import hashlib
-import hmac
 
 from ..auth.middleware import is_authenticated, get_current_user
 from ..utils.security import check_rate_limit
 
 logger = logging.getLogger(__name__)
 
 class APIAuthenticationError(Exception):
     """Exception for API authentication failures"""
     pass
 
 class APIRateLimitError(Exception):
     """Exception for API rate limit exceeded"""
     pass
 
 def verify_api_key(api_key: str) -> Tuple[bool, Optional[str]]:
     """
     Verify API key if provided.
     
     Args:
         api_key: API key to verify
         
     Returns:
         Tuple of (is_valid, user_id)
     """
     if not api_key:
         return False, None
     
     # For demo purposes, accept a simple API key format
     # In production, this would check against a database of API keys
     if api_key.startswith("tdd_api_"):
         # Extract user identifier from API key
         try:
             # Simple validation - in production use proper key validation
             key_parts = api_key.split("_")
             if len(key_parts) >= 3:
                 user_id = key_parts[2]
                 return True, user_id
         except Exception as e:
             logger.warning(f"API key validation error: {e}")
     
     return False, None
 
 def check_api_rate_limit(request_type: str = "api_request", user_id: Optional[str] = None) -> Tuple[bool, Optional[str]]:
     """
     Check rate limits for API requests with specific limits.
-    
-    Args:
-        request_type: Type of request (api_request, api_heavy, etc.)
-        user_id: User ID for rate limiting (optional)
-        
-    Returns:
-        Tuple of (allowed, error_message)
+    Enforces a lightweight in-memory limiter keyed by (user_id, request_type).
+    Falls back to global limiter from utils.security.
     """
-    # Use more restrictive rate limits for API calls
+    # stricter defaults for API
     api_rate_configs = {
-        "api_request": {"requests": 100, "window": 3600},  # 100 per hour
-        "api_heavy": {"requests": 10, "window": 600},      # 10 per 10 minutes
-        "api_execution": {"requests": 20, "window": 3600}  # 20 execution plans per hour
+        "api_request":   {"requests": 100, "window": 3600},   # 100/h
+        "api_heavy":     {"requests": 10,  "window": 600},    # 10/10min
+        "api_execution": {"requests": 20,  "window": 3600},   # 20/h
     }
-    
-    # For now, use the existing rate limiting system
-    # TODO: Implement API-specific rate limiting with user-based limits
-    return check_rate_limit(request_type)
+    cfg = api_rate_configs.get(request_type, api_rate_configs["api_request"])
+    key_user = user_id or "anon"
+    bucket_key = f"{key_user}:{request_type}"
+    now = int(time.time())
+    window = cfg["window"]
+    window_start = now - window
+    # prune and count
+    events = _rate_limit_cache.get(bucket_key, [])
+    events = [t for t in events if t >= window_start]
+    if len(events) >= cfg["requests"]:
+        retry_in = max(0, window - (now - events[0]))
+        return False, f"{request_type} limit reached. retry_in={retry_in}s"
+    events.append(now)
+    _rate_limit_cache[bucket_key] = events
+    # also respect shared/global limiter if present
+    shared_ok, shared_err = check_rate_limit(request_type)
+    if not shared_ok:
+        return False, shared_err
+    return True, None
 
 def add_cors_headers() -> Dict[str, str]:
     """
     Add CORS headers for API responses.
     
     Returns:
         Dict of CORS headers
     """
     return {
-        "Access-Control-Allow-Origin": "*",  # In production, be more restrictive
+        "Access-Control-Allow-Origin": "*",  # TODO: restringir via ENV em produ√ß√£o
         "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
         "Access-Control-Allow-Headers": "Content-Type, Authorization, X-API-Key",
         "Access-Control-Max-Age": "86400"
     }
 
 def authenticate_api_request(query_params: Dict[str, str]) -> Tuple[bool, Optional[str], Optional[str]]:
     """
     Authenticate API request using multiple methods.
     
     Args:
         query_params: Query parameters from request
         
     Returns:
         Tuple of (is_authenticated, user_id, auth_method)
     """
     # Method 1: API Key authentication
     api_key = query_params.get("api_key")
     if api_key:
         is_valid, user_id = verify_api_key(api_key)
         if is_valid:
             return True, user_id, "api_key"
         else:
-            logger.warning(f"Invalid API key attempted: {api_key[:10]}...")
+            logger.warning("Invalid API key attempted")
     
     # Method 2: Session-based authentication (Streamlit session)
     if is_authenticated():
         current_user = get_current_user()
         user_id = current_user.username if current_user else "anonymous"
         return True, user_id, "session"
     
     # No valid authentication found
     return False, None, None
 
 def validate_api_request(query_params: Dict[str, str]) -> Dict[str, Any]:
     """
     Comprehensive API request validation.
     
     Args:
         query_params: Query parameters from request
         
     Returns:
         Dict with validation results and user info
     """
     validation_result = {
         "success": False,
         "user_id": None,
         "auth_method": None,
         "rate_limit_ok": False,
@@ -286,46 +295,46 @@ def create_api_success_response(data: Any, metadata: Optional[Dict[str, Any]] =
         "success": True,
         "data": data,
         "timestamp": datetime.now().isoformat()
     }
     
     if metadata:
         response["metadata"] = metadata
     
     return response
 
 # Example API key generation for development/testing
 def generate_dev_api_key(user_id: str) -> str:
     """
     Generate development API key.
     
     Args:
         user_id: User identifier
         
     Returns:
         Development API key
     """
     timestamp = str(int(time.time()))
     key_data = f"{user_id}_{timestamp}"
     return f"tdd_api_{user_id}_{hashlib.md5(key_data.encode()).hexdigest()[:8]}"
 
-# Rate limiting cache (in-memory for demo - use Redis in production)
-_rate_limit_cache = {}
+# Rate limiting cache (in-memory; use Redis em produ√ß√£o)
+_rate_limit_cache: Dict[str, list] = {}
 
 def reset_rate_limits():
     """Reset rate limiting cache - for testing purposes."""
     global _rate_limit_cache
     _rate_limit_cache.clear()
 
 # Export functions
 __all__ = [
     "authenticate_api_request",
     "validate_api_request", 
     "check_api_rate_limit",
     "add_cors_headers",
     "log_api_request",
     "create_api_error_response",
     "create_api_success_response",
     "generate_dev_api_key",
     "APIAuthenticationError",
     "APIRateLimitError"
-]
\ No newline at end of file
+]
 
EOF
)
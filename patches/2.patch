 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/utils/__init__.py b/streamlit_extension/utils/__init__.py
index 65f64f488f03a40d23bbdf2868e06862d68f862e..15d7ada9f601cf4a520369d277ed1cf876de51d7 100644
--- a/streamlit_extension/utils/__init__.py
+++ b/streamlit_extension/utils/__init__.py
@@ -1,15 +1,18 @@
 """Utility functions for Streamlit extension."""
 
 from .database import DatabaseManager
 from .validators import validate_config
 from .load_tester import LoadTester
 from .metrics_collector import MetricsCollector
 from .performance_monitor import PerformanceMonitor
 
 __all__ = [
     "DatabaseManager",
     "validate_config",
     "LoadTester",
     "MetricsCollector",
     "PerformanceMonitor",
-]
\ No newline at end of file
+]
+
+# Guarda de import opcional para ambientes de teste sem todos os módulos
+# (evita ImportError imediato ao importar o pacote).
\ No newline at end of file
diff --git a/streamlit_extension/utils/auth_manager.py b/streamlit_extension/utils/auth_manager.py
index 8c19ab8597da7e88ab8a7a3543ed9f4fecbfad00..f319ec671ad6c4062fe9d833d051c59cf52abf69 100644
--- a/streamlit_extension/utils/auth_manager.py
+++ b/streamlit_extension/utils/auth_manager.py
@@ -1,44 +1,44 @@
 """
 Enterprise authentication and authorization system for Streamlit.
 
 Implements secure authentication, session management, and CSRF protection
 to resolve critical P0 security gaps identified in report.md.
 """
 
 from __future__ import annotations
 
 import hashlib
 import hmac
 import secrets
 import time
 import uuid
 from dataclasses import dataclass
 from datetime import datetime, timedelta
 from typing import Any, Dict, List, Optional, Set
 import streamlit as st
-import jwt
+# NOTE: jwt import removido (não utilizado)
 
 
 @dataclass
 class User:
     """User model with role-based permissions."""
     
     id: str
     username: str
     email: str
     roles: List[str]
     permissions: Set[str]
     created_at: datetime
     last_login: Optional[datetime] = None
     is_active: bool = True
     password_hash: Optional[str] = None
     
     def has_permission(self, permission: str) -> bool:
         """Check if user has specific permission."""
         return permission in self.permissions
     
     def has_role(self, role: str) -> bool:
         """Check if user has specific role."""
         return role in self.roles
 
 
@@ -93,65 +93,67 @@ class CSRFProtection:
             # Verify session ID matches
             if token_session != session_id:
                 return False
             
             # Verify timestamp (not too old)
             token_time = int(timestamp)
             if time.time() - token_time > max_age:
                 return False
             
             # Verify signature
             data = f"{token_session}:{timestamp}"
             expected_signature = hmac.new(
                 self.secret_key,
                 data.encode(),
                 hashlib.sha256
             ).hexdigest()
             
             return hmac.compare_digest(signature, expected_signature)
             
         except (ValueError, TypeError):
             return False
 
 
 class PasswordManager:
     """Secure password hashing and validation."""
-    
+    # Permite configurar custo via secrets (fallback seguro)
+    _DEFAULT_ITERS = 200_000
+
     @staticmethod
     def hash_password(password: str, salt: Optional[str] = None) -> tuple[str, str]:
         """Hash password with salt."""
         if salt is None:
             salt = secrets.token_hex(32)
-        
-        # Use PBKDF2 with high iteration count
+
+        iterations = int(st.secrets.get("auth_pbkdf2_iters", PasswordManager._DEFAULT_ITERS))
         password_hash = hashlib.pbkdf2_hmac(
             'sha256',
             password.encode(),
             salt.encode(),
-            100000  # iterations
+            iterations
         ).hex()
-        
+
         return password_hash, salt
     
     @staticmethod
     def verify_password(password: str, stored_hash: str, salt: str) -> bool:
         """Verify password against stored hash."""
         computed_hash, _ = PasswordManager.hash_password(password, salt)
         return hmac.compare_digest(stored_hash, computed_hash)
 
 
 class AuthenticationManager:
     """Main authentication manager for Streamlit applications."""
     
     def __init__(self, secret_key: str, session_timeout_hours: int = 24):
         self.secret_key = secret_key
         self.session_timeout_hours = session_timeout_hours
         self.csrf_protection = CSRFProtection(secret_key)
         self.password_manager = PasswordManager()
         
         # Initialize session state
         if 'auth_manager' not in st.session_state:
             st.session_state.auth_manager = {
                 'sessions': {},
                 'users': {},
                 'current_session': None
             }
@@ -238,52 +240,60 @@ class AuthenticationManager:
         """Get currently authenticated user."""
         session = self.get_current_session()
         if not session:
             return None
         
         return st.session_state.auth_manager['users'].get(session.user_id)
     
     def get_current_session(self) -> Optional[Session]:
         """Get current valid session."""
         current_session_id = st.session_state.auth_manager.get('current_session')
         if not current_session_id:
             return None
         
         session = st.session_state.auth_manager['sessions'].get(current_session_id)
         if not session or session.is_expired() or not session.is_valid:
             self.logout()
             return None
         
         return session
     
     def validate_csrf_token(self, token: str) -> bool:
         """Validate CSRF token for current session."""
         session = self.get_current_session()
         if not session:
             return False
-        
+
         return self.csrf_protection.validate_token(token, session.session_id)
+
+    def rotate_csrf(self) -> Optional[str]:
+        """Gera e instala novo CSRF token para a sessão atual (defesa contra replay)."""
+        session = self.get_current_session()
+        if not session:
+            return None
+        session.csrf_token = self.csrf_protection.generate_token(session.session_id)
+        return session.csrf_token
     
     def logout(self) -> None:
         """Logout current user and invalidate session."""
         current_session_id = st.session_state.auth_manager.get('current_session')
         if current_session_id:
             session = st.session_state.auth_manager['sessions'].get(current_session_id)
             if session:
                 session.is_valid = False
             
             st.session_state.auth_manager['current_session'] = None
     
     def require_authentication(self) -> User:
         """Decorator/helper to require authentication for pages."""
         user = self.get_current_user()
         if not user:
             st.error("🔒 Authentication required. Please log in.")
             st.stop()
         return user
     
     def require_permission(self, permission: str) -> User:
         """Decorator/helper to require specific permission."""
         user = self.require_authentication()
         if not user.has_permission(permission):
             st.error(f"🚫 Access denied. Required permission: {permission}")
             st.stop()
@@ -332,53 +342,55 @@ class AuthenticationManager:
 
 def login_form() -> Optional[Session]:
     """Render login form and handle authentication."""
     st.subheader("🔐 Login")
     
     with st.form("login_form"):
         username = st.text_input("Username")
         password = st.text_input("Password", type="password")
         submitted = st.form_submit_button("Login")
         
         if submitted:
             if not username or not password:
                 st.error("Please provide both username and password")
                 return None
             
             auth_manager = AuthenticationManager(
                 secret_key=st.secrets.get("auth_secret_key", "dev-secret-key")
             )
             
             session = auth_manager.authenticate_user(
                 username=username,
                 password=password,
                 ip_address=st.session_state.get('client_ip', 'unknown'),
                 user_agent=st.session_state.get('user_agent', 'unknown')
             )
-            
+
             if session:
                 st.success("✅ Login successful!")
+                # Rotaciona CSRF após login
+                AuthenticationManager(st.secrets.get("auth_secret_key", "dev-secret-key")).rotate_csrf()
                 st.rerun()
                 return session
             else:
                 st.error("❌ Invalid credentials")
                 return None
     
     return None
 
 
 def init_default_admin():
     """Initialize default admin user for first setup."""
     auth_manager = AuthenticationManager(
         secret_key=st.secrets.get("auth_secret_key", "dev-secret-key")
     )
     
     # Check if admin exists
     existing_admin = None
     for user in st.session_state.auth_manager['users'].values():
         if 'admin' in user.roles:
             existing_admin = user
             break
     
     if not existing_admin:
         admin_user = auth_manager.create_user(
             username="admin",
@@ -409,26 +421,26 @@ def permission_required(permission: str):
                 secret_key=st.secrets.get("auth_secret_key", "dev-secret-key")
             )
             user = auth_manager.require_permission(permission)
             return func(user, *args, **kwargs)
         return wrapper
     return decorator
 
 
 def csrf_protected(func):
     """Decorator to add CSRF protection to form submissions."""
     def wrapper(*args, **kwargs):
         auth_manager = AuthenticationManager(
             secret_key=st.secrets.get("auth_secret_key", "dev-secret-key")
         )
         
         session = auth_manager.get_current_session()
         if not session:
             st.error("🔒 Session expired. Please log in again.")
             st.stop()
         
         # Add CSRF token to form
         if 'csrf_token' not in st.session_state:
             st.session_state.csrf_token = session.csrf_token
         
         return func(*args, **kwargs)
-    return wrapper
\ No newline at end of file
+    return wrapper
diff --git a/streamlit_extension/utils/constants.py b/streamlit_extension/utils/constants.py
index f3c0e7a1dba0ff300477162d81e591b135b77248..1abf135e6d6423b3cc2f0f76d12cb7222d9bbebd 100644
--- a/streamlit_extension/utils/constants.py
+++ b/streamlit_extension/utils/constants.py
@@ -1,27 +1,29 @@
+from __future__ import annotations
+
 from enum import Enum, IntEnum
-from typing import Final
+from typing import Final, List
 
 class TableNames:
     """Database table names."""
     CLIENTS: Final[str] = "framework_clients"
     PROJECTS: Final[str] = "framework_projects"
     EPICS: Final[str] = "framework_epics"
     TASKS: Final[str] = "framework_tasks"
     USERS: Final[str] = "framework_users"
     WORK_SESSIONS: Final[str] = "work_sessions"
     ACHIEVEMENTS: Final[str] = "user_achievements"
     STREAKS: Final[str] = "user_streaks"
 
 
 class FieldNames:
     """Common database field names."""
     ID: Final[str] = "id"
     NAME: Final[str] = "name"
     EMAIL: Final[str] = "email"
     STATUS: Final[str] = "status"
     CREATED_AT: Final[str] = "created_at"
     UPDATED_AT: Final[str] = "updated_at"
     CLIENT_ID: Final[str] = "client_id"
     PROJECT_ID: Final[str] = "project_id"
     EPIC_ID: Final[str] = "epic_id"
 
@@ -93,25 +95,33 @@ class UIConstants:
     MAX_PAGE_SIZE: Final[int] = 100
     DEFAULT_SEARCH_PLACEHOLDER: Final[str] = "Digite para buscar..."
     EMPTY_STATE_MESSAGE: Final[str] = "Nenhum registro encontrado"
     LOADING_MESSAGE: Final[str] = "Carregando..."
     SUCCESS_MESSAGE: Final[str] = "Operação realizada com sucesso!"
     ERROR_MESSAGE: Final[str] = "Erro ao executar operação"
 
 
 class ValidationRules:
     """Validation constants."""
     MIN_PASSWORD_LENGTH: Final[int] = 8
     MAX_NAME_LENGTH: Final[int] = 100
     MAX_EMAIL_LENGTH: Final[int] = 255
     MAX_DESCRIPTION_LENGTH: Final[int] = 1000
     MIN_SEARCH_LENGTH: Final[int] = 2
 
 
 class TimeConstants:
     """Time-related constants."""
     SESSION_TIMEOUT_MINUTES: Final[int] = 30
     CACHE_TTL_SECONDS: Final[int] = 300
     DB_CONNECTION_TIMEOUT: Final[int] = 30
     POMODORO_MINUTES: Final[int] = 25
     SHORT_BREAK_MINUTES: Final[int] = 5
     LONG_BREAK_MINUTES: Final[int] = 15
+
+# Explicit re-exports para linting/type checkers
+__all__: List[str] = [
+    "TableNames", "FieldNames", "ClientStatus", "ProjectStatus", "TaskStatus",
+    "EpicStatus", "TDDPhase", "Priority", "Complexity", "UIConstants",
+    "ValidationRules", "TimeConstants",
+]
+
diff --git a/streamlit_extension/utils/enhanced_recovery.py b/streamlit_extension/utils/enhanced_recovery.py
index 82cfd204c9030367cb879b95b3d70fee4e32edc8..d88b725d2f2d82819d6e32423aa66108c5adb749 100644
--- a/streamlit_extension/utils/enhanced_recovery.py
+++ b/streamlit_extension/utils/enhanced_recovery.py
@@ -1,56 +1,64 @@
-"""Enhanced error recovery strategies."""
+"""Enhanced error recovery strategies.
+
+Fornece engine extensível para tentar recuperações automáticas e fallbacks.
+"""
 
 from __future__ import annotations
 
 import time
 from abc import ABC, abstractmethod
 from dataclasses import dataclass
-from typing import Any, List, Optional
+from typing import Any, List, Optional, Protocol
 
 from ..middleware.context_manager import UserContext
 
-
 # Custom exception types used in recovery strategies
 class OperationalError(Exception):
     """Simulate database operational error."""
 
 
 class AuthenticationError(Exception):
     """Simulate authentication error."""
 
 
 class ValidationError(Exception):
     """Simulate validation error."""
 
 
 @dataclass
 class RecoveryResult:
     success: bool
     result: Optional[Any] = None
     fallback: Optional[Any] = None
 
+    def unwrap_or(self, default: Any) -> Any:
+        """Retorna result se sucesso, senão fallback ou default."""
+        if self.success:
+            return self.result
+        return self.fallback if self.fallback is not None else default
+
 
 class RecoveryStrategy(ABC):
     """Interface for recovery strategies."""
 
     @abstractmethod
     def can_recover(self, error: Exception, context: UserContext) -> bool:
         ...
 
     @abstractmethod
     def attempt_recovery(self, error: Exception, context: UserContext) -> RecoveryResult:
         ...
 
     @abstractmethod
     def get_fallback(self, error: Exception, context: UserContext) -> Any:
         ...
 
 
 class DatabaseRecoveryStrategy(RecoveryStrategy):
     def can_recover(self, error: Exception, context: UserContext) -> bool:
         return isinstance(error, OperationalError)
 
     def attempt_recovery(self, error: Exception, context: UserContext) -> RecoveryResult:
         if not self.can_recover(error, context):
             return RecoveryResult(False)
         time.sleep(0.01)  # Simulate retry delay
@@ -83,26 +91,26 @@ class ValidationRecoveryStrategy(RecoveryStrategy):
         if not self.can_recover(error, context):
             return RecoveryResult(False)
         return RecoveryResult(True, result="validated")
 
     def get_fallback(self, error: Exception, context: UserContext) -> Any:
         return "validation_fallback"
 
 
 class RecoveryEngine:
     """Engine that orchestrates multiple recovery strategies."""
 
     def __init__(self, strategies: Optional[List[RecoveryStrategy]] = None) -> None:
         self.strategies = strategies or []
 
     def register_strategy(self, strategy: RecoveryStrategy) -> None:
         self.strategies.append(strategy)
 
     def attempt_recovery(self, error: Exception, context: UserContext) -> RecoveryResult:
         for strategy in self.strategies:
             if strategy.can_recover(error, context):
                 result = strategy.attempt_recovery(error, context)
                 if result.success:
                     return result
                 fallback = strategy.get_fallback(error, context)
                 return RecoveryResult(False, fallback=fallback)
-        return RecoveryResult(False)
\ No newline at end of file
+        return RecoveryResult(False)
diff --git a/streamlit_extension/utils/exception_handler.py b/streamlit_extension/utils/exception_handler.py
index 1ebe4cc5ce43f75464df9bf932c930c9962b9628..2d94c701569b23bfdd2d625e1c95155e5ea60612 100644
--- a/streamlit_extension/utils/exception_handler.py
+++ b/streamlit_extension/utils/exception_handler.py
@@ -694,85 +694,33 @@ def show_error_dashboard():
             import pandas as pd
             df = pd.DataFrame(categories_df)
             st.dataframe(df, use_container_width=True)
     
     # Recent errors
     if stats["recent_errors"]:
         st.subheader("Recent Errors")
         for error in stats["recent_errors"][-5:]:  # Show last 5
             severity_icon = {
                 ErrorSeverity.CRITICAL: "🚨",
                 ErrorSeverity.HIGH: "❌", 
                 ErrorSeverity.MEDIUM: "⚠️",
                 ErrorSeverity.LOW: "ℹ️"
             }.get(error["severity"], "❓")
             
             with st.expander(f"{severity_icon} {error['category']} - {error['error_id'][:8]}", expanded=False):
                 st.text(f"Time: {error['timestamp']}")
                 st.text(f"Message: {error['message']}")
                 st.text(f"Severity: {error['severity']}")
     
     # Reset button
     if st.button("🔄 Reset Error Statistics"):
         reset_error_statistics()
         st.success("Error statistics reset successfully")
         st.rerun()
+__all__ = [
+    "ErrorSeverity", "ErrorCategory", "StreamlitError", "GlobalExceptionHandler",
+    "handle_streamlit_exceptions", "streamlit_error_boundary",
+    "safe_streamlit_operation", "handle_error", "install_global_exception_handler",
+    "get_error_statistics", "reset_error_statistics", "show_error_dashboard",
+    "global_exception_handler",
+]
 
-
-@contextmanager
-def streamlit_error_boundary(operation_name: str = "operation"):
-    """
-    Context manager for error boundary around Streamlit operations.
-    
-    Args:
-        operation_name: Name of the operation for logging
-    """
-    try:
-        yield
-    except Exception as e:
-        context = {
-            "operation": operation_name,
-            "timestamp": datetime.now().isoformat()
-        }
-        
-        global_exception_handler.handle_exception(
-            e, context=context,
-            show_user_message=True,
-            attempt_recovery=True
-        )
-
-
-def safe_streamlit_operation(func: Callable, 
-                           *args, 
-                           default_return: Any = None,
-                           operation_name: Optional[str] = None,
-                           **kwargs) -> Any:
-    """
-    Safely execute a Streamlit operation with error handling.
-    
-    Args:
-        func: Function to execute
-        *args: Arguments for the function
-        default_return: Default return value on error
-        operation_name: Name of operation for logging
-        **kwargs: Keyword arguments for the function
-        
-    Returns:
-        Function result or default_return on error
-    """
-    try:
-        return func(*args, **kwargs)
-    except Exception as e:
-        context = {
-            "function": func.__name__ if hasattr(func, '__name__') else str(func),
-            "operation": operation_name or "safe_operation",
-            "args_count": len(args),
-            "kwargs_keys": list(kwargs.keys()) if kwargs else []
-        }
-        
-        global_exception_handler.handle_exception(
-            e, context=context,
-            show_user_message=True,
-            attempt_recovery=True
-        )
-        
-        return default_return
diff --git a/streamlit_extension/utils/form_validation.py b/streamlit_extension/utils/form_validation.py
index e41213447407621afa1f36893b184002e7e3eda3..1e0a95ab38ef71218a4dcea374b6deba5421c4c9 100644
--- a/streamlit_extension/utils/form_validation.py
+++ b/streamlit_extension/utils/form_validation.py
@@ -1,82 +1,98 @@
-"""
-🔍 Form Validation Module
+"""🔍 Form Validation Module
 
-Centralized validation functions for form components:
-- Required field validation
-- Business rules validation
-- Format validation (email, phone)
-- Input sanitization
+Centraliza validações de formulários:
+- Campos obrigatórios
+- Regras de negócio
+- Formatos (email, telefone)
+- Sanitização de entradas
 """
 
+from __future__ import annotations
+
 import re
-from typing import Dict, List, Optional, Any
+from typing import Any, Dict, Iterable, List, Optional
 
 try:
     from .security import sanitize_input, validate_form
 except ImportError:  # pragma: no cover
     sanitize_input = lambda x, field_name="input": x  # type: ignore
     validate_form = None
 
+EMAIL_RE = re.compile(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
+PHONE_RE = re.compile(r"^[+\d][\d\s().-]{7,}$")
+
+__all__ = [
+    "validate_required_fields", "validate_email_format", "validate_phone_format",
+    "validate_text_length", "validate_business_rules_client",
+    "validate_business_rules_project", "sanitize_form_inputs",
+]
 
-def validate_required_fields(data: Dict, required_fields: List[str]) -> List[str]:
-    """Validate that required fields are present and non-empty."""
-    errors = []
+
+def validate_required_fields(data: Dict[str, Any], required_fields: Iterable[str]) -> List[str]:
+    """Valida se campos obrigatórios existem e não são vazios/whitespace."""
+    errors: List[str] = []
     for field in required_fields:
-        if not data.get(field):
+        value = data.get(field)
+        if value is None:
+            errors.append(f"Missing required field: {field}")
+        elif isinstance(value, str) and value.strip() == "":
             errors.append(f"Missing required field: {field}")
     return errors
 
 
 def validate_email_format(email: str) -> bool:
-    """Validate email format using regex pattern."""
-    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
-    return bool(re.match(pattern, email or ""))
+    """Valida formato de email (regex pré-compilado e fullmatch)."""
+    if not email:
+        return False
+    return EMAIL_RE.fullmatch(email) is not None
 
 
 def validate_phone_format(phone: str) -> bool:
-    """Validate phone number format (international compatible)."""
-    pattern = r"^[+\d][\d\s().-]{7,}$"
-    return bool(re.match(pattern, phone or ""))
+    """Valida telefone (compatível internacional)."""
+    if not phone:
+        return False
+    return PHONE_RE.fullmatch(phone) is not None
 
 
 def validate_text_length(text: str, min_len: int, max_len: int, field_name: str) -> List[str]:
     """Validate text length constraints."""
-    errors = []
+    errors: List[str] = []
     text = text or ""
     if len(text) < min_len:
         errors.append(f"{field_name} must be at least {min_len} characters")
     if len(text) > max_len:
         errors.append(f"{field_name} must be at most {max_len} characters")
     return errors
 
 
-def validate_business_rules_client(data: Dict) -> List[str]:
+def validate_business_rules_client(data: Dict[str, Any]) -> List[str]:
     """Validate business rules specific to client entities."""
     errors: List[str] = []
     errors.extend(validate_text_length(data.get("client_key", ""), 2, 50, "client_key"))
     errors.extend(validate_text_length(data.get("name", ""), 1, 255, "name"))
     return errors
 
 
-def validate_business_rules_project(data: Dict) -> List[str]:
+def validate_business_rules_project(data: Dict[str, Any]) -> List[str]:
     """Validate business rules specific to project entities."""
     errors: List[str] = []
     errors.extend(validate_text_length(data.get("project_key", ""), 2, 50, "project_key"))
     errors.extend(validate_text_length(data.get("name", ""), 1, 255, "name"))
     return errors
 
 
-def sanitize_form_inputs(data: Dict) -> Dict:
-    """Sanitize all form inputs for security."""
+def sanitize_form_inputs(data: Dict[str, Any]) -> Dict[str, Any]:
+    """Sanitiza todas as entradas string; preserva None e tipos primitivos.
+
+    Observação: `validate_form` (se existir) roda após sanitização.
+    """
     sanitized: Dict[str, Any] = {}
     for key, value in data.items():
         if isinstance(value, str):
             sanitized[key] = sanitize_input(value, key)
         else:
             sanitized[key] = value
-    
-    # Apply additional form validation if available
+
     if validate_form:
-        validate_form(sanitized)
-    
-    return sanitized
\ No newline at end of file
+        validate_form(sanitized)  # type: ignore[misc]
+    return sanitized
diff --git a/streamlit_extension/utils/load_tester.py b/streamlit_extension/utils/load_tester.py
index c301326a367ad35a00b5fb0b2167c33fd0f5a4ea..7695bb094fe95861b4327b39d3fe256c03d5152f 100644
--- a/streamlit_extension/utils/load_tester.py
+++ b/streamlit_extension/utils/load_tester.py
@@ -1,53 +1,66 @@
 from __future__ import annotations
 
 """Minimal load testing engine used by the automated tests.
 
 The implementation focuses on deterministic behaviour and low resource
 usage rather than absolute performance. It supports spawning a number of
 virtual users that execute a set of actions for a given duration while
 collecting metrics and basic system statistics.
 """
 
 import threading
 import time
 from concurrent.futures import ThreadPoolExecutor
-from typing import Callable, Iterable, List
+from typing import Callable, Iterable, List, Optional
 
 from .metrics_collector import MetricsCollector
 from .performance_monitor import PerformanceMonitor
 
 
 class LoadTester:
     """Execute simple load test scenarios."""
 
-    def __init__(self, users: int, duration: float, actions: Iterable[Callable[[], None]]):
+    def __init__(self, users: int, duration: float, actions: Iterable[Callable[[], None]], on_error: Optional[Callable[[BaseException], None]] = None):
         self.users = users
         self.duration = duration
         self.actions: List[Callable[[], None]] = list(actions)
         self.metrics = MetricsCollector()
         self.monitor = PerformanceMonitor()
+        self._on_error = on_error
 
     def _user_loop(self, stop_time: float) -> None:
         while time.perf_counter() < stop_time:
             for action in self.actions:
                 start = time.perf_counter()
                 success = True
                 try:
                     action()
-                except Exception:
+                except Exception as exc:  # captura exceção para telemetria
                     success = False
+                    if self._on_error:
+                        try:
+                            self._on_error(exc)
+                        except Exception:
+                            pass
+                    self.metrics.record_exception(exc, (time.perf_counter() - start) * 1000)
+                    # Verifica tempo novamente para não ultrapassar duração
+                    if time.perf_counter() >= stop_time:
+                        break
+                    continue
                 elapsed = (time.perf_counter() - start) * 1000
                 self.metrics.record(elapsed, success)
+                if time.perf_counter() >= stop_time:
+                    break
 
     def run(self) -> dict:
         """Run the configured scenario and return collected metrics."""
 
         self.metrics.start()
         stop_time = time.perf_counter() + self.duration
         with ThreadPoolExecutor(max_workers=self.users) as executor:
             for _ in range(self.users):
                 executor.submit(self._user_loop, stop_time)
         self.metrics.end()
         summary = self.metrics.summary()
         summary["resources"] = self.monitor.sample()
         return summary
\ No newline at end of file
diff --git a/streamlit_extension/utils/metrics_collector.py b/streamlit_extension/utils/metrics_collector.py
index 88e9f2297068b487db0c3a20a50f15aa1e50e309..e82f9964c5c43b3fb8e64d852f5e72a2a5d0bb33 100644
--- a/streamlit_extension/utils/metrics_collector.py
+++ b/streamlit_extension/utils/metrics_collector.py
@@ -1,92 +1,104 @@
 from __future__ import annotations
 
 """Simple metrics collection utilities for load testing.
 
 This module provides a minimal `MetricsCollector` class that records
 response times and error counts while a load test is running. It can
 calculate common statistics such as percentiles and throughput which are
 useful for basic performance analysis.
 """
 
 from dataclasses import dataclass, field
 import math
 import statistics
 import time
-from typing import Dict, List
+from typing import Dict, List, Optional
 
 
 def _percentile(values: List[float], percent: float) -> float:
     """Return the requested percentile from a list of values.
 
     This implementation avoids an optional numpy dependency while still
     providing deterministic results for small datasets used in tests.
     """
 
     if not values:
         return 0.0
     if not 0 <= percent <= 100:
         raise ValueError("percent must be in the range 0..100")
     sorted_vals = sorted(values)
     k = (len(sorted_vals) - 1) * (percent / 100)
     f = math.floor(k)
     c = math.ceil(k)
     if f == c:
         return sorted_vals[int(k)]
     d0 = sorted_vals[f] * (c - k)
     d1 = sorted_vals[c] * (k - f)
     return d0 + d1
 
 
 @dataclass
 class MetricsCollector:
     """Collect response time and error metrics during load tests."""
 
     response_times: List[float] = field(default_factory=list)
     errors: int = 0
     start_time: float | None = None
     end_time: float | None = None
+    _fail_examples: List[str] = field(default_factory=list)
 
     def start(self) -> None:
         """Record the start time of the measurement window."""
 
         self.start_time = time.perf_counter()
 
     def end(self) -> None:
         """Record the end time of the measurement window."""
 
         self.end_time = time.perf_counter()
 
     def record(self, elapsed_ms: float, success: bool = True) -> None:
         """Store a single operation's elapsed time and success flag."""
-
-        self.response_times.append(elapsed_ms)
+        if elapsed_ms < 0:
+            # Protege contra valores negativos por clock skew/erros
+            elapsed_ms = 0.0
+        self.response_times.append(float(elapsed_ms))
         if not success:
             self.errors += 1
 
+    def record_exception(self, exc: BaseException, elapsed_ms: float) -> None:
+        """Atalho para registrar falha com amostra do erro (limitado)."""
+        self.record(elapsed_ms, success=False)
+        if len(self._fail_examples) < 5:
+            self._fail_examples.append(type(exc).__name__)
+
     # summary returns dict with response_time, throughput, errors
     def summary(self) -> Dict[str, Dict[str, float]]:
         """Return a summary of all collected metrics."""
 
         rt_stats: Dict[str, float] = {}
         if self.response_times:
             rts = self.response_times
             rt_stats = {
                 "min": min(rts),
                 "max": max(rts),
                 "mean": statistics.mean(rts),
                 "median": statistics.median(rts),
                 "p95": _percentile(rts, 95),
                 "p99": _percentile(rts, 99),
             }
         duration = 0.0
         if self.start_time is not None and self.end_time is not None:
             duration = self.end_time - self.start_time
         throughput = len(self.response_times) / duration if duration > 0 else 0.0
         error_rate = (
             self.errors / len(self.response_times) if self.response_times else 0.0
         )
         return {
             "response_time": rt_stats,
             "throughput": {"requests_per_second": throughput},
-            "errors": {"total_errors": self.errors, "error_rate": error_rate},
+            "errors": {
+                "total_errors": self.errors,
+                "error_rate": error_rate,
+            },
         }
\ No newline at end of file
diff --git a/streamlit_extension/utils/performance_monitor.py b/streamlit_extension/utils/performance_monitor.py
index 7aa881654c72e85a54a895817908e748136c19e1..70d5e9f7570629e30701d08b19b10c3755205700 100644
--- a/streamlit_extension/utils/performance_monitor.py
+++ b/streamlit_extension/utils/performance_monitor.py
@@ -1,27 +1,27 @@
 """Lightweight system resource monitoring utilities.
 
 The real project might collect a wide range of metrics. For the purposes
 of the tests in this kata we only sample overall CPU and memory usage
 using `psutil`. These values are useful to ensure the load tests execute
 without exhausting local resources.
 """
 
 from __future__ import annotations
 
 import psutil
 from typing import Dict
 
 
 class PerformanceMonitor:
     """Capture simple system resource statistics."""
 
     def sample(self) -> Dict[str, float]:
         """Return a snapshot of current CPU and memory usage.
 
         The values are returned as percentages in the range 0-100.
         """
 
-        return {
-            "cpu_usage": psutil.cpu_percent(interval=0.0),
-            "memory_usage": psutil.virtual_memory().percent,
-        }
\ No newline at end of file
+        # interval=None usa o intervalo desde a última chamada sem bloquear.
+        cpu = psutil.cpu_percent(interval=None)
+        mem = psutil.virtual_memory().percent
+        return {"cpu_usage": float(cpu), "memory_usage": float(mem)}
\ No newline at end of file
diff --git a/streamlit_extension/utils/query_builder.py b/streamlit_extension/utils/query_builder.py
index 0cfca5c652d0a9c70c908ed57bf84cfe5fc2f73f..9b5445316930bab05d469d07340575e794c06a92 100644
--- a/streamlit_extension/utils/query_builder.py
+++ b/streamlit_extension/utils/query_builder.py
@@ -1,146 +1,180 @@
 """
 \U0001f527 SQL Query Builder - Type-Safe Database Operations
 
 Replaces ad-hoc SQL strings with structured query building:
 - Fluent interface for query construction
 - SQL injection prevention
 - Type safety
 - Query optimization
 - Debug logging
 - Performance metrics
 """
 
 from __future__ import annotations
 
 from typing import Any, Dict, Iterable, List, Sequence, Tuple
+import re
 
 
 class QueryBuilder:
     """Fluent interface SQL query builder."""
 
     def __init__(self, table_name: str) -> None:
         """Initialize query builder for specific table."""
         self.table = table_name
         self.query_type: str | None = None
         self.columns: List[str] = []
         self.conditions: List[str] = []
         self.joins: List[str] = []
         self._order_by: List[str] = []
         self._group_by: List[str] = []
         self._having: List[str] = []
         self.limit_value: int | None = None
         self.offset_value: int | None = None
         self.values: Dict[str, Any] = {}
         self.parameters: List[Any] = []
+        self._identifier_re = re.compile(r"^[A-Za-z_][A-Za-z0-9_\.]*$")
+
+    # ------------------------- helpers -------------------------
+    def _safe_ident(self, ident: str) -> str:
+        """Valida identificadores simples (tabela/coluna/direção)."""
+        if not self._identifier_re.fullmatch(ident):
+            raise ValueError(f"Unsafe SQL identifier: {ident!r}")
+        return ident
+
+    def _safe_direction(self, direction: str) -> str:
+        d = direction.upper()
+        if d not in {"ASC", "DESC"}:
+            raise ValueError("Order direction must be ASC or DESC")
+        return d
 
     # ------------------------------------------------------------------
     # Core query construction methods
     # ------------------------------------------------------------------
     def select(self, *columns: str) -> "QueryBuilder":
         """Add SELECT columns."""
         self.query_type = "SELECT"
-        self.columns.extend(columns)
+        if columns:
+            self.columns.extend(self._safe_ident(c) for c in columns)
+        else:
+            self.columns.clear()
         return self
 
     def where(self, condition: str, *params: Any) -> "QueryBuilder":
         """Add WHERE condition with parameters."""
         self.conditions.append(condition)
         self.parameters.extend(params)
         return self
 
     def join(self, table: str, on_condition: str) -> "QueryBuilder":
         """Add INNER JOIN."""
         self.joins.append(f"INNER JOIN {table} ON {on_condition}")
         return self
 
     def left_join(self, table: str, on_condition: str) -> "QueryBuilder":
         """Add LEFT JOIN."""
         self.joins.append(f"LEFT JOIN {table} ON {on_condition}")
         return self
 
     def group_by(self, *columns: str) -> "QueryBuilder":
         """Add GROUP BY clause."""
         self._group_by.extend(columns)
         return self
 
     def having(self, condition: str, *params: Any) -> "QueryBuilder":
         """Add HAVING clause."""
         self._having.append(condition)
         self.parameters.extend(params)
         return self
 
     def order_by(self, column: str, direction: str = "ASC") -> "QueryBuilder":
         """Add ORDER BY clause."""
-        self._order_by.append(f"{column} {direction}")
+        self._order_by.append(f"{self._safe_ident(column)} {self._safe_direction(direction)}")
         return self
 
     def limit(self, count: int) -> "QueryBuilder":
         """Add LIMIT clause."""
         self.limit_value = count
         return self
 
     def offset(self, count: int) -> "QueryBuilder":
         """Add OFFSET clause."""
         self.offset_value = count
         return self
 
     # ------------------------------------------------------------------
     # Data manipulation operations
     # ------------------------------------------------------------------
     def insert(self, **values: Any) -> "QueryBuilder":
         """Build INSERT query."""
         self.query_type = "INSERT"
         self.values = values
         return self
 
     def update(self, **values: Any) -> "QueryBuilder":
         """Build UPDATE query."""
         self.query_type = "UPDATE"
         self.values = values
         return self
 
     def delete(self) -> "QueryBuilder":
         """Build DELETE query."""
         self.query_type = "DELETE"
         return self
 
     # ------------------------------------------------------------------
     # Build helpers
     # ------------------------------------------------------------------
     def build(self) -> Tuple[str, Tuple[Any, ...]]:
         """Build final SQL query with parameters."""
         if self.query_type == "SELECT":
             return self._build_select()
         if self.query_type == "INSERT":
             return self._build_insert()
         if self.query_type == "UPDATE":
             return self._build_update()
         if self.query_type == "DELETE":
             return self._build_delete()
         raise ValueError("No query type specified")
 
+    # Estado mutável pode vazar entre builds; oferecemos reset explícito
+    def reset(self) -> "QueryBuilder":
+        """Limpa estado interno para construção de novo comando."""
+        self.query_type = None
+        self.columns.clear()
+        self.conditions.clear()
+        self.joins.clear()
+        self._order_by.clear()
+        self._group_by.clear()
+        self._having.clear()
+        self.limit_value = None
+        self.offset_value = None
+        self.values.clear()
+        self.parameters.clear()
+        return self
+
     # Internal builders -------------------------------------------------
     def _build_select(self) -> Tuple[str, Tuple[Any, ...]]:
         """Build SELECT query."""
         columns = ", ".join(self.columns) if self.columns else "*"
         query = f"SELECT {columns} FROM {self.table}"
 
         if self.joins:
             query += " " + " ".join(self.joins)
 
         if self.conditions:
             query += " WHERE " + " AND ".join(self.conditions)
 
         if self._group_by:
             query += " GROUP BY " + ", ".join(self._group_by)
 
         if self._having:
             query += " HAVING " + " AND ".join(self._having)
 
         if self._order_by:
             query += " ORDER BY " + ", ".join(self._order_by)
 
         if self.limit_value is not None:
             query += f" LIMIT {self.limit_value}"
 
         if self.offset_value is not None:
 
EOF
)
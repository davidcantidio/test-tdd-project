 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/pages/analytics.py b/streamlit_extension/pages/analytics.py
index 07451ca5d032897b137522d3a90c58718dddc755..80736925875c1f943f131399789e1662f0cecbd1 100644
--- a/streamlit_extension/pages/analytics.py
+++ b/streamlit_extension/pages/analytics.py
@@ -38,51 +38,51 @@ except ImportError:
 try:
     import pandas as pd
     PANDAS_AVAILABLE = True
 except ImportError:
     PANDAS_AVAILABLE = False
     pd = None
 
 # Local imports
 try:
     from streamlit_extension.utils.database import DatabaseManager
     from streamlit_extension.utils.security import (
         create_safe_client, sanitize_display, validate_form, check_rate_limit,
         security_manager
     )
     from streamlit_extension.utils.exception_handler import (
         handle_streamlit_exceptions, streamlit_error_boundary, safe_streamlit_operation
     )
     from streamlit_extension.config import load_config
     # Import authentication middleware
     from streamlit_extension.auth.middleware import init_protected_page
     DATABASE_UTILS_AVAILABLE = True
 except ImportError:
     DatabaseManager = load_config = None
     create_safe_client = sanitize_display = validate_form = None
     check_rate_limit = security_manager = None
-    init_protected_page = None
+    init_protected_page = handle_streamlit_exceptions = streamlit_error_boundary = safe_streamlit_operation = None
     DATABASE_UTILS_AVAILABLE = False
 
 try:
     from tdah_tools.analytics_engine import AnalyticsEngine, TDDAHAnalytics
     ANALYTICS_ENGINE_AVAILABLE = True
 except ImportError:
     AnalyticsEngine = TDDAHAnalytics = None
     ANALYTICS_ENGINE_AVAILABLE = False
 
 # Performance optimization imports
 try:
     import functools
     import hashlib
     PERFORMANCE_UTILS_AVAILABLE = True
 except ImportError:
     functools = hashlib = None
     PERFORMANCE_UTILS_AVAILABLE = False
 
 
 # Authentication middleware integration handled in imports above
 
 # Performance optimization functions
 class AnalyticsCache:
     """Simple in-memory cache for analytics data with TTL support."""
 
@@ -222,329 +222,278 @@ def optimize_database_queries(db_manager: DatabaseManager, days: int, filters: D
             if filters:
                 if filters.get("selected_epics"):
                     task_query_filters["epic_names"] = filters["selected_epics"]
 
                 if filters.get("selected_tdd_phases"):
                     task_query_filters["tdd_phases"] = filters["selected_tdd_phases"]
 
             query_results["tasks"] = db_manager.get_tasks()
             query_results["epics"] = db_manager.get_epics()
             query_results["user_stats"] = db_manager.get_user_stats()
 
         return query_results
 
     except Exception as e:
         st.error(f"Database query optimization failed: {e}")
         # Fallback to individual queries
         return {
             "timer_sessions": db_manager.get_timer_sessions(days),
             "tasks": db_manager.get_tasks(),
             "epics": db_manager.get_epics(),
             "user_stats": db_manager.get_user_stats()
         }
 
 
 @handle_streamlit_exceptions(show_error=True, attempt_recovery=True)
+
 def render_analytics_page():
-    """Render the analytics dashboard page."""
+    """Main analytics page with modular architecture."""
     if not STREAMLIT_AVAILABLE:
         return {"error": "Streamlit not available"}
-
-    # Initialize protected page with authentication
     current_user = init_protected_page("ðŸ“Š Analytics Dashboard")
     if not current_user:
         return {"error": "Authentication required"}
+    if not _check_rate_limit():
+        return {"error": "Rate limited"}
+    st.title("ðŸ“Š Analytics Dashboard")
+    st.markdown("---")
+    if not _check_dependencies():
+        return
+    db_manager, analytics_engine = _initialize_analytics_engine()
+    if not db_manager:
+        return
+    filters = _render_analytics_filters(db_manager)
+    analytics_data = _fetch_analytics_data(db_manager, analytics_engine, filters)
+    if not analytics_data:
+        st.warning("ðŸ“ No data available for the selected time range.")
+        return
+    _render_analytics_header(analytics_data)
+    _render_analytics_tabs(analytics_data)
+    _render_analytics_footer(analytics_data)
+
 
-    # Check rate limit for page load
+def _check_rate_limit() -> bool:
+    """Check rate limit for page load."""
     page_rate_allowed, page_rate_error = check_rate_limit("page_load") if check_rate_limit else (True, None)
     if not page_rate_allowed:
         st.error(f"ðŸš¦ {page_rate_error}")
         st.info("Please wait before reloading the page.")
-        return {"error": "Rate limited"}
+        return False
+    return True
 
-    st.title("ðŸ“Š Analytics Dashboard")
-    st.markdown("---")
 
-    # Check if required dependencies are available
+def _check_dependencies() -> bool:
+    """Verify required dependencies are available."""
     missing_deps = []
     if not PLOTLY_AVAILABLE:
         missing_deps.append("plotly")
     if not PANDAS_AVAILABLE:
         missing_deps.append("pandas")
     if not DATABASE_UTILS_AVAILABLE:
         missing_deps.append("database utilities")
-
     if missing_deps:
         st.error(f"âŒ Missing dependencies: {', '.join(missing_deps)}")
         st.info("Install with: `pip install plotly pandas`")
-        return
+        return False
+    return True
+
 
-    # Initialize database manager and analytics engine
+def _initialize_analytics_engine():
+    """Initialize analytics engine and database manager."""
     try:
         config = load_config()
         db_manager = DatabaseManager(
             framework_db_path=str(config.get_database_path()),
-            timer_db_path=str(config.get_timer_database_path())
+            timer_db_path=str(config.get_timer_database_path()),
         )
-
-        # Initialize analytics engine
         if ANALYTICS_ENGINE_AVAILABLE:
             analytics_engine = TDDAHAnalytics(db_path=str(config.get_timer_database_path()))
             st.sidebar.success("ðŸ§  Advanced analytics enabled")
         else:
             analytics_engine = None
             st.sidebar.warning("âš ï¸ Basic analytics mode (install pandas, plotly for full features)")
-
+        return db_manager, analytics_engine
     except Exception as e:
         st.error(f"âŒ Database connection error: {e}")
-        return
+        return None, None
+
+
+def _render_analytics_filters(db_manager: DatabaseManager) -> Dict[str, Any]:
+    """Render filter sidebar and return selected filters."""
+    days = _render_time_range_selector()
+    filters = _render_advanced_filters(db_manager, days)
+    _render_sidebar_utilities()
+    return filters
+
+
+def _fetch_analytics_data(db_manager: DatabaseManager, analytics_engine: Any, filters: Dict[str, Any]) -> Dict[str, Any]:
+    """Fetch and process analytics data based on filters."""
+    days = filters.get("days", 7)
+    with st.spinner("Loading analytics data..."):
+        if analytics_engine:
+            data = _get_enhanced_analytics_data(analytics_engine, db_manager, days)
+        else:
+            data = _get_analytics_data(db_manager, days)
+        if filters:
+            data = _apply_data_filters(data, filters)
+    st.session_state.last_analytics = data
+    return data
+
+
+def _render_analytics_header(analytics_data: Dict[str, Any]):
+    """Render analytics page header with key metrics."""
+    filters = getattr(st.session_state, "analytics_filters", {})
+    active_filters = []
+    if filters.get("selected_epics"):
+        active_filters.append(f"Epics: {len(filters['selected_epics'])}")
+    if filters.get("focus_range") and filters.get("focus_range") != (1, 10):
+        active_filters.append(f"Focus: {filters['focus_range'][0]}-{filters['focus_range'][1]}")
+    if filters.get("selected_tdd_phases"):
+        active_filters.append(f"TDD: {len(filters['selected_tdd_phases'])}")
+    if filters.get("selected_session_types"):
+        active_filters.append(f"Sessions: {len(filters['selected_session_types'])}")
+    if active_filters:
+        st.info(f"ðŸ” **Active filters:** {' | '.join(active_filters)}")
+    _render_overview_metrics(analytics_data)
+    st.markdown("---")
+
+
+def _render_analytics_tabs(analytics_data: Dict[str, Any]):
+    """Render tabbed interface for different analytics views."""
+    col1, col2 = st.columns(2)
+    with col1:
+        _render_productivity_chart(analytics_data)
+        _render_tdd_phase_distribution(analytics_data)
+    with col2:
+        _render_focus_time_chart(analytics_data)
+        _render_epic_progress_chart(analytics_data)
+    st.markdown("---")
+    _render_tdah_insights(analytics_data)
+    st.markdown("---")
+
+
+def _render_analytics_footer(analytics_data: Dict[str, Any]):
+    """Render analytics page footer with export options."""
+    _render_advanced_tdah_metrics(analytics_data)
+    with st.expander("ðŸ“‹ Detailed Data"):
+        _render_detailed_tables(analytics_data)
 
-    # Enhanced time range selector with interactivity
-    st.sidebar.markdown("## ðŸ“… Time Range")
 
-    # Quick time range options
+def _render_time_range_selector() -> int:
+    """Render time range selector and return number of days."""
+    st.sidebar.markdown("## ðŸ“… Time Range")
     time_options = {
         "Today": 1,
         "Last 3 days": 3,
         "Last 7 days": 7,
         "Last 14 days": 14,
         "Last 30 days": 30,
         "Last 90 days": 90,
         "Last 6 months": 180,
         "Last year": 365,
         "All time": 9999,
-        "Custom range": 0
+        "Custom range": 0,
     }
-
     selected_range = st.sidebar.selectbox("Select time range", list(time_options.keys()), index=2)
-
     if selected_range == "Custom range":
         col1, col2 = st.sidebar.columns(2)
         with col1:
             start_date = st.date_input("From", value=datetime.now() - timedelta(days=30))
         with col2:
             end_date = st.date_input("To", value=datetime.now())
-
-        # Calculate days difference
         days = (end_date - start_date).days + 1
         st.sidebar.caption(f"Period: {days} days")
     else:
         days = time_options[selected_range]
+        start_date = end_date = None
+    return days
 
-    # Advanced filters
-    st.sidebar.markdown("## ðŸ” Advanced Filters")
 
-    # Epic filter
-    show_epic_filter = st.sidebar.checkbox("Filter by Epic", value=False)
-    selected_epics = []
-    if show_epic_filter:
+def _render_advanced_filters(db_manager: DatabaseManager, days: int) -> Dict[str, Any]:
+    """Render advanced sidebar filters."""
+    st.sidebar.markdown("## ðŸ” Advanced Filters")
+    selected_epics: List[str] = []
+    if st.sidebar.checkbox("Filter by Epic", value=False):
         try:
-            config = load_config()
-            db_manager = DatabaseManager(
-                framework_db_path=str(config.get_database_path()),
-                timer_db_path=str(config.get_timer_database_path())
-            )
             all_epics = db_manager.get_epics()
             epic_names = [epic.get("name", "Unknown") for epic in all_epics]
             selected_epics = st.sidebar.multiselect("Select Epics", epic_names)
-        except:
+        except Exception:
             st.sidebar.warning("Could not load epics")
-
-    # Focus level filter
-    show_focus_filter = st.sidebar.checkbox("Filter by Focus Level", value=False)
     focus_range = (1, 10)
-    if show_focus_filter:
-        focus_range = st.sidebar.slider(
-            "Focus Rating Range", 
-            min_value=1, max_value=10, 
-            value=(1, 10), 
-            step=1
-        )
-
-    # TDD phase filter
-    show_tdd_filter = st.sidebar.checkbox("Filter by TDD Phase", value=False)
-    selected_tdd_phases = []
-    if show_tdd_filter:
+    if st.sidebar.checkbox("Filter by Focus Level", value=False):
+        focus_range = st.sidebar.slider("Focus Rating Range", min_value=1, max_value=10, value=(1, 10), step=1)
+    selected_tdd_phases: List[str] = []
+    if st.sidebar.checkbox("Filter by TDD Phase", value=False):
         tdd_phases = ["red", "green", "refactor"]
         selected_tdd_phases = st.sidebar.multiselect("Select TDD Phases", tdd_phases)
-
-    # Session type filter
-    show_session_filter = st.sidebar.checkbox("Filter by Session Type", value=False)
-    selected_session_types = []
-    if show_session_filter:
+    selected_session_types: List[str] = []
+    if st.sidebar.checkbox("Filter by Session Type", value=False):
         session_types = ["focus_session", "short_break", "long_break", "custom"]
         selected_session_types = st.sidebar.multiselect("Select Session Types", session_types)
-
-    # Store filters in session state for use across functions
-    st.session_state.analytics_filters = {
+    filters = {
         "days": days,
         "selected_epics": selected_epics,
         "focus_range": focus_range,
         "selected_tdd_phases": selected_tdd_phases,
         "selected_session_types": selected_session_types,
-        "custom_date_range": (start_date, end_date) if selected_range == "Custom range" else None
     }
+    st.session_state.analytics_filters = filters
+    return filters
 
-    # Interactive controls
-    st.sidebar.markdown("## âš¡ Interactive Controls")
 
-    # Auto-refresh option
-    auto_refresh = st.sidebar.checkbox("Auto-refresh (30s)", value=False)
+def _render_sidebar_utilities():
+    """Render sidebar utilities like refresh and export options."""
+    st.sidebar.markdown("## âš¡ Interactive Controls")
+    auto_refresh = st.sidebar.checkbox("Auto-refresh every minute", value=False)
     if auto_refresh:
-        st.sidebar.info("ðŸ“¡ Data refreshes automatically")
-        # Add auto-refresh functionality
-        if 'refresh_counter' not in st.session_state:
+        if "refresh_counter" not in st.session_state:
             st.session_state.refresh_counter = 0
-        st.session_state.refresh_counter += 1
-
-        # Show refresh indicator
-        st.sidebar.caption(f"Last refresh: {datetime.now().strftime('%H:%M:%S')}")
-
-        # Auto-refresh every 30 seconds
-        time.sleep(1)  # Small delay to prevent too frequent refreshes
-        st.rerun()
-
-    # Manual refresh button
+        if time.time() - st.session_state.get("last_refresh", 0) > 60:
+            st.session_state.last_refresh = time.time()
+            st.session_state.refresh_counter += 1
+            st.sidebar.caption(f"Last refresh: {datetime.now().strftime('%H:%M:%S')}")
+            time.sleep(1)
+            st.rerun()
     if st.sidebar.button("ðŸ”„ Refresh Data", type="primary"):
         st.rerun()
-
-    # Export controls
     st.sidebar.markdown("## ðŸ“Š Export Options")
-
-    export_format = st.sidebar.selectbox(
-        "Export Format",
-        ["CSV", "JSON", "Excel"],
-        help="Choose format for exporting analytics data"
-    )
-
+    export_format = st.sidebar.selectbox("Export Format", ["CSV", "JSON", "Excel"], help="Choose format for exporting analytics data")
     if st.sidebar.button("ðŸ“¥ Export Data"):
-        _export_analytics_data(analytics_data if 'analytics_data' in locals() else {}, export_format)
-
-    # Chart interaction settings
+        _export_analytics_data(getattr(st.session_state, 'last_analytics', {}), export_format)
     st.sidebar.markdown("## ðŸ“ˆ Chart Settings")
-
-    chart_theme = st.sidebar.selectbox(
-        "Chart Theme",
-        ["plotly", "plotly_white", "plotly_dark", "presentation"],
-        index=0,
-        help="Choose visual theme for charts"
-    )
-
+    chart_theme = st.sidebar.selectbox("Chart Theme", ["plotly", "plotly_white", "plotly_dark", "presentation"], index=0)
     show_animations = st.sidebar.checkbox("Chart Animations", value=True)
     show_tooltips = st.sidebar.checkbox("Enhanced Tooltips", value=True)
-
-    # Store chart settings
-    st.session_state.chart_settings = {
-        "theme": chart_theme,
-        "animations": show_animations,
-        "tooltips": show_tooltips
-    }
-
-    # Performance settings
+    st.session_state.chart_settings = {"theme": chart_theme, "animations": show_animations, "tooltips": show_tooltips}
     st.sidebar.markdown("## âš™ï¸ Performance")
-
     use_cache = st.sidebar.checkbox("Use Data Caching", value=True, help="Cache data for faster loading")
     chart_quality = st.sidebar.selectbox("Chart Quality", ["High", "Medium", "Fast"], index=1)
-
-    st.session_state.performance_settings = {
-        "use_cache": use_cache,
-        "chart_quality": chart_quality
-    }
-
-    # Performance monitoring display
+    st.session_state.performance_settings = {"use_cache": use_cache, "chart_quality": chart_quality}
     if st.sidebar.checkbox("Show Performance Metrics", value=False):
         _render_performance_metrics()
 
-    # Fetch data using analytics engine or fallback
-    with st.spinner("Loading analytics data..."):
-        if analytics_engine:
-            analytics_data = _get_enhanced_analytics_data(analytics_engine, db_manager, days)
-        else:
-            analytics_data = _get_analytics_data(db_manager, days)
-
-        # Apply filters if any are set
-        if hasattr(st.session_state, 'analytics_filters') and st.session_state.analytics_filters:
-            analytics_data = _apply_data_filters(analytics_data, st.session_state.analytics_filters)
-
-            # Show filter status
-            active_filters = []
-            filters = st.session_state.analytics_filters
-
-            if filters.get("selected_epics"):
-                active_filters.append(f"Epics: {len(filters['selected_epics'])}")
-            if filters.get("focus_range") != (1, 10):
-                active_filters.append(f"Focus: {filters['focus_range'][0]}-{filters['focus_range'][1]}")
-            if filters.get("selected_tdd_phases"):
-                active_filters.append(f"TDD: {len(filters['selected_tdd_phases'])}")
-            if filters.get("selected_session_types"):
-                active_filters.append(f"Sessions: {len(filters['selected_session_types'])}")
-
-            if active_filters:
-                st.info(f"ðŸ” **Active filters:** {' | '.join(active_filters)}")
-
-                # Add reset filters button
-                col1, col2 = st.columns([1, 4])
-                with col1:
-                    if st.button("ðŸ—‘ï¸ Clear Filters"):
-                        if hasattr(st.session_state, 'analytics_filters'):
-                            del st.session_state.analytics_filters
-                        st.rerun()
-
-    if not analytics_data:
-        st.warning("ðŸ“ No data available for the selected time range.")
-        return
-
-    # Overview metrics
-    _render_overview_metrics(analytics_data)
-
-    st.markdown("---")
-
-    # Charts in columns
-    col1, col2 = st.columns(2)
-
-    with col1:
-        _render_productivity_chart(analytics_data)
-        _render_tdd_phase_distribution(analytics_data)
-
-    with col2:
-        _render_focus_time_chart(analytics_data)
-        _render_epic_progress_chart(analytics_data)
-
-    st.markdown("---")
-
-    # TDAH-specific analytics
-    _render_tdah_insights(analytics_data)
-
-    st.markdown("---")
-
-    # Advanced TDAH metrics dashboard
-    _render_advanced_tdah_metrics(analytics_data)
-
-    # Detailed tables
-    with st.expander("ðŸ“‹ Detailed Data"):
-        _render_detailed_tables(analytics_data)
-
 
 @cached_analytics_data(ttl=300)  # Cache for 5 minutes
 @performance_monitor
 def _get_enhanced_analytics_data(analytics_engine: Any, db_manager: DatabaseManager, days: int) -> Dict[str, Any]:
     """Get enhanced analytics data using the analytics engine."""
 
     try:
         # Get productivity metrics from analytics engine
         productivity_metrics = analytics_engine.generate_productivity_metrics(days)
 
         # Get time patterns analysis
         time_patterns = analytics_engine.analyze_time_patterns(days)
 
         # Get session data
         session_data = analytics_engine.load_session_data(days)
 
         # Get basic database data for supplemental info
         basic_data = _get_analytics_data(db_manager, days)
 
         # Combine enhanced analytics with basic data
         enhanced_data = {
             **basic_data,
             "productivity_metrics": productivity_metrics,
             "time_patterns": time_patterns,
             "session_data": session_data,
@@ -705,551 +654,427 @@ def _render_overview_metrics(analytics_data: Dict[str, Any]):
 
         st.metric(
             "ðŸŽ¯ Avg Focus Rating",
             f"{focus_rating:.1f}/10",
             delta_text
         )
 
     with col4:
         if engine_enabled and productivity_metrics:
             # Enhanced points with streak info
             points = productivity_metrics.get("total_points", analytics_data.get("total_points", 0))
             streak = productivity_metrics.get("current_streak", 0)
             delta_text = f"ðŸ”¥ {streak} day streak" if streak > 1 else f"{analytics_data.get('active_epics', 0)} active epics"
         else:
             # Basic points
             points = analytics_data.get("total_points", 0)
             delta_text = f"{analytics_data.get('active_epics', 0)} active epics"
 
         st.metric(
             "ðŸŒŸ Total Points",
             f"{points:,}",
             delta_text
         )
 
 
+
 def _render_productivity_chart(analytics_data: Dict[str, Any]):
-    """Render enhanced productivity over time chart using analytics engine data."""
+    """Render productivity charts with modular data processing."""
     if not PLOTLY_AVAILABLE:
         st.warning("Charts require plotly installation")
         return
-
     st.markdown("### ðŸ“ˆ Daily Productivity")
+    chart_data = _process_productivity_data(analytics_data)
+    if chart_data.get("df") is None:
+        st.info("No productivity data available")
+        return
+    config = _get_productivity_chart_config()
+    _display_productivity_charts(chart_data, config)
+    _display_productivity_metrics(chart_data)
 
+def _process_productivity_data(analytics_data: Dict[str, Any]) -> Dict[str, Any]:
+    """Process raw analytics data for productivity visualization."""
     engine_enabled = analytics_data.get("analytics_engine_enabled", False)
     productivity_metrics = analytics_data.get("productivity_metrics", {})
-
     if engine_enabled and productivity_metrics:
-        # Use enhanced productivity data from analytics engine
         daily_productivity = productivity_metrics.get("daily_productivity", [])
-
         if not daily_productivity:
-            # Fallback to basic daily metrics
-            daily_metrics = analytics_data.get("daily_metrics", [])
-            daily_productivity = daily_metrics
-
+            daily_productivity = analytics_data.get("daily_metrics", [])
         if daily_productivity and PANDAS_AVAILABLE:
-            # Convert to DataFrame for easier manipulation
             df_data = []
             for day_data in daily_productivity:
                 df_data.append({
                     "date": day_data.get("date", ""),
                     "focus_minutes": day_data.get("focus_minutes", day_data.get("total_focus_time", 0)),
                     "tasks_completed": day_data.get("tasks_completed", 0),
                     "productivity_score": day_data.get("productivity_score", 0),
                     "focus_efficiency": day_data.get("focus_efficiency", 0),
-                    "avg_focus_rating": day_data.get("avg_focus_rating", 0)
+                    "avg_focus_rating": day_data.get("avg_focus_rating", 0),
                 })
-
-            df = pd.DataFrame(df_data)
-            df = df.sort_values("date")
-
-            # Create enhanced chart with productivity score
-            fig = make_subplots(
-                rows=2, cols=1,
-                subplot_titles=["Focus Time & Tasks Completed", "Productivity Score & Focus Efficiency"],
-                specs=[[{"secondary_y": True}], [{"secondary_y": True}]],
-                vertical_spacing=0.12
-            )
-
-            # Top chart: Focus time (bars) and tasks (line)
-            fig.add_trace(
-                go.Bar(
-                    x=df["date"],
-                    y=df["focus_minutes"],
-                    name="Focus Minutes",
-                    marker_color="lightblue",
-                    opacity=0.7
-                ),
-                row=1, col=1, secondary_y=False
-            )
-
-            fig.add_trace(
-                go.Scatter(
-                    x=df["date"],
-                    y=df["tasks_completed"],
-                    mode="lines+markers",
-                    name="Tasks Completed",
-                    line=dict(color="orange", width=2),
-                    marker=dict(size=6)
-                ),
-                row=1, col=1, secondary_y=True
-            )
-
-            # Bottom chart: Productivity metrics
-            fig.add_trace(
-                go.Scatter(
-                    x=df["date"],
-                    y=df["productivity_score"],
-                    mode="lines+markers",
-                    name="Productivity Score",
-                    line=dict(color="green", width=3),
-                    marker=dict(size=8)
-                ),
-                row=2, col=1, secondary_y=False
-            )
-
-            fig.add_trace(
-                go.Scatter(
-                    x=df["date"],
-                    y=df["focus_efficiency"],
-                    mode="lines+markers",
-                    name="Focus Efficiency %",
-                    line=dict(color="purple", width=2, dash="dash"),
-                    marker=dict(size=6)
-                ),
-                row=2, col=1, secondary_y=True
-            )
-
-            # Update axes
-            fig.update_xaxes(title_text="Date", row=2, col=1)
-            fig.update_yaxes(title_text="Focus Minutes", row=1, col=1, secondary_y=False)
-            fig.update_yaxes(title_text="Tasks Completed", row=1, col=1, secondary_y=True)
-            fig.update_yaxes(title_text="Productivity Score", row=2, col=1, secondary_y=False)
-            fig.update_yaxes(title_text="Focus Efficiency %", row=2, col=1, secondary_y=True)
-
-            fig.update_layout(
-                height=600,
-                showlegend=True,
-                title=None
-            )
-
-            st.plotly_chart(fig, use_container_width=True)
-
-            # Add insights if available
-            if productivity_metrics.get("insights"):
-                st.markdown("#### ðŸ’¡ Productivity Insights")
-                for insight in productivity_metrics["insights"][:3]:
-                    st.info(f"â€¢ {insight}")
-        else:
-            st.info("No productivity data available")
+            df = pd.DataFrame(df_data).sort_values("date")
+            return {"df": df, "insights": productivity_metrics.get("insights", []), "enhanced": True}
+        return {"df": None, "insights": [], "enhanced": True}
+    daily_metrics = analytics_data.get("daily_metrics", [])
+    if daily_metrics and PANDAS_AVAILABLE:
+        df = pd.DataFrame(sorted(daily_metrics, key=lambda x: x["date"]))
+        return {"df": df, "insights": [], "enhanced": False}
+    return {"df": None, "insights": [], "enhanced": False}
+
+def _get_productivity_chart_config() -> Dict[str, Any]:
+    """Get chart configuration for productivity visualizations."""
+    return {"enhanced_height": 600, "basic_height": 400}
+
+def _display_productivity_metrics(chart_data: Dict[str, Any]):
+    """Display key productivity metrics in cards."""
+    insights = chart_data.get("insights", [])
+    if insights:
+        st.markdown("#### ðŸ’¡ Productivity Insights")
+        for insight in insights[:3]:
+            st.info(f"â€¢ {insight}")
+
+def _display_productivity_charts(chart_data: Dict[str, Any], config: Dict[str, Any]):
+    """Display productivity charts with given configuration."""
+    df = chart_data.get("df")
+    if df is None:
+        return
+    if chart_data.get("enhanced"):
+        fig = make_subplots(
+            rows=2,
+            cols=1,
+            subplot_titles=["Focus Time & Tasks Completed", "Productivity Score & Focus Efficiency"],
+            specs=[[{"secondary_y": True}], [{"secondary_y": True}]],
+            vertical_spacing=0.12,
+        )
+        fig.add_trace(
+            go.Bar(x=df["date"], y=df["focus_minutes"], name="Focus Minutes", marker_color="lightblue", opacity=0.7),
+            row=1,
+            col=1,
+            secondary_y=False,
+        )
+        fig.add_trace(
+            go.Scatter(x=df["date"], y=df["tasks_completed"], mode="lines+markers", name="Tasks Completed", line=dict(color="orange", width=2), marker=dict(size=6)),
+            row=1,
+            col=1,
+            secondary_y=True,
+        )
+        fig.add_trace(
+            go.Scatter(x=df["date"], y=df["productivity_score"], mode="lines+markers", name="Productivity Score", line=dict(color="green", width=3), marker=dict(size=8)),
+            row=2,
+            col=1,
+            secondary_y=False,
+        )
+        fig.add_trace(
+            go.Scatter(x=df["date"], y=df["focus_efficiency"], mode="lines+markers", name="Focus Efficiency %", line=dict(color="purple", width=2, dash="dash"), marker=dict(size=6)),
+            row=2,
+            col=1,
+            secondary_y=True,
+        )
+        fig.update_xaxes(title_text="Date", row=2, col=1)
+        fig.update_yaxes(title_text="Focus Minutes", row=1, col=1, secondary_y=False)
+        fig.update_yaxes(title_text="Tasks Completed", row=1, col=1, secondary_y=True)
+        fig.update_yaxes(title_text="Productivity Score", row=2, col=1, secondary_y=False)
+        fig.update_yaxes(title_text="Focus Efficiency %", row=2, col=1, secondary_y=True)
+        fig.update_layout(height=config["enhanced_height"], showlegend=True, title=None)
+        st.plotly_chart(fig, use_container_width=True)
     else:
-        # Fallback to basic chart
-        daily_metrics = analytics_data.get("daily_metrics", [])
-        if not daily_metrics:
-            st.info("No daily data available")
-            return
-
-        # Sort by date
-        daily_metrics.sort(key=lambda x: x["date"])
-
-        if PANDAS_AVAILABLE:
-            df = pd.DataFrame(daily_metrics)
-
-            # Create basic subplot with secondary y-axis
-            fig = make_subplots(specs=[[{"secondary_y": True}]])
-
-            # Add focus time bar chart
-            fig.add_trace(
-                go.Bar(
-                    x=df["date"],
-                    y=df["focus_minutes"],
-                    name="Focus Minutes",
-                    marker_color="lightblue",
-                    opacity=0.7
-                ),
-                secondary_y=False
-            )
-
-            # Add tasks completed line
-            fig.add_trace(
-                go.Scatter(
-                    x=df["date"],
-                    y=df["tasks_completed"],
-                    mode="lines+markers",
-                    name="Tasks Completed",
-                    line=dict(color="orange", width=2),
-                    marker=dict(size=6)
-                ),
-                secondary_y=True
-            )
-
-            # Update axes
-            fig.update_xaxes(title_text="Date")
-            fig.update_yaxes(title_text="Focus Minutes", secondary_y=False)
-            fig.update_yaxes(title_text="Tasks Completed", secondary_y=True)
-
-            fig.update_layout(
-                height=400,
-                showlegend=True,
-                title=None
-            )
-
-            st.plotly_chart(fig, use_container_width=True)
-        else:
-            # Fallback display
-            st.json(daily_metrics[:5])  # Show first 5 days
-
+        fig = make_subplots(specs=[[{"secondary_y": True}]])
+        fig.add_trace(
+            go.Bar(x=df["date"], y=df["focus_minutes"], name="Focus Minutes", marker_color="lightblue", opacity=0.7),
+            secondary_y=False,
+        )
+        fig.add_trace(
+            go.Scatter(x=df["date"], y=df["tasks_completed"], mode="lines+markers", name="Tasks Completed", line=dict(color="orange", width=2), marker=dict(size=6)),
+            secondary_y=True,
+        )
+        fig.update_xaxes(title_text="Date")
+        fig.update_yaxes(title_text="Focus Minutes", secondary_y=False)
+        fig.update_yaxes(title_text="Tasks Completed", secondary_y=True)
+        fig.update_layout(height=config["basic_height"], showlegend=True, title=None)
+        st.plotly_chart(fig, use_container_width=True)
 
 def _render_focus_time_chart(analytics_data: Dict[str, Any]):
-    """Render enhanced focus time analysis using analytics engine time patterns."""
+    """Render focus time analysis charts."""
     if not PLOTLY_AVAILABLE:
         st.warning("Charts require plotly installation")
         return
-
     st.markdown("### â±ï¸ Focus Time Analysis")
+    focus_data = _aggregate_focus_time_data(analytics_data)
+    if not focus_data:
+        st.info("No timer sessions available")
+        return
+    _render_focus_trends(focus_data)
+    _render_focus_summary(focus_data)
+    _render_focus_patterns(focus_data)
 
+def _aggregate_focus_time_data(analytics_data: Dict[str, Any]) -> Dict[str, Any]:
+    """Aggregate and calculate focus time metrics."""
     engine_enabled = analytics_data.get("analytics_engine_enabled", False)
     time_patterns = analytics_data.get("time_patterns", {})
-
     if engine_enabled and time_patterns:
-        # Use enhanced time patterns from analytics engine
         hourly_focus = time_patterns.get("hourly_focus_distribution", {})
         peak_hours = time_patterns.get("peak_productivity_hours", [])
         focus_quality_by_hour = time_patterns.get("focus_quality_by_hour", {})
+        hours = list(range(24))
+        minutes = [hourly_focus.get(str(h), 0) for h in hours]
+        focus_quality = [focus_quality_by_hour.get(str(h), 0) for h in hours]
+        total_focus_time = sum(minutes)
+        avg_session_quality = sum(focus_quality) / len([q for q in focus_quality if q > 0]) if any(focus_quality) else 0
+        return {
+            "type": "enhanced",
+            "hours": hours,
+            "minutes": minutes,
+            "focus_quality": focus_quality,
+            "peak_hours": peak_hours,
+            "patterns": time_patterns.get("patterns", []),
+            "total_focus_time": total_focus_time,
+            "avg_session_quality": avg_session_quality,
+        }
+    # Fallback to basic hourly analysis
+    timer_sessions = analytics_data.get("timer_sessions", [])
+    if not timer_sessions:
+        return {}
+    from collections import defaultdict
+    hourly_data = defaultdict(int)
+    for session in timer_sessions:
+        if session.get("started_at"):
+            try:
+                if "T" in session["started_at"]:
+                    hour = int(session["started_at"].split("T")[1][:2])
+                else:
+                    hour = int(session["started_at"].split(" ")[1][:2])
+                hourly_data[hour] += session.get("planned_duration_minutes", 0)
+            except (ValueError, IndexError):
+                continue
+    hours = list(range(24))
+    minutes = [hourly_data.get(h, 0) for h in hours]
+    return {"type": "basic", "hours": hours, "minutes": minutes}
 
-        if hourly_focus:
-            # Create enhanced hourly chart with focus quality overlay
-            hours = list(range(24))
-            minutes = [hourly_focus.get(str(h), 0) for h in hours]
-            focus_quality = [focus_quality_by_hour.get(str(h), 0) for h in hours]
-
-            # Create dual chart showing time and quality
-            fig = make_subplots(
-                rows=2, cols=1,
-                subplot_titles=["Focus Time by Hour", "Focus Quality by Hour"],
-                vertical_spacing=0.15
-            )
-
-            # Top chart: Focus time with peak hours highlighted
-            colors = ['rgba(255, 99, 132, 0.8)' if h in peak_hours else 'rgba(54, 162, 235, 0.6)' for h in hours]
-
-            fig.add_trace(
-                go.Bar(
-                    x=hours,
-                    y=minutes,
-                    name="Focus Minutes",
-                    marker_color=colors,
-                    text=[f"{m:.0f}min" if m > 0 else "" for m in minutes],
-                    textposition="outside"
-                ),
-                row=1, col=1
-            )
-
-            # Bottom chart: Focus quality
-            fig.add_trace(
-                go.Scatter(
-                    x=hours,
-                    y=focus_quality,
-                    mode="lines+markers",
-                    name="Focus Quality",
-                    line=dict(color="green", width=3),
-                    marker=dict(size=8, color=focus_quality, colorscale="RdYlGn", cmin=0, cmax=10),
-                    fill="tonexty" if focus_quality else None
-                ),
-                row=2, col=1
-            )
-
-            # Update layout
-            fig.update_xaxes(title_text="Hour of Day", row=2, col=1, dtick=2)
-            fig.update_yaxes(title_text="Minutes", row=1, col=1)
-            fig.update_yaxes(title_text="Quality (1-10)", row=2, col=1, range=[0, 10])
-
-            fig.update_layout(
-                height=500,
-                showlegend=False,
-                title=None
-            )
-
-            st.plotly_chart(fig, use_container_width=True)
-
-            # Add insights
-            col1, col2 = st.columns(2)
-            with col1:
-                if peak_hours:
-                    peak_times = ", ".join([f"{h}:00" for h in peak_hours[:3]])
-                    st.success(f"ðŸŒŸ **Peak Hours:** {peak_times}")
-
-                total_focus_time = sum(minutes)
-                avg_session_quality = sum(focus_quality) / len([q for q in focus_quality if q > 0]) if any(focus_quality) else 0
-                st.info(f"â±ï¸ **Total Focus:** {total_focus_time:.0f} minutes")
-                st.info(f"ðŸŽ¯ **Avg Quality:** {avg_session_quality:.1f}/10")
-
-            with col2:
-                # Time patterns insights
-                patterns = time_patterns.get("patterns", [])
-                if patterns:
-                    st.markdown("**ðŸ’¡ Time Insights:**")
-                    for pattern in patterns[:3]:
-                        st.markdown(f"â€¢ {pattern}")
-        else:
-            st.info("No enhanced time pattern data available")
+def _render_focus_summary(focus_data: Dict[str, Any]):
+    """Render focus time summary metrics."""
+    if focus_data.get("type") != "enhanced":
+        return
+    peak_hours = focus_data.get("peak_hours", [])
+    if peak_hours:
+        peak_times = ", ".join([f"{h}:00" for h in peak_hours[:3]])
+        st.success(f"ðŸŒŸ **Peak Hours:** {peak_times}")
+    st.info(f"â±ï¸ **Total Focus:** {focus_data.get('total_focus_time', 0):.0f} minutes")
+    st.info(f"ðŸŽ¯ **Avg Quality:** {focus_data.get('avg_session_quality', 0):.1f}/10")
+
+def _render_focus_trends(focus_data: Dict[str, Any]):
+    """Render focus time trend charts."""
+    hours = focus_data.get("hours", [])
+    minutes = focus_data.get("minutes", [])
+    if focus_data.get("type") == "enhanced":
+        focus_quality = focus_data.get("focus_quality", [])
+        peak_hours = focus_data.get("peak_hours", [])
+        fig = make_subplots(rows=2, cols=1, subplot_titles=["Focus Time by Hour", "Focus Quality by Hour"], vertical_spacing=0.15)
+        colors = ['rgba(255, 99, 132, 0.8)' if h in peak_hours else 'rgba(54, 162, 235, 0.6)' for h in hours]
+        fig.add_trace(go.Bar(x=hours, y=minutes, name="Focus Minutes", marker_color=colors, text=[f"{m:.0f}min" if m > 0 else "" for m in minutes], textposition="outside"), row=1, col=1)
+        fig.add_trace(go.Scatter(x=hours, y=focus_quality, mode="lines+markers", name="Focus Quality", line=dict(color="green", width=3), marker=dict(size=8, color=focus_quality, colorscale="RdYlGn", cmin=0, cmax=10), fill="tonexty" if focus_quality else None), row=2, col=1)
+        fig.update_xaxes(title_text="Hour of Day", row=2, col=1, dtick=2)
+        fig.update_yaxes(title_text="Minutes", row=1, col=1)
+        fig.update_yaxes(title_text="Quality (1-10)", row=2, col=1, range=[0, 10])
+        fig.update_layout(height=500, showlegend=False, title=None)
+        st.plotly_chart(fig, use_container_width=True)
     else:
-        # Fallback to basic hourly analysis
-        timer_sessions = analytics_data.get("timer_sessions", [])
-        if not timer_sessions:
-            st.info("No timer sessions available")
-            return
-
-        # Group by hour of day
-        from collections import defaultdict
-        hourly_data = defaultdict(int)
-
-        for session in timer_sessions:
-            if session.get("started_at"):
-                try:
-                    # Extract hour from timestamp
-                    if "T" in session["started_at"]:
-                        hour = int(session["started_at"].split("T")[1][:2])
-                    else:
-                        hour = int(session["started_at"].split(" ")[1][:2])
-
-                    hourly_data[hour] += session.get("planned_duration_minutes", 0)
-                except (ValueError, IndexError):
-                    continue
-
-        if hourly_data:
-            hours = list(range(24))
-            minutes = [hourly_data.get(h, 0) for h in hours]
-
-            fig = px.bar(
-                x=hours,
-                y=minutes,
-                title="Focus Time by Hour of Day",
-                labels={"x": "Hour", "y": "Minutes"},
-                color=minutes,
-                color_continuous_scale="Blues"
-            )
+        fig = px.bar(x=hours, y=minutes, title="Focus Time by Hour of Day", labels={"x": "Hour", "y": "Minutes"}, color=minutes, color_continuous_scale="Blues")
+        fig.update_layout(height=400, showlegend=False)
+        st.plotly_chart(fig, use_container_width=True)
 
-            fig.update_layout(height=400, showlegend=False)
-            st.plotly_chart(fig, use_container_width=True)
+def _render_focus_patterns(focus_data: Dict[str, Any]):
+    """Render focus pattern analysis."""
+    if focus_data.get("type") != "enhanced":
+        return
+    patterns = focus_data.get("patterns", [])
+    if patterns:
+        st.markdown("**ðŸ’¡ Time Insights:**")
+        for pattern in patterns[:3]:
+            st.markdown(f"â€¢ {pattern}")
 
 
 def _render_tdd_phase_distribution(analytics_data: Dict[str, Any]):
-    """Render TDD phase distribution."""
+    """Render TDD phase distribution analysis."""
     if not PLOTLY_AVAILABLE:
         st.warning("Charts require plotly installation")
         return
-
-    st.markdown("### ðŸ”´ðŸŸ¢ðŸ”µ TDD Phase Distribution")
-
-    tasks = analytics_data.get("tasks", [])
-    if not tasks:
+    tdd_data = _calculate_tdd_metrics(analytics_data)
+    if not tdd_data.get("phase_counts"):
         st.info("No task data available")
         return
+    _render_tdd_overview(tdd_data)
+    _render_tdd_phase_chart(tdd_data)
+    _render_tdd_recommendations(tdd_data)
 
-    # Count tasks by TDD phase
-    phase_counts = {"red": 0, "green": 0, "refactor": 0, "unknown": 0}
 
+def _calculate_tdd_metrics(analytics_data: Dict[str, Any]) -> Dict[str, Any]:
+    """Calculate TDD phase metrics and balance scores."""
+    tasks = analytics_data.get("tasks", [])
+    phase_counts = {"red": 0, "green": 0, "refactor": 0, "unknown": 0}
     for task in tasks:
         phase = task.get("tdd_phase") or "unknown"
         phase = phase.lower() if isinstance(phase, str) else "unknown"
         if phase in phase_counts:
             phase_counts[phase] += 1
         else:
             phase_counts["unknown"] += 1
-
-    # Remove zero counts
     phase_counts = {k: v for k, v in phase_counts.items() if v > 0}
+    return {"phase_counts": phase_counts}
 
-    if phase_counts:
-        colors = {
-            "red": "#FF6B6B",
-            "green": "#51CF66",
-            "refactor": "#339AF0",
-            "unknown": "#ADB5BD"
-        }
 
-        fig = px.pie(
-            values=list(phase_counts.values()),
-            names=list(phase_counts.keys()),
-            title="Tasks by TDD Phase",
-            color_discrete_map=colors
-        )
+def _render_tdd_overview(tdd_data: Dict[str, Any]):
+    """Render TDD overview metrics."""
+    st.markdown("### ðŸ”´ðŸŸ¢ðŸ”µ TDD Phase Distribution")
+
+
+def _render_tdd_phase_chart(tdd_data: Dict[str, Any]):
+    """Render TDD phase distribution chart."""
+    phase_counts = tdd_data.get("phase_counts", {})
+    if not phase_counts:
+        return
+    colors = {
+        "red": "#FF6B6B",
+        "green": "#51CF66",
+        "refactor": "#339AF0",
+        "unknown": "#ADB5BD",
+    }
+    fig = px.pie(
+        values=list(phase_counts.values()),
+        names=list(phase_counts.keys()),
+        title="Tasks by TDD Phase",
+        color_discrete_map=colors,
+    )
+    fig.update_layout(height=400)
+    st.plotly_chart(fig, use_container_width=True)
+
+
+def _render_tdd_recommendations(tdd_data: Dict[str, Any]):
+    """Render TDD improvement recommendations."""
+    return
 
-        fig.update_layout(height=400)
-        st.plotly_chart(fig, use_container_width=True)
 
 
 def _render_epic_progress_chart(analytics_data: Dict[str, Any]):
-    """Render enhanced epic progress overview with productivity insights."""
+    """Render epic progress visualization."""
     if not PLOTLY_AVAILABLE:
         st.warning("Charts require plotly installation")
         return
-
     st.markdown("### ðŸ“Š Epic Progress")
+    progress_data = _calculate_epic_progress(analytics_data)
+    if not progress_data:
+        _render_basic_epic_progress(analytics_data)
+        return
+    _render_progress_overview(progress_data)
+    _render_progress_charts(progress_data)
+    _render_progress_details(progress_data)
 
+def _calculate_epic_progress(analytics_data: Dict[str, Any]) -> Dict[str, Any]:
+    """Calculate epic progress metrics and completion rates."""
     engine_enabled = analytics_data.get("analytics_engine_enabled", False)
     productivity_metrics = analytics_data.get("productivity_metrics", {})
-
     if engine_enabled and productivity_metrics:
-        # Enhanced epic analysis from analytics engine
         epic_analysis = productivity_metrics.get("epic_analysis", {})
+        epic_performance = epic_analysis.get("epic_performance", [])
+        if epic_performance and PANDAS_AVAILABLE:
+            df = pd.DataFrame(epic_performance)
+            return {"df": df, "analysis": epic_analysis}
+    return {}
+
+def _render_progress_overview(progress_data: Dict[str, Any]):
+    """Render epic progress overview."""
+    df = progress_data.get("df")
+    if df is None:
+        return
 
-        if epic_analysis:
-            epic_performance = epic_analysis.get("epic_performance", [])
-
-            if epic_performance and PANDAS_AVAILABLE:
-                # Create comprehensive epic dashboard
-                df = pd.DataFrame(epic_performance)
-
-                # Multi-metric epic chart
-                fig = make_subplots(
-                    rows=2, cols=2,
-                    subplot_titles=[
-                        "Points Earned by Epic",
-                        "Epic Velocity (Tasks/Week)", 
-                        "Epic Efficiency Score",
-                        "Progress vs Target"
-                    ],
-                    specs=[
-                        [{"type": "bar"}, {"type": "bar"}],
-                        [{"type": "scatter"}, {"type": "bar"}]
-                    ]
-                )
-
-                # Top-left: Points by Epic
-                fig.add_trace(
-                    go.Bar(
-                        x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []),
-                        y=df["points_earned"] if "points_earned" in df.columns else df.get("points", []),
-                        name="Points",
-                        marker_color="lightblue",
-                        text=df["points_earned"] if "points_earned" in df.columns else df.get("points", []),
-                        textposition="outside"
-                    ),
-                    row=1, col=1
-                )
-
-                # Top-right: Epic Velocity (if available)
-                if "velocity" in df.columns:
-                    fig.add_trace(
-                        go.Bar(
-                            x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []),
-                            y=df["velocity"],
-                            name="Velocity",
-                            marker_color="orange",
-                            text=[f"{v:.1f}" for v in df["velocity"]],
-                            textposition="outside"
-                        ),
-                        row=1, col=2
-                    )
-
-                # Bottom-left: Efficiency Score (if available)
-                if "efficiency_score" in df.columns:
-                    fig.add_trace(
-                        go.Scatter(
-                            x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []),
-                            y=df["efficiency_score"],
-                            mode="markers+lines",
-                            name="Efficiency",
-                            marker=dict(size=12, color=df["efficiency_score"], colorscale="RdYlGn", cmin=0, cmax=100),
-                            line=dict(color="green", width=2)
-                        ),
-                        row=2, col=1
-                    )
-
-                # Bottom-right: Progress vs Target (if available)
-                if "progress_percentage" in df.columns:
-                    fig.add_trace(
-                        go.Bar(
-                            x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []),
-                            y=df["progress_percentage"],
-                            name="Actual Progress",
-                            marker_color="lightgreen",
-                            opacity=0.7
-                        ),
-                        row=2, col=2
-                    )
-
-                    if "target_percentage" in df.columns:
-                        fig.add_trace(
-                            go.Scatter(
-                                x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []),
-                                y=df["target_percentage"],
-                                mode="markers+lines",
-                                name="Target",
-                                line=dict(color="red", dash="dash", width=2),
-                                marker=dict(size=8, color="red")
-                            ),
-                            row=2, col=2
-                        )
-
-                # Update layout
-                fig.update_layout(
-                    height=600,
-                    showlegend=False
-                )
-
-                # Update axes
-                fig.update_xaxes(tickangle=-45)
-                fig.update_yaxes(title_text="Points", row=1, col=1)
-                fig.update_yaxes(title_text="Tasks/Week", row=1, col=2)
-                fig.update_yaxes(title_text="Efficiency %", range=[0, 100], row=2, col=1)
-                fig.update_yaxes(title_text="Progress %", range=[0, 100], row=2, col=2)
-
-                st.plotly_chart(fig, use_container_width=True)
+def _render_progress_charts(progress_data: Dict[str, Any]):
+    """Render epic progress charts."""
+    df = progress_data.get("df")
+    if df is None:
+        return
+    fig = make_subplots(
+        rows=2,
+        cols=2,
+        subplot_titles=["Points Earned by Epic", "Epic Velocity (Tasks/Week)", "Epic Efficiency Score", "Progress vs Target"],
+        specs=[[{"type": "bar"}, {"type": "bar"}], [{"type": "scatter"}, {"type": "bar"}]],
+    )
+    fig.add_trace(
+        go.Bar(x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []),
+               y=df["points_earned"] if "points_earned" in df.columns else df.get("points", []),
+               name="Points", marker_color="lightblue", text=df["points_earned"] if "points_earned" in df.columns else df.get("points", []), textposition="outside"),
+        row=1, col=1,
+    )
+    if "velocity" in df.columns:
+        fig.add_trace(
+            go.Bar(x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []), y=df["velocity"], name="Velocity", marker_color="orange", text=[f"{v:.1f}" for v in df["velocity"]], textposition="outside"),
+            row=1, col=2,
+        )
+    if "efficiency_score" in df.columns:
+        fig.add_trace(
+            go.Scatter(x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []), y=df["efficiency_score"], mode="markers+lines", name="Efficiency", marker=dict(size=12, color=df["efficiency_score"], colorscale="RdYlGn", cmin=0, cmax=100), line=dict(color="green", width=2)),
+            row=2, col=1,
+        )
+    if "progress_percentage" in df.columns:
+        fig.add_trace(
+            go.Bar(x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []), y=df["progress_percentage"], name="Actual Progress", marker_color="lightgreen", opacity=0.7),
+            row=2, col=2,
+        )
+        if "target_percentage" in df.columns:
+            fig.add_trace(
+                go.Scatter(x=df["epic_name"] if "epic_name" in df.columns else df.get("name", []), y=df["target_percentage"], mode="markers+lines", name="Target", line=dict(color="red", dash="dash", width=2), marker=dict(size=8, color="red")),
+                row=2, col=2,
+            )
+    fig.update_layout(height=600, showlegend=False)
+    fig.update_xaxes(tickangle=-45)
+    fig.update_yaxes(title_text="Points", row=1, col=1)
+    fig.update_yaxes(title_text="Tasks/Week", row=1, col=2)
+    fig.update_yaxes(title_text="Efficiency %", range=[0, 100], row=2, col=1)
+    fig.update_yaxes(title_text="Progress %", range=[0, 100], row=2, col=2)
+    st.plotly_chart(fig, use_container_width=True)
+
+def _render_progress_details(progress_data: Dict[str, Any]):
+    """Render detailed epic progress information."""
+    df = progress_data.get("df")
+    if df is None:
+        return
+    col1, col2, col3 = st.columns(3)
+    with col1:
+        if "velocity" in df.columns and len(df) > 0:
+            top_velocity_epic = df.loc[df["velocity"].idxmax()]
+            epic_name = top_velocity_epic.get("epic_name", top_velocity_epic.get("name", "Unknown"))
+            st.success(f"ðŸš€ **Fastest Epic:** {epic_name}")
+            st.caption(f"Velocity: {top_velocity_epic['velocity']:.1f} tasks/week")
+    with col2:
+        if "efficiency_score" in df.columns and len(df) > 0:
+            most_efficient_epic = df.loc[df["efficiency_score"].idxmax()]
+            epic_name = most_efficient_epic.get("epic_name", most_efficient_epic.get("name", "Unknown"))
+            st.success(f"âš™ï¸ **Most Efficient:** {epic_name}")
+            st.caption(f"Efficiency: {most_efficient_epic['efficiency_score']:.1f}%")
+    with col3:
+        points_col = "points_earned" if "points_earned" in df.columns else "points"
+        total_points = df[points_col].sum() if points_col in df.columns else 0
+        avg_progress = df["progress_percentage"].mean() if "progress_percentage" in df.columns else 0
+        st.metric("Total Points", f"{total_points:,}", f"Avg Progress: {avg_progress:.1f}%")
 
-                # Epic insights
-                col1, col2, col3 = st.columns(3)
-
-                with col1:
-                    if "velocity" in df.columns and len(df) > 0:
-                        top_velocity_epic = df.loc[df["velocity"].idxmax()]
-                        epic_name = top_velocity_epic.get("epic_name", top_velocity_epic.get("name", "Unknown"))
-                        st.success(f"ðŸš€ **Fastest Epic:** {epic_name}")
-                        st.caption(f"Velocity: {top_velocity_epic['velocity']:.1f} tasks/week")
-
-                with col2:
-                    if "efficiency_score" in df.columns and len(df) > 0:
-                        most_efficient_epic = df.loc[df["efficiency_score"].idxmax()]
-                        epic_name = most_efficient_epic.get("epic_name", most_efficient_epic.get("name", "Unknown"))
-                        st.success(f"âš™ï¸ **Most Efficient:** {epic_name}")
-                        st.caption(f"Efficiency: {most_efficient_epic['efficiency_score']:.1f}%")
-
-                with col3:
-                    points_col = "points_earned" if "points_earned" in df.columns else "points"
-                    total_points = df[points_col].sum() if points_col in df.columns else 0
-                    avg_progress = df["progress_percentage"].mean() if "progress_percentage" in df.columns else 0
-                    st.metric("Total Points", f"{total_points:,}", f"Avg Progress: {avg_progress:.1f}%")
-            else:
-                # Fallback to basic epic chart
-                _render_basic_epic_progress(analytics_data)
-        else:
-            _render_basic_epic_progress(analytics_data)
-    else:
-        _render_basic_epic_progress(analytics_data)
 
 def _render_basic_epic_progress(analytics_data: Dict[str, Any]):
     """Render basic epic progress (fallback)."""
     epics = analytics_data.get("epics", [])
     if not epics:
         st.info("No epic data available")
         return
 
     # Get progress for each epic (simplified)
     epic_progress = []
     for epic in epics[:10]:  # Limit to 10 epics
         epic_name = epic.get("name", "Unknown")[:20] + "..."
         points = epic.get("points_earned", 0)
         status = epic.get("status", "unknown")
 
         epic_progress.append({
             "epic": epic_name,
             "points": points,
             "status": status
         })
 
     if epic_progress and PANDAS_AVAILABLE:
         df = pd.DataFrame(epic_progress)
 
         fig = px.bar(
 
EOF
)
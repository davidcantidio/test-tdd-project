 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/duration_system/cascade_transactions.py b/duration_system/cascade_transactions.py
index 081147dc5e651becae4551fc2c8836fabf203936..9ffdbc4ac05b2228d2c1eaf9f2414f29a21efa05 100644
--- a/duration_system/cascade_transactions.py
+++ b/duration_system/cascade_transactions.py
@@ -1,40 +1,42 @@
 #!/usr/bin/env python3
 """
 Simplified Cascade Transaction Manager
 Safe cascade delete operations with proper SQL parameter binding.
 SECURITY FIX: All SQL queries use parameter binding to prevent injection.
 """
 
 import sqlite3
 import logging
 from typing import List, Dict, Any, Optional
 from dataclasses import dataclass
 from datetime import datetime
 from contextlib import contextmanager
 import uuid
 
+from .query_builders import query_table
+
 logger = logging.getLogger(__name__)
 
 
 @dataclass
 class CascadeOperation:
     """Represents a cascade delete operation."""
     operation_id: str
     parent_table: str
     parent_id: int
     dry_run: bool = False
     started_at: Optional[datetime] = None
     completed_at: Optional[datetime] = None
     affected_tables: List[str] = None
     total_records_affected: int = 0
     error_message: Optional[str] = None
 
     def __post_init__(self):
         if self.affected_tables is None:
             self.affected_tables = []
 
 
 class CascadeTransactionManager:
     """Simplified cascade transaction manager with security focus."""
 
     def __init__(self, database_path: str):
@@ -55,53 +57,58 @@ class CascadeTransactionManager:
             'framework_epics': [
                 {'table': 'framework_tasks', 'foreign_key': 'epic_id'}
             ]
         }
 
     def get_cascade_impact(self, table: str, record_id: int) -> Dict[str, Any]:
         """Analyze cascade delete impact using safe SQL."""
         if table not in self.safe_relationships:
             return {'error': 'Table not supported for cascade operations'}
         
         impact = {
             'tables_affected': [],
             'estimated_records': 0,
             'warnings': []
         }
 
         try:
             with sqlite3.connect(self.database_path) as conn:
                 # SECURITY FIX: Use parameter binding for all queries
                 relationships = self.safe_relationships[table]
                 
                 for relationship in relationships:
                     child_table = relationship['table']
                     foreign_key = relationship['foreign_key']
                     
-                    # Use parameter binding to prevent SQL injection
-                    query = f"SELECT COUNT(*) FROM {child_table} WHERE {foreign_key} = ?"
-                    cursor = conn.execute(query, (record_id,))
+                    # Use query builder for secure parameter binding
+                    count_query, params = (
+                        query_table(child_table)
+                        .select("COUNT(*)")
+                        .where(foreign_key, "=", record_id)
+                        .build()
+                    )
+                    cursor = conn.execute(count_query, params)
                     count = cursor.fetchone()[0]
                     
                     if count > 0:
                         impact['tables_affected'].append(child_table)
                         impact['estimated_records'] += count
                 
                 # Add warnings based on impact
                 if impact['estimated_records'] > 100:
                     impact['warnings'].append("Large number of records to delete")
                 
                 if len(impact['tables_affected']) > 3:
                     impact['warnings'].append("Many tables affected")
 
         except Exception as e:
             logger.error(f"Error analyzing cascade impact: {e}")
             impact['error'] = str(e)
 
         return impact
 
     @contextmanager
     def cascade_transaction(self, operation: CascadeOperation):
         """Context manager for cascade operations."""
         operation.started_at = datetime.now()
         connection = None
         
@@ -155,63 +162,70 @@ class CascadeTransactionManager:
 
         # Perform actual deletion
         try:
             with self.cascade_transaction(operation) as conn:
                 self._perform_cascade_delete(conn, operation)
         except Exception as e:
             operation.error_message = str(e)
             raise
 
         return operation
 
     def _perform_cascade_delete(self, conn: sqlite3.Connection, operation: CascadeOperation):
         """Perform the actual cascade delete with safe SQL."""
         deleted_count = 0
         table = operation.parent_table
         record_id = operation.parent_id
         
         # Delete in reverse dependency order (children first)
         relationships = self.safe_relationships.get(table, [])
         
         # Reverse order for proper cascade
         for relationship in reversed(relationships):
             child_table = relationship['table']
             foreign_key = relationship['foreign_key']
             
-            # SECURITY FIX: Use parameter binding
-            delete_query = f"DELETE FROM {child_table} WHERE {foreign_key} = ?"
-            cursor = conn.execute(delete_query, (record_id,))
+            # SECURITY FIX: Use query builder for parameter binding
+            delete_query, params = (
+                query_table(child_table)
+                .delete()
+                .where(foreign_key, "=", record_id)
+                .build()
+            )
+            cursor = conn.execute(delete_query, params)
             
             if cursor.rowcount > 0:
                 deleted_count += cursor.rowcount
                 operation.affected_tables.append(child_table)
                 logger.debug(f"Deleted {cursor.rowcount} records from {child_table}")
 
         # Finally delete the parent record
-        # SECURITY FIX: Use parameter binding
-        parent_delete_query = f"DELETE FROM {table} WHERE id = ?"
-        cursor = conn.execute(parent_delete_query, (record_id,))
+        # SECURITY FIX: Use query builder for parameter binding
+        parent_delete_query, parent_params = (
+            query_table(table).delete().where("id", "=", record_id).build()
+        )
+        cursor = conn.execute(parent_delete_query, parent_params)
         
         if cursor.rowcount > 0:
             deleted_count += cursor.rowcount
             operation.affected_tables.append(table)
 
         operation.total_records_affected = deleted_count
 
 
 def safe_cascade_delete(table: str, record_id: int, database_path: str = "framework.db") -> Dict[str, Any]:
     """Safe cascade delete with comprehensive error handling."""
     try:
         manager = CascadeTransactionManager(database_path)
         operation = manager.cascade_delete(table, record_id)
         
         return {
             'success': True,
             'operation_id': operation.operation_id,
             'affected_tables': operation.affected_tables,
             'records_deleted': operation.total_records_affected,
             'duration_ms': (
                 (operation.completed_at - operation.started_at).total_seconds() * 1000
                 if operation.completed_at and operation.started_at else 0
             )
         }
         
diff --git a/duration_system/query_builders.py b/duration_system/query_builders.py
new file mode 100644
index 0000000000000000000000000000000000000000..3bcb2327d45593ad913eadfc7b8d1a928102d6e9
--- /dev/null
+++ b/duration_system/query_builders.py
@@ -0,0 +1,374 @@
+#!/usr/bin/env python3
+"""
+Secure Query Builder System
+Replaces ad-hoc SQL strings with parameterized, secure query builders.
+"""
+
+from __future__ import annotations
+
+from typing import Dict, List, Any, Optional, Union, Tuple, Set
+from enum import Enum
+from dataclasses import dataclass
+import re
+
+
+class QueryType(Enum):
+    """Query operation types."""
+    SELECT = "SELECT"
+    INSERT = "INSERT"
+    UPDATE = "UPDATE"
+    DELETE = "DELETE"
+
+
+class JoinType(Enum):
+    """SQL join types."""
+    INNER = "INNER JOIN"
+    LEFT = "LEFT JOIN"
+    RIGHT = "RIGHT JOIN"
+    FULL = "FULL OUTER JOIN"
+
+
+@dataclass
+class QueryCondition:
+    """Represents a WHERE condition."""
+    field: str
+    operator: str  # =, !=, >, <, >=, <=, LIKE, IN, NOT IN
+    value: Any
+    logical_op: str = "AND"  # AND, OR
+
+    def to_sql(self) -> Tuple[str, Any]:
+        """Convert condition to SQL with parameter."""
+        if self.operator == "IN":
+            placeholders = ",".join("?" for _ in self.value)
+            return f"{self.field} IN ({placeholders})", self.value
+        elif self.operator == "NOT IN":
+            placeholders = ",".join("?" for _ in self.value)
+            return f"{self.field} NOT IN ({placeholders})", self.value
+        else:
+            return f"{self.field} {self.operator} ?", [self.value]
+
+
+@dataclass
+class QueryJoin:
+    """Represents a table join."""
+    table: str
+    join_type: JoinType
+    on_condition: str
+
+
+class SecureQueryBuilder:
+    """Secure SQL query builder with parameter binding and validation."""
+
+    allowed_operators = {"=", "!=", ">", "<", ">=", "<=", "LIKE", "IN", "NOT IN"}
+
+    def __init__(self, table: str, allowed_fields: Optional[Set[str]] = None):
+        """Initialize query builder for specific table."""
+        self.table = table
+        self.query_type: Optional[QueryType] = None
+        self.select_fields: List[str] = []
+        self.conditions: List[QueryCondition] = []
+        self.joins: List[QueryJoin] = []
+        self.order_by_fields: List[str] = []
+        self.group_by_fields: List[str] = []
+        self.limit_value: Optional[int] = None
+        self.offset_value: Optional[int] = None
+        self.insert_data: Dict[str, Any] = {}
+        self.update_data: Dict[str, Any] = {}
+        self._allowed_fields = allowed_fields
+
+    # ------------------------------------------------------------------
+    # Helper validation methods
+    def _validate_field(self, field: str) -> None:
+        if self._allowed_fields is not None and field not in self._allowed_fields:
+            raise ValueError(f"Field {field} not allowed")
+        # Basic regex validation to avoid injection through field names
+        if not re.match(r"^[A-Za-z0-9_\.]+$", field):
+            raise ValueError(f"Invalid field name: {field}")
+
+    def _validate_operator(self, operator: str) -> None:
+        if operator not in self.allowed_operators:
+            raise ValueError(f"Operator {operator} not allowed")
+
+    # ------------------------------------------------------------------
+    # Query construction methods
+    def select(self, *fields: str) -> "SecureQueryBuilder":
+        """Add SELECT fields."""
+        self.query_type = QueryType.SELECT
+        if fields:
+            for field in fields:
+                self._validate_field(field)
+            self.select_fields.extend(fields)
+        else:
+            self.select_fields = ["*"]
+        return self
+
+    def insert(self, data: Dict[str, Any]) -> "SecureQueryBuilder":
+        """Set INSERT data."""
+        self.query_type = QueryType.INSERT
+        self.insert_data = data
+        return self
+
+    def update(self, data: Dict[str, Any]) -> "SecureQueryBuilder":
+        """Set UPDATE data."""
+        self.query_type = QueryType.UPDATE
+        self.update_data = data
+        return self
+
+    def delete(self) -> "SecureQueryBuilder":
+        """Set DELETE operation."""
+        self.query_type = QueryType.DELETE
+        return self
+
+    def where(
+        self,
+        field: str,
+        operator: str,
+        value: Any,
+        logical_op: str = "AND",
+    ) -> "SecureQueryBuilder":
+        """Add WHERE condition with validation."""
+        self._validate_field(field)
+        self._validate_operator(operator)
+        condition = QueryCondition(field, operator, value, logical_op)
+        self.conditions.append(condition)
+        return self
+
+    def where_in(self, field: str, values: List[Any]) -> "SecureQueryBuilder":
+        """Add WHERE IN condition."""
+        return self.where(field, "IN", values)
+
+    def where_like(self, field: str, pattern: str) -> "SecureQueryBuilder":
+        """Add WHERE LIKE condition."""
+        return self.where(field, "LIKE", pattern)
+
+    def join(
+        self,
+        table: str,
+        on_condition: str,
+        join_type: JoinType = JoinType.INNER,
+    ) -> "SecureQueryBuilder":
+        """Add table join."""
+        self.joins.append(QueryJoin(table, join_type, on_condition))
+        return self
+
+    def left_join(self, table: str, on_condition: str) -> "SecureQueryBuilder":
+        """Add LEFT JOIN."""
+        return self.join(table, on_condition, JoinType.LEFT)
+
+    def order_by(self, field: str, direction: str = "ASC") -> "SecureQueryBuilder":
+        """Add ORDER BY clause."""
+        self._validate_field(field)
+        self.order_by_fields.append(f"{field} {direction}")
+        return self
+
+    def group_by(self, field: str) -> "SecureQueryBuilder":
+        """Add GROUP BY clause."""
+        self._validate_field(field)
+        self.group_by_fields.append(field)
+        return self
+
+    def limit(self, count: int) -> "SecureQueryBuilder":
+        """Add LIMIT clause."""
+        self.limit_value = count
+        return self
+
+    def offset(self, count: int) -> "SecureQueryBuilder":
+        """Add OFFSET clause."""
+        self.offset_value = count
+        return self
+
+    def build(self) -> Tuple[str, List[Any]]:
+        """Build final SQL query with parameters and complexity checks."""
+        if len(self.joins) > 5:
+            raise ValueError("Too many joins in query")
+        if len(self.conditions) > 20:
+            raise ValueError("Too many conditions in query")
+
+        if self.query_type == QueryType.SELECT:
+            return self._build_select()
+        if self.query_type == QueryType.INSERT:
+            return self._build_insert()
+        if self.query_type == QueryType.UPDATE:
+            return self._build_update()
+        if self.query_type == QueryType.DELETE:
+            return self._build_delete()
+        raise ValueError("Query type not set")
+
+    def _build_select(self) -> Tuple[str, List[Any]]:
+        """Build SELECT query."""
+        query_parts = [f"SELECT {', '.join(self.select_fields)}"]
+        query_parts.append(f"FROM {self.table}")
+        params: List[Any] = []
+
+        for join in self.joins:
+            query_parts.append(f"{join.join_type.value} {join.table} ON {join.on_condition}")
+
+        if self.conditions:
+            where_parts: List[str] = []
+            for i, condition in enumerate(self.conditions):
+                sql_part, condition_params = condition.to_sql()
+                if i > 0:
+                    where_parts.append(condition.logical_op)
+                where_parts.append(sql_part)
+                params.extend(
+                    condition_params if isinstance(condition_params, list) else [condition_params]
+                )
+            query_parts.append("WHERE " + " ".join(where_parts))
+
+        if self.group_by_fields:
+            query_parts.append(f"GROUP BY {', '.join(self.group_by_fields)}")
+
+        if self.order_by_fields:
+            query_parts.append(f"ORDER BY {', '.join(self.order_by_fields)}")
+
+        if self.limit_value is not None:
+            query_parts.append(f"LIMIT {self.limit_value}")
+            if self.offset_value is not None:
+                query_parts.append(f"OFFSET {self.offset_value}")
+
+        return " ".join(query_parts), params
+
+    def _build_insert(self) -> Tuple[str, List[Any]]:
+        """Build INSERT query."""
+        fields = list(self.insert_data.keys())
+        placeholders = ",".join("?" for _ in fields)
+        query = f"INSERT INTO {self.table} ({', '.join(fields)}) VALUES ({placeholders})"
+        params = list(self.insert_data.values())
+        return query, params
+
+    def _build_update(self) -> Tuple[str, List[Any]]:
+        """Build UPDATE query."""
+        set_parts = [f"{field} = ?" for field in self.update_data.keys()]
+        query_parts = [f"UPDATE {self.table}", f"SET {', '.join(set_parts)}"]
+        params = list(self.update_data.values())
+
+        if self.conditions:
+            where_parts: List[str] = []
+            for i, condition in enumerate(self.conditions):
+                sql_part, condition_params = condition.to_sql()
+                if i > 0:
+                    where_parts.append(condition.logical_op)
+                where_parts.append(sql_part)
+                params.extend(
+                    condition_params if isinstance(condition_params, list) else [condition_params]
+                )
+            query_parts.append("WHERE " + " ".join(where_parts))
+
+        return " ".join(query_parts), params
+
+    def _build_delete(self) -> Tuple[str, List[Any]]:
+        """Build DELETE query."""
+        query_parts = [f"DELETE FROM {self.table}"]
+        params: List[Any] = []
+
+        if self.conditions:
+            where_parts: List[str] = []
+            for i, condition in enumerate(self.conditions):
+                sql_part, condition_params = condition.to_sql()
+                if i > 0:
+                    where_parts.append(condition.logical_op)
+                where_parts.append(sql_part)
+                params.extend(
+                    condition_params if isinstance(condition_params, list) else [condition_params]
+                )
+            query_parts.append("WHERE " + " ".join(where_parts))
+
+        return " ".join(query_parts), params
+
+
+class EpicQueryBuilder(SecureQueryBuilder):
+    """Specialized query builder for epics with common operations."""
+
+    def __init__(self):
+        super().__init__("framework_epics")
+
+    def with_client_info(self) -> "EpicQueryBuilder":
+        """Join with client information."""
+        self.left_join(
+            "framework_clients",
+            "framework_epics.client_id = framework_clients.id",
+        )
+        return self
+
+    def with_project_info(self) -> "EpicQueryBuilder":
+        """Join with project information."""
+        self.left_join(
+            "framework_projects",
+            "framework_epics.project_id = framework_projects.id",
+        )
+        return self
+
+    def active_only(self) -> "EpicQueryBuilder":
+        """Filter to active epics only."""
+        self.where("status", "!=", "archived")
+        return self
+
+    def by_client(self, client_id: int) -> "EpicQueryBuilder":
+        """Filter by client ID."""
+        self.where("client_id", "=", client_id)
+        return self
+
+    def with_points_range(self, min_points: int, max_points: int) -> "EpicQueryBuilder":
+        """Filter by points range."""
+        self.where("points_value", ">=", min_points)
+        self.where("points_value", "<=", max_points)
+        return self
+
+
+class TaskQueryBuilder(SecureQueryBuilder):
+    """Specialized query builder for tasks."""
+
+    def __init__(self):
+        super().__init__("framework_tasks")
+
+    def with_epic_info(self) -> "TaskQueryBuilder":
+        """Join with epic information."""
+        self.left_join(
+            "framework_epics",
+            "framework_tasks.epic_id = framework_epics.id",
+        )
+        return self
+
+    def by_tdd_phase(self, phase: str) -> "TaskQueryBuilder":
+        """Filter by TDD phase."""
+        self.where("tdd_phase", "=", phase)
+        return self
+
+    def by_status(self, status: str) -> "TaskQueryBuilder":
+        """Filter by task status."""
+        self.where("status", "=", status)
+        return self
+
+    def recent_tasks(self, days: int = 7) -> "TaskQueryBuilder":
+        """Filter to recent tasks."""
+        self.where("created_at", ">=", f"datetime('now', '-{days} days')")
+        return self
+
+
+# Factory functions for convenience
+def query_epics() -> EpicQueryBuilder:
+    """Create epic query builder."""
+    return EpicQueryBuilder()
+
+
+def query_tasks() -> TaskQueryBuilder:
+    """Create task query builder."""
+    return TaskQueryBuilder()
+
+
+def query_table(table_name: str) -> SecureQueryBuilder:
+    """Create generic query builder for any table."""
+    return SecureQueryBuilder(table_name)
+
+
+__all__ = [
+    "SecureQueryBuilder",
+    "EpicQueryBuilder",
+    "TaskQueryBuilder",
+    "QueryType",
+    "JoinType",
+    "QueryCondition",
+    "query_epics",
+    "query_tasks",
+    "query_table",
+]
 
EOF
)
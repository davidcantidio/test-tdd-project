 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/duration_system/duration_calculator.py b/duration_system/duration_calculator.py
index d5548e1d4f2de6af6658eb3473b12aa7e99c4f52..08255db1ae81193de3af73acc949eb46c1af34d6 100644
--- a/duration_system/duration_calculator.py
+++ b/duration_system/duration_calculator.py
@@ -1,42 +1,45 @@
 """
 Duration Calculator Engine for Epic Timeline Management
 
 This module provides automatic duration calculation between dates with support
 for business days, calendar days, and various time units used in real epic data.
 
 Focus: Duration System Implementation - Core calculation logic
 """
 
 from datetime import datetime, date, timedelta
 from typing import Optional, Tuple, Union, Dict, Any
 from enum import Enum
 import re
 import logging
 
 logger = logging.getLogger(__name__)
 
+# Average number of days per month in Gregorian calendar
+AVERAGE_DAYS_PER_MONTH = 365.25 / 12  # â‰ˆ30.4375 days
+
 
 class DurationUnit(Enum):
     """Supported duration units from real epic data"""
     DAYS = "dias"
     WEEKS = "semanas"
     MONTHS = "meses"
 
 
 class DateCalculationMode(Enum):
     """Date calculation modes"""
     CALENDAR_DAYS = "calendar"
     BUSINESS_DAYS = "business"
 
 
 class DurationCalculationError(Exception):
     """Custom exception for duration calculation errors"""
     pass
 
 
 class DurationCalculator:
     """
     Core engine for automatic duration calculation between dates.
     
     Supports:
     - Calendar days vs business days calculation
@@ -164,51 +167,52 @@ class DurationCalculator:
         elif unit_normalized in ['semana', 'semanas']:
             unit = DurationUnit.WEEKS
         elif unit_normalized in ['mes', 'meses', 'mÃªs']:
             unit = DurationUnit.MONTHS
         else:
             raise DurationCalculationError(f"Unsupported unit: {unit_str}")
         
         return value, unit
     
     def duration_to_days(self, value: float, unit: DurationUnit) -> float:
         """
         Convert duration value to days based on unit.
         
         Args:
             value: Numeric value 
             unit: Duration unit
             
         Returns:
             Duration converted to days
         """
         if unit == DurationUnit.DAYS:
             return value
         elif unit == DurationUnit.WEEKS:
             return value * 7.0
         elif unit == DurationUnit.MONTHS:
-            return value * 30.0  # Approximate 30 days per month
+            # Use average Gregorian month length for better accuracy
+            return value * AVERAGE_DAYS_PER_MONTH
         else:
             raise DurationCalculationError(f"Unknown unit: {unit}")
     
     def parse_and_convert_to_days(self, duration_str: str) -> float:
         """
         Parse duration string and convert to days in one step.
         
         Args:
             duration_str: Duration string from epic data
             
         Returns:
             Duration in days (float)
         """
         value, unit = self.parse_duration_string(duration_str)
         return self.duration_to_days(value, unit)
     
     def validate_date_consistency(
         self, 
         planned_start: Optional[Union[date, str]] = None,
         planned_end: Optional[Union[date, str]] = None,
         actual_start: Optional[Union[date, str]] = None,
         actual_end: Optional[Union[date, str]] = None,
         duration_days: Optional[float] = None
     ) -> Dict[str, Any]:
         """
diff --git a/streamlit_extension/utils/database.py b/streamlit_extension/utils/database.py
index 341dc76cc393ca9b25a2952f936b2e53ac9bedf3..9d5b0734513c6a638b2c52cc8b2b6be6f2fcc904 100644
--- a/streamlit_extension/utils/database.py
+++ b/streamlit_extension/utils/database.py
@@ -1,41 +1,42 @@
 """
 ðŸ—„ï¸ Database Management Utilities
 
 Streamlit-optimized database operations with:
 - Connection pooling
 - Caching strategies
 - SQLAlchemy integration
 - Error handling
 """
 
 import sqlite3
 from pathlib import Path
 from typing import Optional, Dict, Any, List, Union
 from contextlib import contextmanager
 from datetime import datetime
 import json
+import logging
 
 # Graceful imports
 try:
     import sqlalchemy as sa
     from sqlalchemy import create_engine, text
     from sqlalchemy.pool import StaticPool
     SQLALCHEMY_AVAILABLE = True
 except ImportError:
     sa = None
     create_engine = None
     text = None
     StaticPool = None
     SQLALCHEMY_AVAILABLE = False
 
 try:
     import pandas as pd
     PANDAS_AVAILABLE = True
 except ImportError:
     pd = None
     PANDAS_AVAILABLE = False
 
 try:
     import streamlit as st
     STREAMLIT_AVAILABLE = True
 except ImportError:
@@ -47,50 +48,52 @@ try:
     from ..config.streamlit_config import format_datetime_user_tz, format_time_ago_user_tz
     TIMEZONE_UTILS_AVAILABLE = True
 except ImportError:
     TIMEZONE_UTILS_AVAILABLE = False
     format_datetime_user_tz = None
     format_time_ago_user_tz = None
 
 # Import duration system for FASE 2.3 extension
 try:
     from duration_system.duration_calculator import DurationCalculator
     from duration_system.duration_formatter import DurationFormatter
     DURATION_SYSTEM_AVAILABLE = True
 except ImportError:
     DurationCalculator = None
     DurationFormatter = None
     DURATION_SYSTEM_AVAILABLE = False
 
 # Import caching system
 try:
     from .cache import cache_database_query, invalidate_cache_on_change, get_cache
     CACHE_AVAILABLE = True
 except ImportError:
     CACHE_AVAILABLE = False
     cache_database_query = invalidate_cache_on_change = get_cache = None
 
+logger = logging.getLogger(__name__)
+
 
 class DatabaseManager:
     """Streamlit-optimized database manager."""
     
     def __init__(self, framework_db_path: str = "framework.db", timer_db_path: str = "task_timer.db"):
         self.framework_db_path = Path(framework_db_path)
         self.timer_db_path = Path(timer_db_path)
         self.engines = {}
         
         if SQLALCHEMY_AVAILABLE:
             self._initialize_engines()
     
     def _initialize_engines(self):
         """Initialize SQLAlchemy engines with optimized settings."""
         if not SQLALCHEMY_AVAILABLE:
             return
         
         # Framework database engine
         if self.framework_db_path.exists():
             framework_url = f"sqlite:///{self.framework_db_path}"
             self.engines["framework"] = create_engine(
                 framework_url,
                 poolclass=StaticPool,
                 connect_args={
                     "check_same_thread": False,
@@ -1206,148 +1209,152 @@ class DatabaseManager:
                             stats[status] = count
                         total += count
                     stats["total"] = total
                     
                     return stats
                     
         except Exception as e:
             print(f"Error getting task statistics: {e}")
             return {"todo": 0, "in_progress": 0, "completed": 0, "total": 0}
     
     # ==================================================================================
     # DURATION SYSTEM EXTENSION METHODS (FASE 2.3)
     # ==================================================================================
     
     @cache_database_query("calculate_epic_duration", ttl=300) if CACHE_AVAILABLE else lambda f: f
     def calculate_epic_duration(self, epic_id: int) -> float:
         """Calculate total duration for an epic based on task dates.
         
         Args:
             epic_id: ID of the epic to calculate duration for
             
         Returns:
             Duration in days (float), or 0.0 if calculation fails
         """
         if not DURATION_SYSTEM_AVAILABLE:
-            print("Duration system not available - install duration_system package")
+            logger.warning("Duration system not available - install duration_system package")
             return 0.0
         
         try:
             with self.get_connection("framework") as conn:
                 # Get epic with date fields
                 if SQLALCHEMY_AVAILABLE:
                     result = conn.execute(text("""
                         SELECT planned_start_date, planned_end_date, 
                                actual_start_date, actual_end_date,
                                calculated_duration_days
                         FROM framework_epics 
                         WHERE id = :epic_id AND deleted_at IS NULL
                     """), {"epic_id": epic_id})
                     epic_row = result.fetchone()
                 else:
                     cursor = conn.cursor()
                     cursor.execute("""
                         SELECT planned_start_date, planned_end_date,
                                actual_start_date, actual_end_date,
                                calculated_duration_days
                         FROM framework_epics 
                         WHERE id = ? AND deleted_at IS NULL
                     """, (epic_id,))
                     epic_row = cursor.fetchone()
                 
                 if not epic_row:
                     return 0.0
                 
                 calculator = DurationCalculator()
                 
                 # Try to use existing calculated duration first
                 if epic_row[4] is not None:  # calculated_duration_days
                     return float(epic_row[4])
                 
                 # Calculate from actual dates if available
                 if epic_row[2] and epic_row[3]:  # actual_start_date, actual_end_date
                     return calculator.calculate_duration_days(epic_row[2], epic_row[3])
                 
                 # Fall back to planned dates
                 if epic_row[0] and epic_row[1]:  # planned_start_date, planned_end_date
                     return calculator.calculate_duration_days(epic_row[0], epic_row[1])
                 
                 # If no dates available, sum task durations
                 return self._calculate_epic_duration_from_tasks(epic_id)
                 
         except Exception as e:
-            print(f"Error calculating epic duration for {epic_id}: {e}")
+            logger.error("Error calculating epic duration for %s: %s", epic_id, e)
             return 0.0
     
     @invalidate_cache_on_change("db_query:get_epics:", "db_query:calculate_epic_duration:") if CACHE_AVAILABLE else lambda f: f
     def update_duration_description(self, epic_id: int, description: str) -> bool:
         """Update the duration description for an epic.
         
         Args:
             epic_id: ID of the epic to update
             description: New duration description (e.g., "1.5 dias", "1 semana")
             
         Returns:
             True if successful, False otherwise
         """
         if not DURATION_SYSTEM_AVAILABLE:
-            print("Duration system not available")
+            logger.warning("Duration system not available")
             return False
         
         try:
             # Parse and validate duration description
             calculator = DurationCalculator()
             duration_days = calculator.parse_and_convert_to_days(description)
-            
+
             with self.get_connection("framework") as conn:
-                if SQLALCHEMY_AVAILABLE:
-                    conn.execute(text("""
-                        UPDATE framework_epics 
-                        SET duration_description = :description,
-                            calculated_duration_days = :duration_days,
-                            updated_at = CURRENT_TIMESTAMP
-                        WHERE id = :epic_id
-                    """), {
-                        "description": description,
-                        "duration_days": duration_days,
-                        "epic_id": epic_id
-                    })
-                    conn.commit()
-                else:
-                    cursor = conn.cursor()
-                    cursor.execute("""
-                        UPDATE framework_epics 
-                        SET duration_description = ?, calculated_duration_days = ?, 
-                            updated_at = CURRENT_TIMESTAMP
-                        WHERE id = ?
-                    """, (description, duration_days, epic_id))
-                    conn.commit()
-                
-                return True
-                
+                try:
+                    if SQLALCHEMY_AVAILABLE:
+                        conn.execute(text("""
+                            UPDATE framework_epics
+                            SET duration_description = :description,
+                                calculated_duration_days = :duration_days,
+                                updated_at = CURRENT_TIMESTAMP
+                            WHERE id = :epic_id
+                        """), {
+                            "description": description,
+                            "duration_days": duration_days,
+                            "epic_id": epic_id
+                        })
+                        conn.commit()
+                    else:
+                        cursor = conn.cursor()
+                        cursor.execute("""
+                            UPDATE framework_epics
+                            SET duration_description = ?, calculated_duration_days = ?,
+                                updated_at = CURRENT_TIMESTAMP
+                            WHERE id = ?
+                        """, (description, duration_days, epic_id))
+                        conn.commit()
+                except Exception:
+                    conn.rollback()
+                    raise
+
+            return True
+
         except Exception as e:
-            print(f"Error updating duration description for epic {epic_id}: {e}")
+            logger.error("Error updating duration description for epic %s: %s", epic_id, e)
             return False
     
     @cache_database_query("get_epic_timeline", ttl=180) if CACHE_AVAILABLE else lambda f: f
     def get_epic_timeline(self, epic_id: int) -> Dict[str, Any]:
         """Get comprehensive timeline information for an epic.
         
         Args:
             epic_id: ID of the epic to get timeline for
             
         Returns:
             Dictionary with timeline data including dates, durations, and validation
         """
         if not DURATION_SYSTEM_AVAILABLE:
             return {"error": "Duration system not available"}
         
         try:
             with self.get_connection("framework") as conn:
                 # Get epic timeline data
                 if SQLALCHEMY_AVAILABLE:
                     result = conn.execute(text("""
                         SELECT id, epic_key, name, status,
                                planned_start_date, planned_end_date,
                                actual_start_date, actual_end_date,
                                calculated_duration_days, duration_description,
                                created_at, updated_at, completed_at
diff --git a/tests/test_duration_calculator.py b/tests/test_duration_calculator.py
index 05c86e7370a98f2940d6fc47569137c04e946938..e7059bd460cd3ec35d954b9934c7c3ab9fd9cd12 100644
--- a/tests/test_duration_calculator.py
+++ b/tests/test_duration_calculator.py
@@ -199,51 +199,52 @@ class TestDurationCalculator:
     def test_parse_duration_string_unsupported_unit(self):
         """Test error with unsupported unit"""
         # This should not happen with current regex, but test for robustness
         with pytest.raises(DurationCalculationError):
             # Patch the regex to allow invalid unit for testing
             self.calculator._duration_pattern = __import__('re').compile(r'^(\d+(?:\.\d+)?)\s*(invalid)$')
             self.calculator.parse_duration_string("1 invalid")
     
     # ==================================================================================
     # DURATION CONVERSION TESTS
     # ==================================================================================
     
     def test_duration_to_days_days_unit(self):
         """Test converting days unit to days"""
         days = self.calculator.duration_to_days(3.5, DurationUnit.DAYS)
         assert days == 3.5
     
     def test_duration_to_days_weeks_unit(self):
         """Test converting weeks unit to days"""
         days = self.calculator.duration_to_days(2.0, DurationUnit.WEEKS)
         assert days == 14.0
     
     def test_duration_to_days_months_unit(self):
         """Test converting months unit to days"""
         days = self.calculator.duration_to_days(1.0, DurationUnit.MONTHS)
-        assert days == 30.0
+        # Uses average Gregorian month length (~30.4375 days)
+        assert days == pytest.approx(30.4375)
     
     def test_parse_and_convert_to_days_real_epic_formats(self):
         """Test parsing and converting real epic duration formats"""
         # Test formats from real epic data
         test_cases = [
             ("1.5 dias", 1.5),
             ("2 dias", 2.0),
             ("5 dias", 5.0),
             ("1 semana", 7.0),
             ("4 dias", 4.0)
         ]
         
         for duration_str, expected_days in test_cases:
             days = self.calculator.parse_and_convert_to_days(duration_str)
             assert days == expected_days
     
     # ==================================================================================
     # DATE CONSISTENCY VALIDATION TESTS
     # ==================================================================================
     
     def test_validate_date_consistency_valid_planned_dates(self):
         """Test validation with valid planned dates"""
         result = self.calculator.validate_date_consistency(
             planned_start="2025-01-01",
             planned_end="2025-01-08",
 
EOF
)
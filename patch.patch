 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/streamlit_extension/utils/database.py b/streamlit_extension/utils/database.py
index 5551e928de2283d8cf35ca2068ecf1de8e4c2bab..207c0b7a729f180bd9049fec8127056919be24a5 100644
--- a/streamlit_extension/utils/database.py
+++ b/streamlit_extension/utils/database.py
@@ -100,61 +100,65 @@ class DatabaseManager:
                     "timeout": 20
                 },
                 echo=False
             )
         
         # Timer database engine  
         if self.timer_db_path.exists():
             timer_url = f"sqlite:///{self.timer_db_path}"
             self.engines["timer"] = create_engine(
                 timer_url,
                 poolclass=StaticPool,
                 connect_args={
                     "check_same_thread": False,
                     "timeout": 20
                 },
                 echo=False
             )
     
     @contextmanager
     def get_connection(self, db_name: str = "framework"):
         """Get database connection with context manager."""
         if SQLALCHEMY_AVAILABLE and db_name in self.engines:
             # Use SQLAlchemy engine
             conn = self.engines[db_name].connect()
             try:
+                # Ensure foreign keys are enforced
+                conn.execute(text("PRAGMA foreign_keys = ON"))
                 yield conn
             finally:
                 conn.close()
         else:
             # Fallback to sqlite3
             db_path = self.framework_db_path if db_name == "framework" else self.timer_db_path
             if not db_path.exists():
                 raise FileNotFoundError(f"Database not found: {db_path}")
-            
+
             conn = sqlite3.connect(str(db_path), timeout=20)
             conn.row_factory = sqlite3.Row
+            # Enforce foreign keys for sqlite connections
+            conn.execute("PRAGMA foreign_keys = ON")
             try:
                 yield conn
             finally:
                 conn.close()
     
     @cache_database_query("get_epics", ttl=300) if CACHE_AVAILABLE else lambda f: f
     def get_epics(self) -> List[Dict[str, Any]]:
         """Get all epics with intelligent caching."""
         try:
             with self.get_connection("framework") as conn:
                 if SQLALCHEMY_AVAILABLE:
                     result = conn.execute(text("""
                         SELECT id, epic_key, name, description, status, 
                                created_at, updated_at, completed_at,
                                points_earned, difficulty_level, project_id
                         FROM framework_epics 
                         WHERE deleted_at IS NULL
                         ORDER BY created_at DESC
                     """))
                     return [dict(row._mapping) for row in result]
                 else:
                     cursor = conn.cursor()
                     cursor.execute("""
                         SELECT id, epic_key, name, description, status,
                                created_at, updated_at, completed_at,
@@ -1540,130 +1544,122 @@ class DatabaseManager:
                     
                     return [dict(zip([col[0] for col in cursor.description], row)) 
                            for row in cursor.fetchall()]
                            
         except Exception:
             return []
     
     # ==================================================================================
     # HIERARCHY SYSTEM METHODS (CLIENT → PROJECT → EPIC → TASK) - SCHEMA V6
     # ==================================================================================
     
     @cache_database_query("get_clients", ttl=300) if CACHE_AVAILABLE else lambda f: f
     def get_clients(self, include_inactive: bool = True) -> List[Dict[str, Any]]:
         """Get all clients with caching support.
         
         Args:
             include_inactive: If True, include inactive/archived clients
             
         Returns:
             List of client dictionaries
         """
         try:
             with self.get_connection("framework") as conn:
                 query = """
                     SELECT id, client_key, name, description, industry, company_size,
-                           primary_contact_name, primary_contact_email, 
+                           primary_contact_name, primary_contact_email,
                            timezone, currency, preferred_language,
                            hourly_rate, contract_type, status, client_tier,
                            priority_level, account_manager_id, technical_lead_id,
                            created_at, updated_at, last_contact_date
-                    FROM framework_clients 
+                    FROM framework_clients
                     WHERE deleted_at IS NULL
                 """
-                
-                params = []
+
+                params: Dict[str, Any] = {}
                 if not include_inactive:
-                    query += " AND status = ?"
-                    params.append("active")
-                
+                    query += " AND status = :status"
+                    params["status"] = "active"
+
                 query += " ORDER BY priority_level DESC, name ASC"
-                
-                # Use sqlite3 for this method to avoid parameter issues
-                if False:  # Temporarily disable SQLAlchemy
-                    if params:
-                        result = conn.execute(text(query), {"status": params[0]})
-                    else:
-                        result = conn.execute(text(query))
+
+                if SQLALCHEMY_AVAILABLE:
+                    result = conn.execute(text(query), params)
                     return [dict(row._mapping) for row in result]
                 else:
                     cursor = conn.cursor()
                     cursor.execute(query, params)
                     return [dict(row) for row in cursor.fetchall()]
         except Exception as e:
             logger.error(f"Error loading clients: {e}")
             if STREAMLIT_AVAILABLE and st:
                 st.error(f"❌ Error loading clients: {e}")
             return []
     
     @cache_database_query("get_projects", ttl=300) if CACHE_AVAILABLE else lambda f: f
     def get_projects(self, client_id: Optional[int] = None, include_inactive: bool = False) -> List[Dict[str, Any]]:
         """Get projects with caching support.
         
         Args:
             client_id: Filter by specific client ID (optional)
             include_inactive: If True, include inactive/archived projects
             
         Returns:
             List of project dictionaries with client information
         """
         try:
             with self.get_connection("framework") as conn:
                 query = """
                     SELECT p.id, p.client_id, p.project_key, p.name, p.description,
                            p.summary, p.project_type, p.methodology, p.status,
                            p.priority, p.health_status, p.completion_percentage,
                            p.planned_start_date, p.planned_end_date,
                            p.actual_start_date, p.actual_end_date,
                            p.estimated_hours, p.actual_hours,
                            p.budget_amount, p.budget_currency, p.hourly_rate,
                            p.project_manager_id, p.technical_lead_id,
                            p.repository_url, p.deployment_url, p.documentation_url,
                            p.created_at, p.updated_at,
                            c.name as client_name, c.client_key as client_key,
                            c.status as client_status, c.client_tier
                     FROM framework_projects p
                     INNER JOIN framework_clients c ON p.client_id = c.id AND c.deleted_at IS NULL
                     WHERE p.deleted_at IS NULL
                 """
-                
-                params = []
+
+                params: Dict[str, Any] = {}
                 if client_id:
-                    query += " AND p.client_id = ?"
-                    params.append(client_id)
-                
+                    query += " AND p.client_id = :client_id"
+                    params["client_id"] = client_id
+
                 if not include_inactive:
                     query += " AND p.status NOT IN ('cancelled', 'archived')"
-                
+
                 query += " ORDER BY p.priority DESC, p.name ASC"
-                
-                # Use sqlite3 for this method to avoid parameter issues  
-                if False:  # Temporarily disable SQLAlchemy
-                    if client_id:
-                        result = conn.execute(text(query), {"client_id": client_id})
-                    else:
-                        result = conn.execute(text(query))
+
+                if SQLALCHEMY_AVAILABLE:
+                    result = conn.execute(text(query), params)
                     return [dict(row._mapping) for row in result]
                 else:
                     cursor = conn.cursor()
                     cursor.execute(query, params)
                     return [dict(row) for row in cursor.fetchall()]
         except Exception as e:
             logger.error(f"Error loading projects: {e}")
             if STREAMLIT_AVAILABLE and st:
                 st.error(f"❌ Error loading projects: {e}")
             return []
     
     @cache_database_query("get_epics_with_hierarchy", ttl=300) if CACHE_AVAILABLE else lambda f: f
     def get_epics_with_hierarchy(self, project_id: Optional[int] = None, client_id: Optional[int] = None) -> List[Dict[str, Any]]:
         """Get epics with complete hierarchy information (client → project → epic).
         
         Args:
             project_id: Filter by specific project ID (optional)
             client_id: Filter by specific client ID (optional)
             
         Returns:
             List of epic dictionaries with client and project information
         """
         try:
             with self.get_connection("framework") as conn:
                 query = """
@@ -1820,51 +1816,51 @@ class DatabaseManager:
                 params = []
                 if project_id:
                     query += " AND project_id = ?"
                     params.append(project_id)
                 elif client_id:
                     query += " AND client_id = ?"
                     params.append(client_id)
                 
                 query += " ORDER BY client_name, project_name"
                 
                 if SQLALCHEMY_AVAILABLE:
                     result = conn.execute(text(query), params)
                     return [dict(row._mapping) for row in result]
                 else:
                     cursor = conn.cursor()
                     cursor.execute(query, params)
                     return [dict(row) for row in cursor.fetchall()]
         except Exception as e:
             logger.error(f"Error loading project dashboard: {e}")
             return []
     
     # ==================================================================================
     # HIERARCHY CRUD OPERATIONS
     # ==================================================================================
     
-    @invalidate_cache_on_change("db_query:get_clients:") if CACHE_AVAILABLE else lambda f: f
+    @invalidate_cache_on_change("db_query:get_clients:", "db_query:get_client_dashboard:") if CACHE_AVAILABLE else lambda f: f
     def create_client(self, client_key: str, name: str, description: str = "", 
                      industry: str = "", company_size: str = "startup",
                      primary_contact_name: str = "", primary_contact_email: str = "",
                      hourly_rate: float = 0.0, **kwargs) -> Optional[int]:
         """Create a new client.
         
         Args:
             client_key: Unique client identifier
             name: Client company name
             description: Client description
             industry: Industry sector
             company_size: Company size category
             primary_contact_name: Main contact person
             primary_contact_email: Main contact email
             hourly_rate: Default hourly rate for this client
             **kwargs: Additional client fields
             
         Returns:
             Client ID if successful, None otherwise
         """
         try:
             client_data = {
                 'client_key': client_key,
                 'name': name,
                 'description': description,
@@ -1889,51 +1885,56 @@ class DatabaseManager:
                 
                 if SQLALCHEMY_AVAILABLE:
                     # Convert to named parameters for SQLAlchemy
                     named_placeholders = ', '.join([f':{key}' for key in client_data.keys()])
                     result = conn.execute(
                         text(f"INSERT INTO framework_clients ({columns}) VALUES ({named_placeholders})"),
                         client_data
                     )
                     conn.commit()
                     return result.lastrowid
                 else:
                     cursor = conn.cursor()
                     cursor.execute(
                         f"INSERT INTO framework_clients ({columns}) VALUES ({placeholders})",
                         list(client_data.values())
                     )
                     conn.commit()
                     return cursor.lastrowid
                     
         except Exception as e:
             logger.error(f"Error creating client: {e}")
             if STREAMLIT_AVAILABLE and st:
                 st.error(f"❌ Error creating client: {e}")
             return None
     
-    @invalidate_cache_on_change("db_query:get_projects:", "db_query:get_hierarchy_overview:") if CACHE_AVAILABLE else lambda f: f
+    @invalidate_cache_on_change(
+        "db_query:get_projects:",
+        "db_query:get_hierarchy_overview:",
+        "db_query:get_client_dashboard:",
+        "db_query:get_project_dashboard:"
+    ) if CACHE_AVAILABLE else lambda f: f
     def create_project(self, client_id: int, project_key: str, name: str,
                       description: str = "", project_type: str = "development",
                       methodology: str = "agile", **kwargs) -> Optional[int]:
         """Create a new project.
         
         Args:
             client_id: ID of the client who owns this project
             project_key: Unique project identifier within client
             name: Project name
             description: Project description
             project_type: Type of project (development, maintenance, etc.)
             methodology: Development methodology (agile, waterfall, etc.)
             **kwargs: Additional project fields
             
         Returns:
             Project ID if successful, None otherwise
         """
         try:
             project_data = {
                 'client_id': client_id,
                 'project_key': project_key,
                 'name': name,
                 'description': description,
                 'project_type': project_type,
                 'methodology': methodology,
 
EOF
)